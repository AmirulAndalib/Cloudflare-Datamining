{
	"locale": "en-us",
	"post": {
		"access": true,
		"authors": [
			{
				"id": "5d1644b141acde0011a94f51",
				"name": "Filippo Valsorda",
				"slug": "filippo",
				"profile_image": "http://blog.cloudflare.com/content/images/2018/02/K6rX3ZSn_400x400.jpg",
				"cover_image": "http://blog.cloudflare.com/content/images/2018/08/general@2x-26.png",
				"bio": null,
				"website": null,
				"location": null,
				"facebook": null,
				"twitter": "@filosottile",
				"meta_title": null,
				"meta_description": null,
				"url": "http://blog.cloudflare.com/author/filippo/"
			}
		],
		"canonical_url": null,
		"codeinjection_foot": null,
		"codeinjection_head": null,
		"comment_id": "4791",
		"comments": false,
		"created_at": "2016-04-27T15:51:49.000+01:00",
		"custom_excerpt": "Go native vendoring (a.k.a. GO15VENDOREXPERIMENT) allows you to freeze dependencies by putting them in a vendor folder in your project. The compiler will then look there before searching the GOPATH.",
		"custom_template": null,
		"email_subject": null,
		"excerpt": "Go native vendoring (a.k.a. GO15VENDOREXPERIMENT) allows you to freeze dependencies by putting them in a vendor folder in your project. The compiler will then look there before searching the GOPATH.",
		"feature_image": null,
		"feature_image_alt": null,
		"feature_image_caption": null,
		"featured": false,
		"frontmatter": null,
		"html": "<!--kg-card-begin: markdown--><p><a href=\"https://docs.google.com/document/d/1Bz5-UB7g2uPBdOx-rw5t9MxJwkfpx90cqG9AFL0JAYo/edit\">Go native vendoring</a> (a.k.a. GO15VENDOREXPERIMENT) allows you to freeze dependencies by putting them in a <code>vendor</code> folder in your project. The compiler will then look there before searching the GOPATH.</p>\n<p>The only annoyance compared to using a per-project GOPATH, which is what we used to do, is that you might forget to vendor a package that you have in your GOPATH. The program will build for you, but it won't for anyone else. Back to the <a href=\"https://www.urbandictionary.com/define.php?term=wfm\">WFM</a> times!</p>\n<p>I decided I wanted something, a tool, to check that all my (non-stdlib) dependencies were vendored.</p>\n<p>At first I thought of using <a href=\"https://golang.org/cmd/go/#hdr-List_packages\"><code>go list</code></a>, which Dave Cheney appropriately called a <a href=\"http://dave.cheney.net/2014/09/14/go-list-your-swiss-army-knife\">swiss army knife</a>, but while it can show the entire recursive dependency tree (format <code>.Deps</code>), there's no way to know from the templating engine if a dependency is in the standard library.</p>\n<p>We could just pass each output back into <code>go list</code> to check for <code>.Standard</code>, but I thought this would be a good occasion to build a very simple static analysis tool. Go's simplicity and libraries make it a very easy task, as you will see.</p>\n<h3 id=\"firstloadingtheprogram\">First, loading the program</h3>\n<p>We use <a href=\"https://godoc.org/golang.org/x/tools/go/loader\"><code>golang.org/x/tools/go/loader</code></a> to load the packages passed as arguments on the command line, including the test files based on a flag.</p>\n<pre><code class=\"language-go\">var conf loader.Config\nfor _, p := range flag.Args() {\n    if *tests {\n        conf.ImportWithTests(p)\n    } else {\n        conf.Import(p)\n    }\n}\nprog, err := conf.Load()\nif err != nil {\n    log.Fatal(err)\n}\nfor p := range prog.AllPackages {\n    fmt.Println(p.Path())\n}\n</code></pre>\n<p>With these few lines we already replicated <code>go list -f {{ .Deps }}</code>!</p>\n<p>The only missing loading feature here is wildcard (<code>./...</code>) support. That code <a href=\"https://github.com/golang/go/blob/87bca88c703c1f14fe8473dc2f07dc521cf2b989/src/cmd/go/main.go#L365\">is in the go tool source</a> and it's unexported. There's an <a href=\"https://github.com/golang/go/issues/8768\">issue</a> about exposing it, but for now packages <a href=\"https://github.com/golang/lint/blob/58f662d2fc0598c6c36a92ae29af1caa6ec89d7a/golint/import.go\">are just copy-pasting it</a>. We'll use a packaged version of that code, <a href=\"https://github.com/kisielk/gotool\"><code>github.com/kisielk/gotool</code></a>:</p>\n<pre><code class=\"language-go\">for _, p := range gotool.ImportPaths(flag.Args()) {\n</code></pre>\n<p>Finally, since we are only interested in the dependency tree today we instruct the parser to only go as far as the imports statements and we ignore the resulting &quot;not used&quot; errors:</p>\n<pre><code class=\"language-go\">conf.ParserMode = parser.ImportsOnly\nconf.AllowErrors = true\nconf.TypeChecker.Error = func(error) {}\n</code></pre>\n<h3 id=\"thentheactuallogic\">Then, the actual logic</h3>\n<p>We now have a <code>loader.Program</code> object, which holds references to various <code>loader.PackageInfo</code> objects, which in turn are a combination of package, AST and types information. All you need to perform any kind of complex analysis. Not that we are going to do that today :)</p>\n<p>We'll just replicate <a href=\"https://github.com/golang/go/blob/87bca88c703c1f14fe8473dc2f07dc521cf2b989/src/cmd/go/pkg.go#L183-L194\">the <code>go list</code> logic to recognize stdlib packages</a> and remove the packages passed on the command line from the list:</p>\n<pre><code class=\"language-go\">initial := make(map[*loader.PackageInfo]bool)\nfor _, pi := range prog.InitialPackages() {\n    initial[pi] = true\n}\n\nvar packages []*loader.PackageInfo\nfor _, pi := range prog.AllPackages {\n    if initial[pi] {\n        continue\n    }\n    if len(pi.Files) == 0 {\n        continue // virtual stdlib package\n    }\n    filename := prog.Fset.File(pi.Files[0].Pos()).Name()\n    if !strings.HasPrefix(filename, build.Default.GOROOT) ||\n        !isStandardImportPath(pi.Pkg.Path()) {\n        packages = append(packages, pi)\n    }\n}\n</code></pre>\n<p>Then we just have to print a warning if any remaining package is not in a <code>/vendor/</code> folder:</p>\n<pre><code class=\"language-go\">for _, pi := range packages {\n    if strings.Index(pi.Pkg.Path(), &quot;/vendor/&quot;) == -1 {\n        fmt.Println(&quot;[!] dependency not vendored:&quot;, pi.Pkg.Path())\n    }\n}\n</code></pre>\n<p>Done! You can find the tool here: <a href=\"https://github.com/FiloSottile/vendorcheck\">https://github.com/FiloSottile/vendorcheck</a></p>\n<h3 id=\"furtherreading\">Further reading</h3>\n<p><a href=\"https://github.com/golang/example/tree/master/gotypes#gotypes-the-go-type-checker\">This document</a> maintained by Alan Donovan will tell you more than I'll ever know about the static analysis tooling.</p>\n<p>Note that you might be tempted to use <code>go/importer</code> and <code>types.Importer[From]</code> instead of <code>x/go/loader</code>. Don't do that. That doesn't load the source but reads compiled <code>.a</code> files, which <strong>can be stale or missing</strong>. Static analysis tools that spit out &quot;package not found&quot; for existing packages or, worse, incorrect results because of this are a pet peeve of mine.</p>\n<p><em>If you now feel the urge to write static analysis tools, know that the CloudFlare Go team <a href=\"https://www.cloudflare.com/join-our-team/\">is hiring in London, San Francisco and Singapore</a>!</em></p>\n<!--kg-card-end: markdown-->",
		"id": "5d16453b41acde0011a95591",
		"meta_description": "In this post we'll build together a very simple Go static analysis tool, vendorcheck. It will make sure that all our dependencies are vendored.",
		"meta_title": null,
		"og_description": null,
		"og_image": null,
		"og_title": null,
		"primary_author": {
			"id": "5d1644b141acde0011a94f51",
			"name": "Filippo Valsorda",
			"slug": "filippo",
			"profile_image": "http://blog.cloudflare.com/content/images/2018/02/K6rX3ZSn_400x400.jpg",
			"cover_image": "http://blog.cloudflare.com/content/images/2018/08/general@2x-26.png",
			"bio": null,
			"website": null,
			"location": null,
			"facebook": null,
			"twitter": "@filosottile",
			"meta_title": null,
			"meta_description": null,
			"url": "http://blog.cloudflare.com/author/filippo/"
		},
		"primary_tag": {
			"id": "5d16450341acde0011a951a0",
			"name": "Tools",
			"slug": "tools",
			"description": null,
			"feature_image": null,
			"visibility": "public",
			"meta_title": null,
			"meta_description": null,
			"og_image": null,
			"og_title": null,
			"og_description": null,
			"twitter_image": null,
			"twitter_title": null,
			"twitter_description": null,
			"codeinjection_head": null,
			"codeinjection_foot": null,
			"canonical_url": null,
			"accent_color": null,
			"url": "http://blog.cloudflare.com/tag/tools/"
		},
		"published_at": "2016-04-27T16:01:15.000+01:00",
		"reading_time": 2,
		"slug": "building-the-simplest-go-static-analysis-tool",
		"tags": [
			{
				"id": "5d16450341acde0011a951a0",
				"name": "Tools",
				"slug": "tools",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/tools/"
			},
			{
				"id": "5d16450341acde0011a95215",
				"name": "Go",
				"slug": "go",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/go/"
			},
			{
				"id": "5d16450341acde0011a95214",
				"name": "Programming",
				"slug": "programming",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/programming/"
			}
		],
		"title": "Building the simplest Go static analysis tool",
		"twitter_description": null,
		"twitter_image": null,
		"twitter_title": null,
		"updated_at": "2018-08-27T20:10:28.000+01:00",
		"url": "http://blog.cloudflare.com/building-the-simplest-go-static-analysis-tool/",
		"uuid": "846d320c-3786-4916-9a0b-f61eef443d57",
		"visibility": "public"
	}
}