{
	"locale": "en-us",
	"post": {
		"id": "5d16453b41acde0011a95705",
		"uuid": "607ad519-5652-4688-9fff-33fbb1fc9d3f",
		"title": "Bootstrapping a Typescript Worker",
		"slug": "bootstrapping-a-typescript-worker",
		"html": "<!--kg-card-begin: markdown--><p>Cloudflare <a href=\"https://developers.cloudflare.com/workers/about/\">Workers</a> allows you to quickly deploy Javascript code to our 150+ data centers around the world and execute very close to your end-user.  The edit/compile/debug story is already pretty amazing using the <a href=\"https://dash.cloudflare.com/workers\">Workers IDE</a> with integrated Chrome Dev Tools. However, for those hankering for some <a href=\"https://www.typescriptlang.org/\">Typescript</a> and an IDE with static analysis, autocomplete and that jazz, follow along to see one way to set up a Typescript project with <a href=\"https://www.jetbrains.com/webstorm/\">Webstorm</a> and npm run upload your code straight to the edge.</p>\n<h3 id=\"prerequisites\">Pre Requisites</h3>\n<p>My environment looks like this:</p>\n<ul>\n<li>macOS High Sierra</li>\n<li>node v8.11.3</li>\n<li>npm v5.6.0</li>\n<li>Webstorm v2018.1.3</li>\n</ul>\n<p>You'll also need a <a href=\"https://support.cloudflare.com/hc/en-us/articles/201720164\">Cloudflare domain</a> and to <a href=\"https://www.cloudflare.com/a/workers\">activate Workers</a> on it.</p>\n<p>I'll be using cryptoserviceworker.com</p>\n<p>I'll also use Yeoman to build our initial scaffolding. Install it with <code>npm install yo -g</code></p>\n<h2 id=\"gettingstarted\">Getting Started</h2>\n<p>Let's start with a minimal node app with a &quot;hello world&quot; class and a test.</p>\n<pre><code>mkdir cryptoserviceworker &amp;&amp; cd cryptoserviceworker\nnpm install generator-node-typescript -g\nyo node-typescript\n</code></pre>\n<p>That generator creates the following directory structure:</p>\n<pre><code>drwxr-xr-x   16 steve  staff     512 Jun 18 20:40 .\ndrwxr-xr-x   10 steve  staff     320 Jun 18 20:35 ..\n-rw-r--r--    1 steve  staff     197 Jun 18 20:40 .editorconfig\n-rw-r--r--    1 steve  staff      96 Jun 18 20:40 .gitignore\n-rw-r--r--    1 steve  staff     147 Jun 18 20:40 .npmignore\n-rw-r--r--    1 steve  staff     267 Jun 18 20:40 .travis.yml\ndrwxr-xr-x    5 steve  staff     160 Jun 18 20:40 .vscode\n-rw-r--r--    1 steve  staff    1066 Jun 18 20:40 LICENSE\n-rw-r--r--    1 steve  staff    2071 Jun 18 20:40 README.md\ndrwxr-xr-x    4 steve  staff     128 Jun 18 20:40 __tests__\ndrwxr-xr-x  479 steve  staff   15328 Jun 18 20:40 node_modules\n-rw-r--r--    1 steve  staff  244624 Jun 18 20:40 package-lock.json\n-rw-r--r--    1 steve  staff    1506 Jun 18 20:40 package.json\ndrwxr-xr-x    4 steve  staff     128 Jun 18 20:40 src\n-rw-r--r--    1 steve  staff     454 Jun 18 20:40 tsconfig.json\n-rw-r--r--    1 steve  staff      73 Jun 18 20:40 tslint.json\n</code></pre>\n<p>It includes default settings, a task runner, an initial Typescript config and more. We won't use all of it, but it's a good starting point.</p>\n<h2 id=\"firsttest\">First Test</h2>\n<p>If we take a look at the contents of <code>src/greeter.ts</code>, we'll see it's a very Typescript implementation of hello world.</p>\n<pre><code>$ cat greeter.ts \nexport class Greeter {\n  private greeting: string;\n\n  constructor(message: string) {\n    this.greeting = message;\n  }\n\n  public greet(): string {\n    return `Bonjour, ${this.greeting}!`;\n  }\n}\n</code></pre>\n<p>Because Yeoman has set up our test infrastructure, we should be able exercise the code using the greeter test in <code>__tests__/greeter-spec.ts</code></p>\n<pre><code>import { Greeter } from '../src/greeter';\n\ntest('Should greet with message', () =&gt; {\n  const greeter = new Greeter('friend');\n  expect(greeter.greet()).toBe('Bonjour, friend!');\n});\n</code></pre>\n<p>This generator uses jest. It's installed locally, but let's install it globally for convenience and run it!</p>\n<pre><code>npm install jest -g\njest\n PASS  __tests__/greeter-spec.ts\n PASS  __tests__/index-spec.ts\n\nTest Suites: 2 passed, 2 total\nTests:       2 passed, 2 total\nSnapshots:   0 total\nTime:        1.867s\nRan all test suites.\n\n</code></pre>\n<p>OK, so we have a testable Typescript template. Let's fire up Webstorm and write some code!</p>\n<h3 id=\"helloworldwithworkers\">Hello, World with Workers</h3>\n<p>A hello world implementation in Typescript might look something like this:</p>\n<p><img src=\"http://blog.cloudflare.com/content/images/2018/06/typescript-hello-world.png\" alt=\"Hello world first attempt\" loading=\"lazy\"></p>\n<p>Webstorm doesn't like it as you can see from the red error highlights. Even though Request and Response are part of the Service Worker API and will be available to us in the V8 runtime, Typescript doesn't know about them yet. <a href=\"https://www.npmjs.com/package/node-fetch\">node-fetch</a> provides an implementation for node, so let’s install that.</p>\n<pre><code class=\"language-bash\">npm install node-fetch\nnpm install @types/node-fetch\n</code></pre>\n<p>That made Webstorm happier. It’s been able to locate the type definitions.</p>\n<p><img src=\"http://blog.cloudflare.com/content/images/2018/06/typescript-hello-world2.png\" alt=\"Hello world with type defs\" loading=\"lazy\"></p>\n<p>Now let's write a test. Create a new file <strong>tests</strong>/worker-spec.ts:</p>\n<pre><code class=\"language-typescript\">import { Request } from &quot;node-fetch&quot;;\nimport { Worker } from &quot;../src/worker&quot;;\n\ntest('Should say hello', () =&gt; {\n\n  const worker = new Worker();\n  const request = new Request(&quot;https://cryptoserviceworker.com/&quot;);\n  const response = worker.handle(request);\n  expect(response.status).toEqual(200);\n  expect(response.body).toEqual(&quot;Hello, world!&quot;);\n});\n</code></pre>\n<p>And delete the other files and tests so we're just working worker.ts and worker-spect.ts</p>\n<p>Run <code>jest</code></p>\n<pre><code> PASS  __tests__/worker-spec.ts\n PASS  __tests__/worker-spec.js\n\nTest Suites: 2 passed, 2 total\nTests:       2 passed, 2 total\nSnapshots:   0 total\nTime:        1.213s, estimated 2s\n</code></pre>\n<p>OK, so our test passed, but notice it ran both the Typescript and the Javascript? Let's restrict to just Typescript. Go into package.json, locate jest and change</p>\n<p><code>&quot;testRegex&quot;: &quot;(/__tests__/.*|\\\\.(test|spec))\\\\.(ts|js)$&quot;,</code> to<br>\n<code>&quot;testRegex&quot;: &quot;(/__tests__/.*)\\\\-spec.ts$&quot;</code></p>\n<p>Run it again:</p>\n<pre><code class=\"language-bash\">jest\n PASS  __tests__/worker-spec.ts\n  ✓ Should say hello (8ms)\n\nTest Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        1.123s, estimated 2s\nRan all test suites.\n\n</code></pre>\n<p>Better. OK, ship it!</p>\n<h3 id=\"fromlocaltypescripttoworkercompatiblejavascript\">From Local Typescript to Worker Compatible Javascript.</h3>\n<p>Let's take a look at <code>src/worker.js</code> to see how our Typescript transpiled.</p>\n<pre><code class=\"language-javascript\">&quot;use strict&quot;;\nObject.defineProperty(exports, &quot;__esModule&quot;, { value: true });\nconst node_fetch_1 = require(&quot;node-fetch&quot;);\nclass Worker {\n    handle(request) {\n        return new node_fetch_1.Response('Hello, world!');\n    }\n}\nexports.Worker = Worker;\n</code></pre>\n<p>Actually, let's try it in the Cloudflare Workers IDE and try it for real. Go to your <a href=\"https://dash.cloudflare.com\">dashboard</a>, click the Workers icon and then &quot;Launch Editor&quot;</p>\n<p><img src=\"http://blog.cloudflare.com/content/images/2018/06/workers-dashboard.png\" alt=\"Workers Dashboard\" loading=\"lazy\"></p>\n<p>First things first, check the canonical Hello World implementation works.</p>\n<p><img src=\"http://blog.cloudflare.com/content/images/2018/06/hello-world-ide.png\" alt=\"Hello world in IDE\" loading=\"lazy\"></p>\n<p>Awesome, now let's replace it with our &quot;transpiled from Typescript&quot; version:</p>\n<p><img src=\"http://blog.cloudflare.com/content/images/2018/06/fail1.png\" alt=\"Fail 1\" loading=\"lazy\"></p>\n<p>Fail. OK, so the out of the box &quot;transpiled from typescript&quot; is not going to work. Let's make the changes necessary to get it run manually, then incorporate that into the build process.</p>\n<p><strong>Error #1: Uncaught ReferenceError: exports is not defined at line 2</strong><br>\nThat's easy enough, let's add <code>var exports = {}</code>. Update Preview.</p>\n<p><strong>Error #2: Uncaught ReferenceError: require is not defined at line 4</strong></p>\n<p>True, we're running in V8 on the Cloudflare Edge and the only code is what we uploaded. There are no &quot;node_modules&quot; to include. Plus, that line was only for dev anyway. Remove it. Update Preview.</p>\n<p><strong>Error #3: No event handlers were registered. This script does nothing.</strong></p>\n<p>Right, we need to invoke the code. Let's add a snippet to the top of the file to actually invoke our worker.</p>\n<pre><code class=\"language-javascript\">addEventListener('fetch', event =&gt; {\n  let worker = new exports.Worker();\n  event.respondWith(worker.handle(event.request));\n})\n</code></pre>\n<p><strong>Error #4: Uncaught ReferenceError: <code>node_fetch_1</code> is not defined</strong></p>\n<p>Right, we removed that because <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Request\">Response</a> is a native object when it runs in the context of a worker. So remove the <code>node_fetch_1</code> prefix.</p>\n<p><strong>Error #5: exports.__esModule = true does nothing</strong></p>\n<p>So let's remove that.</p>\n<p>Success!!</p>\n<p><img src=\"http://blog.cloudflare.com/content/images/2018/06/hello-world-success.png\" alt=\"Success\" loading=\"lazy\"></p>\n<p>OK, so with some massaging, we got a Worker transpiled from Typescript to execute. We:</p>\n<ul>\n<li>Added a line to create an exports object</li>\n<li>Removed the dev dependency on &quot;node_fetch&quot;</li>\n<li>Removed the exports.__esModule = true line</li>\n</ul>\n<p>Let's add that to our build process so we can have &quot;Worker-ready&quot; Javascript every time we make a change to our Typescript.</p>\n<h3 id=\"grunt\">Grunt</h3>\n<p>I'm going to use Grunt to automate that. Here's my new <code>worker.ts</code></p>\n<pre><code class=\"language-typescript\">// --BEGIN PREAMBLE--\n/// //Invoke worker\n/// var exports = {};\n/// addEventListener('fetch', event =&gt; {\n///   event.respondWith(fetchAndApply(event.request))\n/// });\n///\n/// async function fetchAndApply(request) {\n///   let worker = new exports.Worker();\n///   return worker.handle(request);\n/// }\n// --END PREAMBLE--\n\n// --BEGIN COMMENT--\n// mock the methods and objects that will be available in the browser\nimport { Request, Response } from 'node-fetch';\n// --END COMMENT--\nexport class Worker {\n  public handle(request: Request) {\n    return new Response(&quot;Hello, world!&quot;)\n  }\n}\n</code></pre>\n<p>I want to uncomment the preamble to invoke our script, comment out the dev dependencies and remove the __esmodule line. Let's install Grunt, a text-replace module and create a <code>Gruntfile.js</code></p>\n<pre><code class=\"language-bash\">npm install grunt-cli -g\nnpm install grunt --save-dev\nnpm install grunt-replace --save-dev\ntouch Gruntfile.js\n</code></pre>\n<p>My <code>Gruntfile.js</code> looks like this</p>\n<pre><code class=\"language-json\">module.exports = function (grunt) {\n\n  grunt.loadNpmTasks('grunt-replace');\n  grunt.initConfig({\n    replace: {\n      comments: {\n        options: {\n          patterns: [\n            {\n              /* Comment imports for node during dev */\n              match: /--BEGIN COMMENT--[\\s\\S]*?--END COMMENT--/g,\n              replacement: 'Dev environment code block removed by build'\n            },\n            {\n              /* Uncomment preamble for production to process the request */\n              match: /\\/\\/\\//mg,\n              replacement: ''\n            }\n          ]\n        },\n        files: [\n          { expand: true, flatten: true, src: ['src/worker.ts'], dest: 'build/' }\n        ]\n      },\n      exports: {\n        //remove the exports line that typescript includes without an option to\n        //suppress, but is not in the v8 env that workers run in.\n        options: {\n          patterns: [\n            {\n              match: /exports.__esModule = true;/g,\n              replacement: &quot;// exports line commented by build&quot;\n            }\n          ]\n        },\n        files: [\n          { expand: true, flatten: true, src: ['build/worker.js'], dest: 'build/' }\n        ]\n      }\n    }\n  });\n\n  grunt.registerTask('prepare-typescript', 'replace:comments');\n  grunt.registerTask('fix-export', 'replace:exports');\n};\n\n</code></pre>\n<p>There are two tasks. The first is the comment/uncomment step that we want before our Typescript is transpiled.</p>\n<p>The second is to remove the <code>exports.__esmodule = true</code> line</p>\n<pre><code class=\"language-bash\">$ grunt prepare-typescript\nRunning &quot;replace:comments&quot; (replace) task\n&gt;&gt; 11 replacements in 1 file.\n\nDone.\n</code></pre>\n<p>If we open <code>build/worker.ts</code>, we see this:</p>\n<pre><code class=\"language-typescript\">// --BEGIN PREAMBLE--\n //Invoke worker\n var exports = {};\n addEventListener('fetch', event =&gt; {\n   event.respondWith(fetchAndApply(event.request))\n });\n\n async function fetchAndApply(request) {\n   let worker = new exports.Worker();\n   return worker.handle(request);\n }\n// --END PREAMBLE--\n\n// Dev environment code block removed by build\nexport class Worker {\n  public handle(request: Request) {\n    return new Response(&quot;Hello, world!&quot;)\n  }\n}\n</code></pre>\n<p>Opening <code>build/worker.js</code> you'll see a whole lot of code generated for handling async functions. That's because we're using the <code>async</code> keyword in the preamble.</p>\n<pre><code>&quot;use strict&quot;;\nvar __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this &amp;&amp; this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] &amp; 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), &quot;throw&quot;: verb(1), &quot;return&quot;: verb(2) }, typeof Symbol === &quot;function&quot; &amp;&amp; (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(&quot;Generator is already executing.&quot;);\n        while (_) try {\n            if (f = 1, y &amp;&amp; (t = y[op[0] &amp; 2 ? &quot;return&quot; : op[0] ? &quot;throw&quot; : &quot;next&quot;]) &amp;&amp; !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [0, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length &gt; 0 &amp;&amp; t[t.length - 1]) &amp;&amp; (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 &amp;&amp; (!t || (op[1] &gt; t[0] &amp;&amp; op[1] &lt; t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 &amp;&amp; _.label &lt; t[1]) { _.label = t[1]; t = op; break; }\n                    if (t &amp;&amp; _.label &lt; t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] &amp; 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nexports.__esModule = true;\n// --BEGIN PREAMBLE--\n//Invoke worker\nvar exports = {};\naddEventListener('fetch', function (event) {\n    event.respondWith(fetchAndApply(event.request));\n});\nfunction fetchAndApply(request) {\n    return __awaiter(this, void 0, void 0, function () {\n        var worker;\n        return __generator(this, function (_a) {\n            worker = new exports.Worker();\n            return [2 /*return*/, worker.handle(request)];\n        });\n    });\n}\n// --END PREAMBLE--\n// Dev environment code block removed by build\nvar Worker = /** @class */ (function () {\n    function Worker() {\n    }\n    Worker.prototype.handle = function (request) {\n        return new Response(&quot;Hello, world!&quot;);\n    };\n    return Worker;\n}());\nexports.Worker = Worker;\n</code></pre>\n<p>Now let's remove that <code>exports.__esModule = true</code> line.</p>\n<p><code>grunt fix-export</code></p>\n<p>and now we'll see instead in the worker.js <code>// exports line commented by build</code>.</p>\n<h3 id=\"putittogether\">Put it together</h3>\n<p>I just want to run <code>npm run build</code> and get Worker-friendly Javascript. Let's modify <code>package.json</code> to do just that. Change</p>\n<p><code>&quot;build&quot;: &quot;tsc --pretty&quot;</code> to <code>&quot;build&quot;: &quot;grunt prepare-typescript &amp;&amp; tsc build/*.ts --pretty --skipLibCheck; grunt fix-export&quot;,</code></p>\n<p>And run it.</p>\n<p><code>npm run build</code> will result in</p>\n<pre><code>&quot;use strict&quot;;\nvar __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this &amp;&amp; this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] &amp; 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), &quot;throw&quot;: verb(1), &quot;return&quot;: verb(2) }, typeof Symbol === &quot;function&quot; &amp;&amp; (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(&quot;Generator is already executing.&quot;);\n        while (_) try {\n            if (f = 1, y &amp;&amp; (t = y[op[0] &amp; 2 ? &quot;return&quot; : op[0] ? &quot;throw&quot; : &quot;next&quot;]) &amp;&amp; !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [0, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length &gt; 0 &amp;&amp; t[t.length - 1]) &amp;&amp; (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 &amp;&amp; (!t || (op[1] &gt; t[0] &amp;&amp; op[1] &lt; t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 &amp;&amp; _.label &lt; t[1]) { _.label = t[1]; t = op; break; }\n                    if (t &amp;&amp; _.label &lt; t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] &amp; 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n// exports line commented by build\n// --BEGIN PREAMBLE--\n//Invoke worker\nvar exports = {};\naddEventListener('fetch', function (event) {\n    event.respondWith(fetchAndApply(event.request));\n});\nfunction fetchAndApply(request) {\n    return __awaiter(this, void 0, void 0, function () {\n        var worker;\n        return __generator(this, function (_a) {\n            worker = new exports.Worker();\n            return [2 /*return*/, worker.handle(request)];\n        });\n    });\n}\n// --END PREAMBLE--\n// Dev environment code block removed by build\nvar Worker = /** @class */ (function () {\n    function Worker() {\n    }\n    Worker.prototype.handle = function (request) {\n        return new Response('Hello, world!');\n    };\n    return Worker;\n}());\nexports.Worker = Worker;\n</code></pre>\n<p>Paste that into the Workers IDE... works first time.</p>\n<h3 id=\"automatedupload\">Automated upload</h3>\n<p>It's going to get old uploading from our IDE to the Web IDE every time we want to test a change and we're going to want to auto deploy from CI at some point. Thankfully there's <a href=\"https://developers.cloudflare.com/workers/api/\">Workers Configuration API</a>, which makes it very simple to upload a Worker automatically:</p>\n<p><code>curl -X PUT &quot;https://api.cloudflare.com/client/v4/zones/:zone_id/workers/script&quot; -H &quot;X-Auth-Email:YOUR_CLOUDFLARE_EMAIL&quot; -H &quot;X-Auth-Key:ACCOUNT_AUTH_KEY&quot; -H &quot;Content-Type:application/javascript&quot; --data-binary &quot;@PATH_TO_YOUR_WORKER_SCRIPT&quot;</code></p>\n<p>OK, so we need our zone ID, Cloudflare email, auth key and path to the binary. I'm going to create Grunt task that uses the <a href=\"https://www.npmjs.com/package/dotenv\">dotenv</a> package to load config from a .env file or environment variables.</p>\n<p>Create a <code>.env</code> file that looks like this:</p>\n<pre><code>CF_WORKER_ZONE_ID=xxxxxxxxxxxxxxxxxxx\nCF_WORKER_EMAIL=steve@example.com\nCF_WORKER_AUTH_KEY=xxxxxxxxxxxxxxxxxx\nCF_WORKER_PATH=build/worker.js\n</code></pre>\n<p>To locate your zone ID and auth key, go to the dashboard, select your zone and click the &quot;Overview&quot; icon.</p>\n<p><img src=\"http://blog.cloudflare.com/content/images/2018/06/overview.png\" alt=\"Overview\" loading=\"lazy\"></p>\n<p>The zone ID is right there, then click &quot;Get API key&quot; and choose the &quot;Global API Key&quot; to get the Auth Key.</p>\n<p><img src=\"http://blog.cloudflare.com/content/images/2018/06/api-key.png\" alt=\"API key\" loading=\"lazy\"></p>\n<p>Fill out your .env with those values and then add the following to your Gruntfile which will:</p>\n<ul>\n<li>Read your config</li>\n<li>Upload to Cloudflare</li>\n<li>Parse any success or error messages.</li>\n</ul>\n<pre><code>grunt.registerTask('upload-worker', 'Uploads workers to Cloudflare', function(path) {\n\n    require('dotenv').config();\n    const fs = require('fs');\n    const log = console;\n\n    const done = this.async();\n    const conf = readConfig();\n    path = path || grunt.option('path') || process.env.CF_WORKER_PATH;\n    if (!path) {\n      fail(&quot;path is required&quot;);\n    }\n    if (!fs.existsSync(path)) {\n      fail(`path not found ${path}`);\n    }\n\n    let script = fs.readFileSync(path);\n    log.info(&quot;Uploading...&quot;);\n    let url = `https://api.cloudflare.com/client/v4/zones/${conf.zoneId}/workers/script`;\n    let options = {\n      url: url,\n      method: 'PUT',\n      headers: {\n        'Content-Type': 'application/javascript'\n      },\n      body: script\n    };\n    invokeApi(options, conf, done);\n  });\n\n  function invokeApi(options, conf, done) {\n\n    // Add authentication to the request\n    options.headers = options.headers || {};\n    Object.assign(options.headers, {\n      'X-Auth-Email': conf.email,\n      'X-Auth-Key': conf.apiKey,\n    });\n\n    request(options, function(error, response) {\n      try {\n        if (error) {\n          log.error(error);\n          fail(`API failure ${response.statusCode} error: ${error}`);\n          done();\n          return;\n        }\n        let body = JSON.parse(response.body);\n        if (body) {\n          logResult(body);\n        }\n        done();\n      } catch (e) {\n        fail(`Unhandled error. ${e}`);\n        done();\n      }\n    });\n  }\n\n  function logResult(body) {\n    body.success ? log.error(&quot;Status: Success&quot;) : log.error(&quot;Status: Failed&quot;);\n    let errors = body.errors || [];\n    if (errors) {\n      log.info(` Errors: ${errors.length}`);\n      for (let e of errors) {\n        log.error(` Code: ${e.code} Message: ${e.message}`);\n      }\n    }\n    let messages = body.messages || [];\n    if (messages) {\n      log.info(` Messages ${messages.length}`);\n      for (let msg of messages) {\n        log.info(` ${msg}`);\n      }\n    }\n    let result = body.result;\n    log.info(&quot; Result&quot;);\n    log.info(` ${JSON.stringify(result, null, 2)}`);\n  }\n\n  function readConfig() {\n    let zoneId = grunt.option('zoneId') || process.env.CF_WORKER_ZONE_ID;\n    let email = grunt.option('email') || process.env.CF_WORKER_EMAIL;\n    let apiKey = grunt.option('apiKey') || process.env.CF_WORKER_AUTH_KEY;\n\n    log.debug(&quot;zoneID: &quot; + zoneId);\n    log.debug(&quot;email: &quot; + email);\n    log.debug(&quot;apiKey: &quot; + &quot;*&quot;.repeat(apiKey.length));\n\n    if (!zoneId || !email || !apiKey) {\n      fail(&quot;zone id, cloudflare email and api key are required&quot;);\n    }\n    return {\n      zoneId: zoneId,\n      email: email,\n      apiKey: apiKey\n    }\n  }\n\n  function fail(message) {\n    grunt.fail.fatal(message, TASK_FAILED);\n  }\n</code></pre>\n<p>Finally, let's add a new task to <code>package.json</code> so we can just <code>npm run upload</code> any time we update our Worker.</p>\n<p><code>&quot;upload&quot;: &quot;grunt upload-worker&quot;</code></p>\n<pre><code class=\"language-bash\">npm run upload-worker\n\nRunning &quot;upload-worker&quot; task\nzoneID: **************\nemail: steve@example.com\napiKey: *************************************\nUploading...\nStatus: Success\n Errors: 0\n Messages 0\n Result\n {\n  &quot;script&quot;...\n }\n</code></pre>\n<p>Voila! Script uploaded. OK, so if it's uploaded, we can call call it remotely:</p>\n<p><code>$ curl https://cryptoserviceworker.com/hello</code></p>\n<p>Hmmm... nothing. Ah, we haven't actually configured Workers to route any requests to our Worker. You can do this via the API, but since it's a one off, I'll do it in the web IDE.</p>\n<p><img src=\"http://blog.cloudflare.com/content/images/2018/06/routes.png\" alt=\"Add routes\" loading=\"lazy\"></p>\n<p>And try again:</p>\n<pre><code>$ curl https://cryptoserviceworker.com/hello\nHello, world!\n</code></pre>\n<p>Success! OK, so to recap:</p>\n<ul>\n<li>We've bootstrapped a Typescript project using NodeJS and Webstorm</li>\n<li>Written a &quot;Hello, World&quot; worker in Typescript</li>\n<li>Setup build tasks to modify the code for Workers</li>\n<li>Automatically uploading to the Cloudflare edge with <code>npm run upload</code></li>\n<li>...</li>\n<li>Profit</li>\n</ul>\n<hr>\n<p><em><small>If you have a worker you'd like to share, or want to check out workers from other Cloudflare users, visit the <a href=\"https://community.cloudflare.com/tags/recipe-exchange\">“Recipe Exchange”</a> in the Workers section of the <a href=\"https://community.cloudflare.com/c/developers/workers\">Cloudflare Community Forum</a>. </small></em></p>\n<!--kg-card-end: markdown-->",
		"comment_id": "5b2b29567cbc6900bf7f433a",
		"feature_image": "http://blog.cloudflare.com/content/images/2018/06/workers-social.png",
		"featured": false,
		"visibility": "public",
		"created_at": "2018-06-21T05:28:06.000+01:00",
		"updated_at": "2018-06-28T19:26:03.000+01:00",
		"published_at": "2018-06-27T14:00:00.000+01:00",
		"custom_excerpt": "Cloudflare Workers allows you to quickly deploy Javascript code to our 150+ data centers around the world and execute very close to your end-user. The edit/compile/debug story is already pretty amazing using the Workers IDE with integrated Chrome Dev Tools. ",
		"codeinjection_head": null,
		"codeinjection_foot": null,
		"custom_template": null,
		"canonical_url": null,
		"tags": [
			{
				"id": "5d16450341acde0011a95165",
				"name": "JavaScript",
				"slug": "javascript",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/javascript/"
			},
			{
				"id": "5d16450341acde0011a95252",
				"name": "Serverless",
				"slug": "serverless",
				"description": null,
				"feature_image": "http://blog.cloudflare.com/content/images/2020/10/Serverless.png",
				"visibility": "public",
				"meta_title": "Cloudflare Blog: Serverless",
				"meta_description": "Cloudflare blog posts tagged 'serverless'.",
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/serverless/"
			},
			{
				"id": "5d16450341acde0011a95253",
				"name": "Cloudflare Workers",
				"slug": "workers",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/workers/"
			}
		],
		"authors": [
			{
				"id": "5d1644b141acde0011a94fc5",
				"name": "Steven Pack",
				"slug": "stevenpack",
				"profile_image": "http://blog.cloudflare.com/content/images/2022/08/steven-pack.png",
				"cover_image": "http://blog.cloudflare.com/content/images/2018/08/general@2x-123.png",
				"bio": "Partner Engineering Director",
				"website": null,
				"location": "San Francisco Bay Area, California",
				"facebook": null,
				"twitter": "@steven_pack",
				"meta_title": null,
				"meta_description": null,
				"url": "http://blog.cloudflare.com/author/stevenpack/"
			}
		],
		"primary_author": {
			"id": "5d1644b141acde0011a94fc5",
			"name": "Steven Pack",
			"slug": "stevenpack",
			"profile_image": "http://blog.cloudflare.com/content/images/2022/08/steven-pack.png",
			"cover_image": "http://blog.cloudflare.com/content/images/2018/08/general@2x-123.png",
			"bio": "Partner Engineering Director",
			"website": null,
			"location": "San Francisco Bay Area, California",
			"facebook": null,
			"twitter": "@steven_pack",
			"meta_title": null,
			"meta_description": null,
			"url": "http://blog.cloudflare.com/author/stevenpack/"
		},
		"primary_tag": {
			"id": "5d16450341acde0011a95165",
			"name": "JavaScript",
			"slug": "javascript",
			"description": null,
			"feature_image": null,
			"visibility": "public",
			"meta_title": null,
			"meta_description": null,
			"og_image": null,
			"og_title": null,
			"og_description": null,
			"twitter_image": null,
			"twitter_title": null,
			"twitter_description": null,
			"codeinjection_head": null,
			"codeinjection_foot": null,
			"canonical_url": null,
			"accent_color": null,
			"url": "http://blog.cloudflare.com/tag/javascript/"
		},
		"url": "http://blog.cloudflare.com/bootstrapping-a-typescript-worker/",
		"excerpt": "Cloudflare Workers allows you to quickly deploy Javascript code to our 150+ data centers around the world and execute very close to your end-user. The edit/compile/debug story is already pretty amazing using the Workers IDE with integrated Chrome Dev Tools. ",
		"reading_time": 14,
		"access": true,
		"comments": false,
		"og_image": null,
		"og_title": null,
		"og_description": null,
		"twitter_image": null,
		"twitter_title": null,
		"twitter_description": null,
		"meta_title": null,
		"meta_description": null,
		"email_subject": null,
		"frontmatter": null,
		"feature_image_alt": null,
		"feature_image_caption": null
	}
}