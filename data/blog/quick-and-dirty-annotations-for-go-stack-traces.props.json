{
	"locale": "en-us",
	"post": {
		"id": "5d16453b41acde0011a9553a",
		"uuid": "674af39d-4933-4e4a-8f5e-5d67efd323b8",
		"title": "Quick and dirty annotations for Go stack traces",
		"slug": "quick-and-dirty-annotations-for-go-stack-traces",
		"html": "<!--kg-card-begin: markdown--><p>CloudFlare’s DNS server, <a href=\"http://blog.cloudflare.com/tag/rrdns/\">RRDNS</a>, is entirely written in Go and typically runs tens of thousands goroutines. Since goroutines are cheap and Go I/O is blocking we run one goroutine per file descriptor we listen on and queue new packets for processing.</p>\n<p><img src=\"http://blog.cloudflare.com/content/images/2015/08/6372385465_014a4e56af_z.jpg\" alt=\"\" loading=\"lazy\"><small><a href=\"https://creativecommons.org/licenses/by-sa/2.0/\">CC BY-SA 2.0</a> <a href=\"https://www.flickr.com/photos/wiredforsound23/6372385465/\">image</a> by <a href=\"https://www.flickr.com/photos/wiredforsound23/\">wiredforlego</a></small></p>\n<p>When there are thousands of goroutines running, debug output quickly becomes difficult to interpret. For example, last week I was tracking down a problem with a file descriptor and wanted to know what its listening goroutine was doing. <em>With 40k stack traces, good luck figuring out which one is having trouble.</em></p>\n<p>Go stack traces include parameter values, but most Go types are (or are implemented as) pointers, so what you will see passed to the goroutine function is just a meaningless memory address.</p>\n<p>We have a couple options to make sense of the addresses: get a heap dump at the same time as the stack trace and cross-reference the pointers, or have a debug endpoint that prints a goroutine/pointer -&gt; IP map. Neither are seamless.</p>\n<h3 id=\"underscoretotherescue\">Underscore to the rescue</h3>\n<p>However, we know that <em>integers are shown in traces</em>, so what we did is first <em>convert IPv4 addresses to their uint32 representation</em>:</p>\n<pre><code class=\"language-go\">// addrToUint32 takes a TCPAddr or UDPAddr and converts its IP to a uint32.\n// If the IP is v6, 0xffffffff is returned.\nfunc addrToUint32(addr net.Addr) uint32 {\n       var ip net.IP\n       switch addr := addr.(type) {\n       case *net.TCPAddr:\n               ip = addr.IP\n       case *net.UDPAddr:\n               ip = addr.IP\n       case *net.IPAddr:\n               ip = addr.IP\n       }\n       if ip == nil {\n               return 0\n       }\n       ipv4 := ip.To4()\n       if ipv4 == nil {\n               return math.MaxUint32\n       }\n       return uint32(ipv4[0])&lt;&lt;24 | uint32(ipv4[1])&lt;&lt;16 | uint32(ipv4[2])&lt;&lt;8 | uint32(ipv4[3])\n}\n</code></pre>\n<p>And then <em>pass the IPv4-as-uint32 to the listening goroutine as an <code>_</code> parameter</em>. Yes, as a parameter with name <code>_</code>; it's known as the <a href=\"https://golang.org/ref/spec#Blank_identifier\">blank identifier</a> in Go.</p>\n<pre><code class=\"language-go\">// PacketUDPRead is a goroutine that listens on a specific UDP socket and reads\n// in new requests\n// The first parameter is the int representation of the listening IP address,\n// and it's passed just so it will appear in stack traces\nfunc PacketUDPRead(_ uint32, conn *net.UDPConn, ...) { ... }\n\ngo PacketUDPRead(addrToUint32(conn.LocalAddr()), conn, ...)\n</code></pre>\n<p>Now when we get a stack trace, we can just look at the first bytes, convert them back to dotted notation, and know on what IP the goroutine was listening.</p>\n<pre><code>goroutine 42 [IO wait]:\n\t[...]\n\t/.../request.go:195 +0x5d\nrrdns/core.PacketUDPRead(0xc27f000001, 0x2b6328113ad8, 0xc20801ecc0, 0xc208044308, 0xc208e99280, 0xc208ad8180, 0x12a05f200)\n\t/.../server.go:119 +0x35a\ncreated by rrdns/core.PacketIO\n\t/.../server.go:230 +0x8be\n</code></pre>\n<p><code>0xc27f000001</code> -&gt; remove alignment byte -&gt; <code>0x7f000001</code> -&gt; <code>127.0.0.1</code></p>\n<p>Obviously you can do the same with any piece of information you can represent as an <code>int</code>.</p>\n<p><em>Are you interested in taming the goroutines that run the web? We're <a href=\"https://www.cloudflare.com/join-our-team\">hiring</a> in London, San Francisco and Singapore!</em></p>\n<!--kg-card-end: markdown-->",
		"comment_id": "4692",
		"feature_image": "http://blog.cloudflare.com/content/images/2017/10/6372385465_014a4e56af_z.jpg",
		"featured": false,
		"visibility": "public",
		"created_at": "2015-08-03T12:14:03.000+01:00",
		"updated_at": "2018-08-24T19:24:41.000+01:00",
		"published_at": "2015-08-03T12:26:04.000+01:00",
		"custom_excerpt": "CloudFlare’s DNS server, RRDNS, is entirely written in Go and typically runs tens of thousands goroutines. Since goroutines are cheap and Go I/O is blocking we run one goroutine per file descriptor we listen on and queue new packets for processing.",
		"codeinjection_head": null,
		"codeinjection_foot": null,
		"custom_template": null,
		"canonical_url": null,
		"tags": [
			{
				"id": "5d16450341acde0011a95161",
				"name": "RRDNS",
				"slug": "rrdns",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/rrdns/"
			},
			{
				"id": "5d16450341acde0011a951ce",
				"name": "Reliability",
				"slug": "reliability",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/reliability/"
			},
			{
				"id": "5d16450341acde0011a951d6",
				"name": "DNS",
				"slug": "dns",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/dns/"
			},
			{
				"id": "5d16450341acde0011a95215",
				"name": "Go",
				"slug": "go",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/go/"
			},
			{
				"id": "5d16450341acde0011a95214",
				"name": "Programming",
				"slug": "programming",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/programming/"
			}
		],
		"authors": [
			{
				"id": "5d1644b141acde0011a94f51",
				"name": "Filippo Valsorda",
				"slug": "filippo",
				"profile_image": "http://blog.cloudflare.com/content/images/2018/02/K6rX3ZSn_400x400.jpg",
				"cover_image": "http://blog.cloudflare.com/content/images/2018/08/general@2x-26.png",
				"bio": null,
				"website": null,
				"location": null,
				"facebook": null,
				"twitter": "@filosottile",
				"meta_title": null,
				"meta_description": null,
				"url": "http://blog.cloudflare.com/author/filippo/"
			}
		],
		"primary_author": {
			"id": "5d1644b141acde0011a94f51",
			"name": "Filippo Valsorda",
			"slug": "filippo",
			"profile_image": "http://blog.cloudflare.com/content/images/2018/02/K6rX3ZSn_400x400.jpg",
			"cover_image": "http://blog.cloudflare.com/content/images/2018/08/general@2x-26.png",
			"bio": null,
			"website": null,
			"location": null,
			"facebook": null,
			"twitter": "@filosottile",
			"meta_title": null,
			"meta_description": null,
			"url": "http://blog.cloudflare.com/author/filippo/"
		},
		"primary_tag": {
			"id": "5d16450341acde0011a95161",
			"name": "RRDNS",
			"slug": "rrdns",
			"description": null,
			"feature_image": null,
			"visibility": "public",
			"meta_title": null,
			"meta_description": null,
			"og_image": null,
			"og_title": null,
			"og_description": null,
			"twitter_image": null,
			"twitter_title": null,
			"twitter_description": null,
			"codeinjection_head": null,
			"codeinjection_foot": null,
			"canonical_url": null,
			"accent_color": null,
			"url": "http://blog.cloudflare.com/tag/rrdns/"
		},
		"url": "http://blog.cloudflare.com/quick-and-dirty-annotations-for-go-stack-traces/",
		"excerpt": "CloudFlare’s DNS server, RRDNS, is entirely written in Go and typically runs tens of thousands goroutines. Since goroutines are cheap and Go I/O is blocking we run one goroutine per file descriptor we listen on and queue new packets for processing.",
		"reading_time": 2,
		"access": true,
		"comments": false,
		"og_image": null,
		"og_title": null,
		"og_description": null,
		"twitter_image": null,
		"twitter_title": null,
		"twitter_description": null,
		"meta_title": null,
		"meta_description": null,
		"email_subject": null,
		"frontmatter": null,
		"feature_image_alt": null,
		"feature_image_caption": null
	}
}