{
	"locale": "en-us",
	"post": {
		"id": "66032966a5fcdf000a08e732",
		"uuid": "63eb4145-0e9a-48b3-807b-3edd16b5032a",
		"title": "Minimizing on-call burnout through alerts observability",
		"slug": "alerts-observability",
		"html": "<h3 id=\"introduction\">Introduction</h3><figure class=\"kg-card kg-image-card\"><img src=\"http://blog.cloudflare.com/content/images/2024/04/Screenshot-2024-01-18-at-10.49.47-PM.png\" class=\"kg-image\" alt loading=\"lazy\" width=\"2048\" height=\"1104\"></figure><p>Many people have probably come across the ‘<a href=\"https://en.wikipedia.org/wiki/Gunshow_(webcomic)#cite_note-Verge-8:~:text=A%202013%20Gunshow,internet%20meme.\">this is fine</a>’ meme or the <a href=\"https://gunshowcomic.com/648\">original comic</a>. This is what a typical day for a lot of on-call personnel looks like. On-calls get a lot of alerts, and dealing with too many alerts can result in alert fatigue – a feeling of exhaustion caused by responding to alerts that lack priority or clear actions. Ensuring the alerts are actionable and accurate, not false positives, is crucial because repeated false alarms can desensitize on-call personnel. To this end, within Cloudflare, numerous teams conduct periodic alert analysis, with each team developing its own dashboards for reporting. As members of the Observability team, we've encountered situations where teams reported inaccuracies in alerts or instances where alerts failed to trigger, as well as provided assistance in dealing with noisy/flapping alerts.</p><p>Observability aims to enhance insight into the technology stack by gathering and analyzing a broader spectrum of data. In this blog post, we delve into alert observability, discussing its importance and Cloudflare's approach to achieving it. We'll also explore how we overcome shortcomings in alert reporting within our architecture to simplify troubleshooting using open-source tools and best practices. Join us to understand how we use alerts effectively and use simple tools and practices to enhance our alerts observability, resilience, and on-call personnel health.</p><figure class=\"kg-card kg-image-card\"><img src=\"http://blog.cloudflare.com/content/images/2024/03/Screenshot-2024-01-18-at-10.52.33-PM.png\" class=\"kg-image\" alt=\"Alert fatigue\" loading=\"lazy\" width=\"1600\" height=\"904\"></figure><p>Being on-call can disrupt sleep patterns, impact social life, and hinder leisure activities, potentially leading to burnout. While burnout can be caused by several factors, one contributing factor can be excessively noisy alerts or receiving alerts that are neither important nor actionable. Analyzing alerts can help mitigate the risk of such burnout by reducing unnecessary interruptions and improving the overall efficiency of the on-call process. It involves periodic review and feedback to the system for improving alert quality. Unfortunately, only some companies or teams do alert analysis, even though it is essential information that every on-call or manager should have access to.</p><p>Alert analysis is useful for on-call personnel, enabling them to easily see which alerts have fired during their shift to help draft handover notes and not miss anything important. In addition, managers can generate reports from these stats to see the improvements over time, as well as helping assess on-call vulnerability to burnout. Alert analysis also helps with writing incident reports, to see if alerts were fired, or to determine when an incident started.</p><p>Let’s first understand the alerting stack and how we used open-source tools to gain greater visibility into it, which allowed us to analyze and optimize its effectiveness.</p><h3 id=\"prometheus-architecture-at-cloudflare\">Prometheus architecture at Cloudflare</h3><figure class=\"kg-card kg-image-card\"><img src=\"http://blog.cloudflare.com/content/images/2024/03/Untitled-2.png\" class=\"kg-image\" alt loading=\"lazy\" width=\"1352\" height=\"1043\"></figure><p>At Cloudflare, we <a href=\"http://blog.cloudflare.com/how-cloudflare-runs-prometheus-at-scale/\">rely heavily on Prometheus</a> for monitoring. We have data centers in more than 310 cities, and each has several <a href=\"https://prometheus.io/docs/introduction/faq/#:~:text=Apache%202.0%20license.-,What%20is%20the%20plural%20of%20Prometheus%3F,Prometheus%27%20is%20%27Prometheis%27\">Prometheis</a>. In total, we have over 1100 Prometheus servers. All alerts are sent to a central <a href=\"https://prometheus.io/docs/alerting/latest/alertmanager/\">Alertmanager</a>, where we have various integrations to route them. Additionally, <a href=\"https://prometheus.io/docs/alerting/latest/configuration/#:~:text=The%20Alertmanager%20will%20send%20HTTP%20POST%20requests%20in%20the%20following%20JSON%20format%20to%20the%20configured%20endpoint%3A\">using an alertmanager webhook</a>, we store all alerts in a datastore for analysis.</p><h3 id=\"lifecycle-of-an-alert\">Lifecycle of an alert</h3><p>Prometheus collects metrics from configured targets at given intervals, evaluates rule expressions, displays the results, and can trigger alerts when the alerting conditions are met. Once an alert goes into firing state, it will be sent to the alertmanager.</p><figure class=\"kg-card kg-image-card\"><img src=\"http://blog.cloudflare.com/content/images/2024/03/Screenshot-2024-01-18-at-10.53.57-PM.png\" class=\"kg-image\" alt=\"Alertmanager core concepts\" loading=\"lazy\" width=\"1600\" height=\"1070\"></figure><p>Depending on the configuration, once Alertmanager receives an alert, it can inhibit, group, silence, or route the alerts to the correct receiver integration, such as chat, PagerDuty, or ticketing system. When configured properly, Alertmanager can mitigate a lot of alert noise. Unfortunately, that is not the case all the time, as not all alerts are optimally configured.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"http://blog.cloudflare.com/content/images/2024/03/Screenshot-2024-03-26-at-1.13.46-PM.png\" class=\"kg-image\" alt=\"LifeCycle of an alert (Alertmanager)\" loading=\"lazy\" width=\"1213\" height=\"617\"><figcaption><em>In Alertmanager, alerts initially enter the firing state, where they may be inhibited or silenced. They return to the firing state when the silence expires or the inhibiting alert resolves, and eventually transition to the resolved state.</em></figcaption></figure><p>Alertmanager sends notifications for <code>firing</code> and <code>resolved</code> alert events via webhook integration. We were using <a href=\"https://github.com/cloudflare/alertmanager2es\">alertmanager2es</a>, which receives webhook alert notifications from Alertmanager and inserts them into an Elasticsearch index for searching and analysis. Alertmanager2es has been a reliable tool for us over the years, offering ways to monitor alerting volume, noisy alerts and do some kind of alert reporting. However, it had its limitations. The absence of <code>silenced</code> and <code>inhibited</code> alert states made troubleshooting issues challenging. We often found ourselves guessing why an alert didn't trigger - was it silenced by another alert or perhaps inhibited by one? Without concrete data, we lacked the means to confirm what was truly happening.</p><p>Since the Alertmanager doesn’t provide notifications for <code>silenced</code> or <code>inhibited</code> alert events via webhook integration, the alert reporting we were doing was somewhat lacking or incomplete. However, the<a href=\"https://raw.githubusercontent.com/prometheus/alertmanager/master/api/v2/openapi.yaml\"> Alertmanager API</a> provides querying capabilities and by querying the <code>/api/alerts</code> alertmanager endpoint, we can get the <code>silenced</code> and <code>inhibited</code> alert states. Having all four states in a datastore will enhance our ability to improve alert reporting and troubleshoot Alertmanager issues.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"http://blog.cloudflare.com/content/images/2024/03/Screenshot-2024-03-26-at-1.14.02-PM.png\" class=\"kg-image\" alt=\"Alertmanager alert notifications\" loading=\"lazy\" width=\"1222\" height=\"665\"><figcaption><em>Interfaces for providing information about alert states</em></figcaption></figure><h2 id=\"solution\">Solution</h2><p>We opted to aggregate all states of the alerts (firing, silenced, inhibited, and resolved) into a datastore. Given that we're gathering data from two distinct sources (the webhook and API) each in varying formats and potentially representing different events, we correlate alerts from both sources using the fingerprint field. The <a href=\"https://github.com/prometheus/common/blob/main/model/alert.go#L48-L52\">fingerprint</a> is a unique hash of the alert’s label set which enables us to match alerts across responses from the Alertmanager webhook and API.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"http://blog.cloudflare.com/content/images/2024/03/Screenshot-2024-01-18-at-10.59.39-PM.png\" class=\"kg-image\" alt=\"Alertmanager webhook vs API response\" loading=\"lazy\" width=\"1600\" height=\"827\"><figcaption><em>Alertmanager webhook and API response of same alert event</em></figcaption></figure><p>The Alertmanager API offers additional fields compared to the webhook (highlighted in pastel red on the right), such as <code>silencedBy</code> and <code>inhibitedBy</code> IDs, which aid in identifying silenced and inhibited alerts. We store both webhook and API responses in the datastore as separate rows. While querying, we match the alerts using the fingerprint field.</p><p>We decided to use a <a href=\"https://vector.dev/\">vector.dev</a> instance to transform the data as necessary, and store it in a data store. Vector.dev (<a href=\"https://www.datadoghq.com/blog/datadog-acquires-timber-technologies-vector/\">acquired by Datadog</a>) is an open-source, high-performance, observability data pipeline that supports a vast range of sources to read data from and supports a lot of sinks for writing data to, as well as a variety of data transformation operations.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"http://blog.cloudflare.com/content/images/2024/03/Screenshot-2024-01-18-at-10.50.14-PM.png\" class=\"kg-image\" alt=\"Proposed solution\" loading=\"lazy\" width=\"1600\" height=\"541\"><figcaption><em>Here, we use one http_server vector instance to receive Alertmanager webhook notifications, two http_client sources to query alerts and silence API endpoints, and two sinks for writing all of the state logs in ClickHouse into alerts and silences tables</em></figcaption></figure><p>Although we use ClickHouse to store this data, any other database can be used here. ClickHouse was chosen as a data store because it provides various data manipulation options. It allows aggregating data during insertion using Materialized Views, reduces duplicates with the replacingMergeTree table engine, and supports JOIN statements.</p><figure class=\"kg-card kg-image-card\"><img src=\"http://blog.cloudflare.com/content/images/2024/03/Untitled-1-1.png\" class=\"kg-image\" alt=\"ClickHouse table schema\" loading=\"lazy\" width=\"1568\" height=\"794\"></figure><p>If we were to create individual columns for all the alert labels, the number of columns would grow exponentially with the addition of new alerts and unique labels. Instead, we decided to create individual columns for a few common labels like alert priority, instance, dashboard, alert-ref, alertname, etc., which helps us analyze the data in general and keep all other labels in a column of type <code>Map(String, String)</code>. This was done because we wanted to keep all the labels in the datastore with minimal resource usage and allow users to query specific labels or filter alerts based on particular labels. For example, we can select all Prometheus alerts using  <code>labelsmap[‘service’’] = ‘Prometheus’</code>.</p><h2 id=\"dashboards\">Dashboards</h2><figure class=\"kg-card kg-image-card\"><img src=\"http://blog.cloudflare.com/content/images/2024/03/Screenshot-2024-01-18-at-11.02.31-PM.png\" class=\"kg-image\" alt=\"Outcome\" loading=\"lazy\" width=\"1600\" height=\"672\"></figure><p>We built multiple dashboards on top of this data:</p><ul><li><strong>Alerts overview</strong>: To get insights into all the alerts the Alertmanager receives.</li><li><strong>Alertname overview</strong>: To drill down on a specific alert.</li><li><strong>Alerts overview by receiver:</strong> This is similar to alerts overview but specific to a team or receiver.</li><li><strong>Alerts state timeline</strong>: This dashboard shows a snapshot of alert volume at a glance.</li><li><strong>Jiralerts overview</strong>: To get insights into the alerts the ticket system receives.</li><li><strong>Silences overview</strong>: To get insights into the Alertmanager silences.</li></ul><h3 id=\"alerts-overview\">Alerts overview</h3><figure class=\"kg-card kg-image-card\"><img src=\"http://blog.cloudflare.com/content/images/2024/03/Screenshot-2024-03-26-at-1.14.24-PM.png\" class=\"kg-image\" alt=\"Collapsed alerts overview dashboard\" loading=\"lazy\" width=\"1217\" height=\"642\"></figure><p>The image is a screenshot of the collapsed alerts overview dashboard by receiver. This dashboard comprises general stats, components, services, and alertname breakdown. The dashboard also highlights the number of P1 / P2 alerts in the last one day / seven days / thirty days, top alerts for the current quarter, and quarter-to-quarter comparison.</p><h3 id=\"component-breakdown\">Component breakdown</h3><figure class=\"kg-card kg-image-card\"><img src=\"http://blog.cloudflare.com/content/images/2024/03/Screenshot-2024-01-19-at-3.47.38-PM.png\" class=\"kg-image\" alt=\"Receiver component breakdown status history\" loading=\"lazy\" width=\"1600\" height=\"505\"></figure><p>We route alerts to teams and a team can have multiple services or components. This panel shows firing alerts component counts over time for a receiver. For example, the alerts are sent to the observability team, which owns multiple components like logging, metrics, traces, and errors. This panel gives an alerting component count over time, and provides a good idea about which component is noisy and at what time at a glance.</p><h3 id=\"timeline-of-alerts\">Timeline of alerts</h3><figure class=\"kg-card kg-image-card\"><img src=\"http://blog.cloudflare.com/content/images/2024/03/Screenshot-2024-01-19-at-3.22.12-PM.png\" class=\"kg-image\" alt loading=\"lazy\" width=\"1600\" height=\"794\"></figure><p>We created this swimlane view using Grafana’s state timeline panel for the receivers. The panel shows how busy the on-call was and at what point. Red here means the alert started firing, orange represents the alert is active and green means it has resolved. It displays the start time, active duration, and resolution of an alert. This highlighted alert is changing state too frequently from firing to resolved - this looks like a flapping alert. Flapping occurs when an alert changes state too frequently. This can happen when alerts are not configured properly and need tweaking, such as adjusting the alert threshold or increasing the <code>for duration</code> period in the alerting rule. The <code>for duration</code> field in the alerting rules adds time tolerance before an alert starts firing. In other words, the alert won’t fire unless the condition is met for ‘X’ minutes.</p><h2 id=\"findings\">Findings</h2><p>There were a few interesting findings within our analysis. We found a few alerts that were firing and did not have a notify label set, which means the alerts were firing but were not being sent or routed to any team, creating unnecessary load on the Alertmanager. We also found a few components generating a lot of alerts, and when we dug in, we found that they were for a cluster that was decommissioned where the alerts were not removed. These dashboards gave us excellent visibility and cleanup opportunities.</p><h3 id=\"alertmanager-inhibitions\">Alertmanager inhibitions</h3><p>Alertmanager inhibition allows suppressing a set of alerts or notifications based on the presence of another set of alerts. We found that Alertmanager inhibitions were not working sometimes. Since there was no way to know about this, we only learned about it when a user reported getting alerted for inhibited alerts. Imagine a Venn diagram of firing and inhibited alerts to understand failed inhibitions. Ideally, there should be no overlap because the inhibited alerts shouldn’t be firing. But if there is an overlap, that means inhibited alerts are firing, and this overlap is considered a failed inhibition alert.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"http://blog.cloudflare.com/content/images/2024/03/Screenshot-2024-03-26-at-1.14.39-PM.png\" class=\"kg-image\" alt=\"Failed inhibition venn diagram\" loading=\"lazy\" width=\"1221\" height=\"505\"><figcaption><em>Failed inhibition venn diagram</em></figcaption></figure><p>After storing alert notifications in ClickHouse, we were able to come up with a query to find the fingerprint of the `alertnames` where the inhibitions were failing using the following query:</p><pre><code>SELECT $rollup(timestamp) as t, count() as count\nFROM\n(\n    SELECT\n        fingerprint, timestamp\n    FROM alerts\n    WHERE\n        $timeFilter\n        AND status.state = 'firing'\n    GROUP BY\n        fingerprint, timestamp\n) AS firing\nANY INNER JOIN\n(\n    SELECT\n        fingerprint, timestamp\n    FROM alerts\n    WHERE\n        $timeFilter\n        AND status.state = 'suppressed' AND notEmpty(status.inhibitedBy)\n    GROUP BY\n        fingerprint, timestamp\n) AS suppressed USING (fingerprint)\nGROUP BY t\n</code></pre><p>The first panel in the image below is the total number of firing alerts, the second panel is the number of failed inhibitions.</p><figure class=\"kg-card kg-image-card\"><img src=\"http://blog.cloudflare.com/content/images/2024/03/Screenshot-2024-03-15-at-10.40.59-PM.png\" class=\"kg-image\" alt loading=\"lazy\" width=\"1600\" height=\"875\"></figure><p>We can also create breakdown for each failed inhibited alert</p><figure class=\"kg-card kg-image-card\"><img src=\"http://blog.cloudflare.com/content/images/2024/03/Screenshot-2024-01-24-at-5.03.08-PM.png\" class=\"kg-image\" alt loading=\"lazy\" width=\"1600\" height=\"491\"></figure><p>By looking up the fingerprint from the database, we could map the alert inhibitions and found that the failed inhibited alerts have an inhibition loop. For example, alert <code>Service_XYZ_down</code> is inhibited by alert <code>server_OOR</code>, alert <code>server_OOR</code> is inhibited by alert <code>server_down</code>, and <code>server_down</code> is inhibited by alert <code>server_OOR</code>.</p><figure class=\"kg-card kg-image-card\"><img src=\"http://blog.cloudflare.com/content/images/2024/03/Screenshot-2024-03-26-at-1.14.54-PM.png\" class=\"kg-image\" alt loading=\"lazy\" width=\"1215\" height=\"467\"></figure><p>Failed inhibitions can be avoided if alert inhibitions are configured carefully.</p><h3 id=\"silences\">Silences</h3><figure class=\"kg-card kg-image-card\"><img src=\"http://blog.cloudflare.com/content/images/2024/03/Screenshot-2024-03-26-at-1.15.09-PM.png\" class=\"kg-image\" alt=\"Alertmanager silences\" loading=\"lazy\" width=\"1020\" height=\"511\"></figure><p>Alertmanager provides a mechanism to silence an alert while it is being worked on or during maintenance. Silence can mute the alerts for a given time and it can be configured based on matchers, which can be an exact match, a regex, an alert name, or any other label. The silence matcher doesn’t necessarily translate to the alertname. By doing alert analysis, we could map the alerts and the silence ID by doing a JOIN query on the alerts and silences tables. We also discovered a lot of stale silences, where silence was created for a long duration and is not relevant anymore.</p><h2 id=\"diy-alert-analysis\">DIY Alert analysis</h2><p><a href=\"https://github.com/cloudflare/cloudflare-blog/tree/master/2024-03-alerts-observability\">The directory</a> contains a basic demo for implementing alerts observability. Running `docker-compose up` spawns several containers, including Prometheus, Alertmanager, Vector, ClickHouse, and Grafana. The vector.dev container queries the Alertmanager alerts API and writes the data into ClickHouse after transforming it. The Grafana dashboard showcases a demo of Alerts and Silences overview.</p><p>Make sure you have docker installed and run <code>docker compose up</code> to get started.</p><p>Visit <a href=\"http://localhost:3000/dashboards\">http://localhost:3000/dashboards</a> to explore the prebuilt demo dashboards.</p><h2 id=\"conclusion\">Conclusion</h2><p>As part of the observability team, we manage the Alertmanager, which is a multi-tenant system. It's crucial for us to have visibility to detect and address system misuse, ensuring proper alerting. The use of alert analysis tools has significantly enhanced the experience for on-call personnel and our team, offering swift access to the alert system. Alerts observability has facilitated the troubleshooting of events such as why an alert did not fire, why an inhibited alert fired, or which alert silenced / inhibited another alert, providing valuable insights for improving alert management.</p><p>Moreover, alerts overview dashboards facilitate rapid review and adjustment, streamlining operations. Teams use these dashboards in the weekly alert reviews to provide tangible evidence of how an on-call shift went, identify which alerts fire most frequently, becoming candidates for cleanup or aggregation thus curbing system misuse and bolstering overall alert management. Additionally, we can pinpoint services that may require particular attention. Alerts observability has also empowered some teams to make informed decisions about on-call configurations, such as transitioning to longer but less frequent shifts or integrating on-call and unplanned work shifts.</p><p>In conclusion, alert observability plays a crucial role in averting burnout by minimizing interruptions and enhancing on-call duties' efficiency. Offering alerts observability as a service benefits all teams by obviating the need for individual dashboard development and fostering a proactive monitoring culture.<br>If you found this blog post interesting and want to work on observability, please check out our job openings – we’re hiring for <a href=\"https://www.cloudflare.com/en-gb/careers/jobs/?department=Production+Engineering&amp;title=alerting\">Alerting</a> and <a href=\"https://www.cloudflare.com/en-gb/careers/jobs/?department=Production+Engineering&amp;title=logging\">Logging</a>!</p>",
		"comment_id": "66032966a5fcdf000a08e732",
		"feature_image": "http://blog.cloudflare.com/content/images/2024/03/Wasm-core-dumps-and-debugging-Rust-in-Workers.png",
		"featured": false,
		"visibility": "public",
		"created_at": "2024-03-26T20:00:38.000+00:00",
		"updated_at": "2024-04-09T08:37:42.000+01:00",
		"published_at": "2024-03-29T13:00:36.000+00:00",
		"custom_excerpt": "Learn how Cloudflare used open-source tools to enhance alert observability, leading to increased resilience and improved on-call team well-being",
		"codeinjection_head": null,
		"codeinjection_foot": null,
		"custom_template": null,
		"canonical_url": null,
		"authors": [
			{
				"id": "631221645f22d3000b3304dd",
				"name": "Monika Singh",
				"slug": "monika",
				"profile_image": "http://blog.cloudflare.com/content/images/2022/09/xlarge.jpg",
				"cover_image": null,
				"bio": null,
				"website": null,
				"location": "Singapore",
				"facebook": null,
				"twitter": "@m0nikasingh",
				"meta_title": null,
				"meta_description": null,
				"url": "http://blog.cloudflare.com/author/monika/"
			}
		],
		"tags": [
			{
				"id": "66032c2ba5fcdf000a08e796",
				"name": "#BLOG-2218",
				"slug": "hash-blog-2218",
				"description": null,
				"feature_image": null,
				"visibility": "internal",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/404/"
			},
			{
				"id": "5ff879f685e81803f3901a57",
				"name": "Observability",
				"slug": "observability",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/observability/"
			},
			{
				"id": "5d16450341acde0011a95204",
				"name": "Developers",
				"slug": "developers",
				"description": null,
				"feature_image": "http://blog.cloudflare.com/content/images/2020/10/Developers-1.png",
				"visibility": "public",
				"meta_title": "Cloudflare Blog: Developers",
				"meta_description": "Collection of Cloudflare blog posts tagged 'Developers'.",
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/developers/"
			},
			{
				"id": "64a3e2b834124c000b00b717",
				"name": "Developer Platform",
				"slug": "developer-platform",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/developer-platform/"
			},
			{
				"id": "60a6436188249201ba7150e4",
				"name": "Prometheus",
				"slug": "prometheus",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/prometheus/"
			},
			{
				"id": "66032c2ba5fcdf000a08e797",
				"name": "Alertmanager",
				"slug": "alertmanager",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/alertmanager/"
			},
			{
				"id": "65c0d31851a92e000adeae66",
				"name": "#front-page",
				"slug": "hash-front-page",
				"description": null,
				"feature_image": null,
				"visibility": "internal",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/404/"
			}
		],
		"primary_author": {
			"id": "631221645f22d3000b3304dd",
			"name": "Monika Singh",
			"slug": "monika",
			"profile_image": "http://blog.cloudflare.com/content/images/2022/09/xlarge.jpg",
			"cover_image": null,
			"bio": null,
			"website": null,
			"location": "Singapore",
			"facebook": null,
			"twitter": "@m0nikasingh",
			"meta_title": null,
			"meta_description": null,
			"url": "http://blog.cloudflare.com/author/monika/"
		},
		"primary_tag": null,
		"url": "http://blog.cloudflare.com/alerts-observability/",
		"excerpt": "Learn how Cloudflare used open-source tools to enhance alert observability, leading to increased resilience and improved on-call team well-being",
		"reading_time": 10,
		"access": true,
		"comments": false,
		"og_image": "http://blog.cloudflare.com/content/images/2024/03/BLOG-2218-1.png",
		"og_title": null,
		"og_description": null,
		"twitter_image": "http://blog.cloudflare.com/content/images/2024/03/BLOG-2218.png",
		"twitter_title": null,
		"twitter_description": null,
		"meta_title": null,
		"meta_description": null,
		"email_subject": null,
		"frontmatter": null,
		"feature_image_alt": null,
		"feature_image_caption": null
	}
}