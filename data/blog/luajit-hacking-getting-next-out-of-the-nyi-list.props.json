{
	"post": {
		"id": "5d16453b41acde0011a955f6",
		"uuid": "7081cc51-3823-4cf3-a2a3-43386b6c7bd4",
		"title": "LuaJIT Hacking: Getting next() out of the NYI list",
		"slug": "luajit-hacking-getting-next-out-of-the-nyi-list",
		"html": "<!--kg-card-begin: markdown--><p>At Cloudflare we’re heavy users of LuaJIT and in the past have sponsored many improvements to its performance.</p>\n<p>LuaJIT is a powerful piece of software, maybe the highest performing JIT in the industry.  But it’s not always easy to get the most out of it, and sometimes a small change in one part of your code can negatively impact other, already optimized, parts.</p>\n<p>One of the first pieces of advice anyone receives when writing Lua code to run quickly using LuaJIT is “avoid the NYIs”: the language or library features that can’t be compiled because they’re NYI (not yet implemented). And that means they run in the interpreter.</p>\n<p><img src=\"http://blog.cloudflare.com/content/images/2017/02/6822250770_d6f8399cf2_z.jpg\" alt=\"\" loading=\"lazy\"><br>\n<small><a href=\"https://creativecommons.org/licenses/by-sa/2.0/\">CC BY-SA 2.0</a> <a href=\"https://www.flickr.com/photos/zengei/6822250770/in/photolist-boRPth-7xeiAm-e6H8w5-dSoqGF-FiYGj-okoVwy-e1ugbE-dXhvop-8fQNCX-974Bts-ekbDjn-p9HV9L-971y78-bdb8Hi-e2Us2u-8fU4pm-9ZFfXg-g469T-7Ft9Jc-9YWa6m-95HYN2-95J19D-5JeU76-95M3qb-PFZRj-9uYpbM-6bJrpt-D2DfZK-Ccqoxs-Jqvvxd-kSQzNX-JyLzNN-dEnx4T-dezBQR-e2NN7a-6aP8op-971xFi-974BBJ-qR8GWh-5De3Sy-974CTy-gyUry-dezAkY-7qHBJ2-eHJH4W-9v2qQs-dCQMt7-nBkbJ7-eZ8yc-e3u6kJ\">image</a> by <a href=\"https://www.flickr.com/photos/zengei/\">Dwayne Bent</a></small></p>\n<p>Another very attractive feature of LuaJIT is the FFI library, which allows Lua code to directly interface with C code and memory structures.  The JIT compiler weaves these memory operations in line with the generated machine language, making it much more efficient than using the traditional Lua C API.</p>\n<p>Unfortunately, if for any reason the Lua code using the FFI library has to run under the interpreter, it takes a very heavy performance hit.  As it happens, under the interpreter the FFI is usually much slower than the Lua C API or the basic operations. For many people, this means either avoiding the FFI  or committing to a permanent vigilance to maintain the code from falling back to the interpreter.</p>\n<h3 id=\"optimizingluajitcode\">Optimizing LuaJIT Code</h3>\n<p>Before optimizing any code, it’s important to identify which parts are actually important.  It’s useless to discuss what’s the fastest way to add a few numbers before sending some data, if the send operation will take a million times longer than that addition. Likewise, there’s no benefit avoiding NYI features in code like initialization routines that might run only a few times, as it’s unlikely that the JIT would even try to optimize them, so they would always run in the interpreter.  Which, by the way, is also very fast; even faster than the first version of LuaJIT itself.</p>\n<p>But optimizing the core parts of a Lua program, like any deep inner loops, can yield huge improvements in the overall performance.  In similar situations, experienced developers using other languages are used to inspecting the assembly language generated by the compiler, to see if there’s some change to the source code that can make the result better.</p>\n<p>The command line LuaJIT executable provides a bytecode list when running with the <code>-jbc</code> option, a statistical profiler, activated with the <code>-jp</code> option, a trace list with <code>-jv</code>, and finally a detailed dump of all the JIT operations with <code>-jdump</code>.</p>\n<p>The last two provide lots of information very useful for understanding what actually happens with the Lua code while executing, but it can be a lot of work to read the huge lists generated by <code>-jdump</code>.  Also, some messages are hard to understand without a fairly complete understanding of how the tracing compiler in LuaJIT actually works.</p>\n<p>One very nice feature is that all these JIT options are implemented in Lua.  To accomplish this the JIT provides ‘hooks’ that can execute a Lua function at important moments with the relevant information. Sometimes the best way to understand what some <code>-jdump</code> output actually means is to read the code that generated that specific part of the output.</p>\n<p><img src=\"http://blog.cloudflare.com/content/images/2017/02/6353190489_1363ec7f16_z.jpg\" alt=\"\" loading=\"lazy\"><br>\n<small><a href=\"https://creativecommons.org/licenses/by/2.0/\">CC BY 2.0</a> <a href=\"https://www.flickr.com/photos/kevandotorg/6353190489/in/photolist-aFpLc4-6Rorty-gvhKC9-8UEeqU-aBoHof-9qr8bs-9qo6Ai-9qrafb-FhYA4L-CH4r5G-8HZcMK-pX32R-6SJMc6-pX39e-oXee8D-aBoHBJ-cLgitL-cLgeKY-3THPb-hzKrGL-cLggDJ-6Rh35p-dqkQyJ-7Ey5Pz-6RkwNh-6RgYDe-7C7F9S-6RgxKH-6RkLFN-i4HqqU-6Rktx9-6RkXKQ-6RgRqD-6RkmBs-6RgML2-6RkE4j-6Rg5nT-6RjKkq-6RfDK2-6RfRRc-6RfYfK-6RfUT8-6RjN4d-hzMBtc-hzNnyN-hzJiM8-hzJVpv-hzLE56-hzKU4c-9mQrRy\">image</a> by <a href=\"https://www.flickr.com/photos/kevandotorg/\">Kevan</a></small></p>\n<h3 id=\"introducingloom\">Introducing Loom</h3>\n<p>After several rounds there, and being frustrated by the limitations of the sequentially-generated dump, I decided to write a different version of <code>-jdump</code>, one that gathered more information to process and add cross-references to help see how things are related before displaying.  The result is <a href=\"https://github.com/cloudflare/loom\">loom</a>, which shows roughly the same information as <code>-jdump</code>, but with more resolved references and formatted in HTML with tables, columns, links and colors.  It has helped me a lot to understand my own code and the workings of LuaJIT itself.</p>\n<p>For example, let's consider the following code in a file called <code>twoloops.lua</code>:</p>\n<pre><code>for i=1,1000 do\n    for j=1,1000 do\n    end\nend\n</code></pre>\n<p>With the <code>-jv</code> option:</p>\n<pre><code>$ luajit -jv twoloops.lua\n[TRACE   1 twoloops.lua:2 loop]\n[TRACE   2 (1/3) twoloops.lua:1 -&gt; 1]\n</code></pre>\n<p>This tells us that there were two traces, the first one contains a loop, and the second one spawns from exit #3 of the other (the “(1/3)” part) and it’s endpoint returns to the start of trace #1.</p>\n<p>Ok, let’s get more detail with <code>-jdump</code>:</p>\n<pre><code>$ luajit -jdump twoloops.lua\n---- TRACE 1 start twoloops.lua:2\n0009  FORL     4 =&gt; 0009\n---- TRACE 1 IR\n0001    int SLOAD  #5    CI\n0002  + int ADD    0001  +1  \n0003 &gt;  int LE     0002  +1000\n0004 ------ LOOP ------------\n0005  + int ADD    0002  +1  \n0006 &gt;  int LE     0005  +1000\n0007    int PHI    0002  0005\n---- TRACE 1 mcode 47\n0bcbffd1  mov dword [0x40db1410], 0x1\n0bcbffdc  cvttsd2si ebp, [rdx+0x20]\n0bcbffe1  add ebp, +0x01\n0bcbffe4  cmp ebp, 0x3e8\n0bcbffea  jg 0x0bcb0014\t-&gt;1\n-&gt;LOOP:\n0bcbfff0  add ebp, +0x01\n0bcbfff3  cmp ebp, 0x3e8\n0bcbfff9  jle 0x0bcbfff0\t-&gt;LOOP\n0bcbfffb  jmp 0x0bcb001c\t-&gt;3\n---- TRACE 1 stop -&gt; loop\n\n---- TRACE 2 start 1/3 twoloops.lua:1\n0010  FORL     0 =&gt; 0005\n0005  KSHORT   4   1\n0006  KSHORT   5 1000\n0007  KSHORT   6   1\n0008  JFORI    4 =&gt; 0010\n---- TRACE 2 IR\n0001    num SLOAD  #1    I\n0002    num ADD    0001  +1  \n0003 &gt;  num LE     0002  +1000\n---- TRACE 2 mcode 81\n0bcbff79  mov dword [0x40db1410], 0x2\n0bcbff84  movsd xmm6, [0x41704068]\n0bcbff8d  movsd xmm5, [0x41704078]\n0bcbff96  movsd xmm7, [rdx]\n0bcbff9a  addsd xmm7, xmm6\n0bcbff9e  ucomisd xmm5, xmm7\n0bcbffa2  jb 0x0bcb0014\t-&gt;1\n0bcbffa8  movsd [rdx+0x38], xmm6\n0bcbffad  movsd [rdx+0x30], xmm6\n0bcbffb2  movsd [rdx+0x28], xmm5\n0bcbffb7  movsd [rdx+0x20], xmm6\n0bcbffbc  movsd [rdx+0x18], xmm7\n0bcbffc1  movsd [rdx], xmm7\n0bcbffc5  jmp 0x0bcbffd1\n---- TRACE 2 stop -&gt; 1\n</code></pre>\n<p>This tells us... well, a lot of things.  If you look closely, you’ll see the same two traces, one is a loop, the second starts at <code>1/3</code> and returns to trace #1.  Each one shows some bytecode instructions, an IR listing, and the final mcode.  There are several options to turn on and off each listing, and more info like the registers allocated to some IR instructions, the “snapshot” structures that allow the interpreter to continue when a compiled trace exits, etc.</p>\n<p>Now using loom:</p>\n<p><a href=\"http://blog.cloudflare.com/content/images/2017/02/image00.png\">![](https://blog.cloudflare<img src=\"http://blog.cloudflare.com/content/images/2017/02/image00.png\" alt=\"\" loading=\"lazy\"></a></p>\n<p>There’s the source code, with the corresponding bytecodes, and the same two traces, with IR and mcode listings.  The bytecode lines on the traces and on the top listings are linked, hovering on some arguments on the IR listing highlights the source and use of each value, the jumps between traces are correctly labeled (and colored), finally, clicking on the bytecode or IR column headers reveals more information: excerpts from the source code and snapshot formats, respectively.</p>\n<p>Writing it was a great learning experience, I had to read the dump script’s Lua sources and went much deeper in the LuaJIT sources than ever before.  And then, I was able to use loom not only to analyze and optimize Cloudflare’s Lua code, but also to watch the steps the compiler goes through to make it run fast, and also what happens when it’s not happy.</p>\n<h3 id=\"thecodeisthecodeisthecodeisthecode\">The code is the code is the code is the code</h3>\n<p>LuaJIT handles up to four different representation of a program’s code:</p>\n<p>First comes the source code, what the developer writes.</p>\n<p>The parser analyzes the source code and produces the Bytecode, which is what the interpreter actually executes.  It has the same flow of the source code, grouped in functions, with all the calls, iterators, operations, etc.  Of course, there’s no nice formatting, comments, the local variable names are replaced by indices, and all constants (other than small numbers) are stored in a separate area.</p>\n<p>When the interpreter finds that a given point of the bytecode has been repeated several times, it’s considered a “hot” part of the code, and interprets it once again but this time it records each bytecode it encounters, generating a “code trace” or just “a trace”.  At the same time, it generates an “intermediate representation”, or IR, of the code as it’s executed.  The IR doesn’t represent the whole of the function or code portion, just the actual options it actually takes.</p>\n<p>A trace is finished when it hits a loop or a recursion, returns to a lower level than when started, hits a NYI operation, or simply becomes too long.  At this point, it can be either compiled into machine language, or aborted if it has reached some code that can’t be correctly translated.  If successful, the bytecode is patched with an entry to the machine code, or “mcode”.  If aborted, the initial trace point is “penalized” or even “blocklisted” to avoid wasting time trying to compile it again.</p>\n<h3 id=\"whatsnext\">What’s <code>next()</code>?</h3>\n<p>One of the most visible characteristics of the Lua language is the heavy use of dictionary objects called <em>tables</em>.  From the <a href=\"https://www.lua.org/manual/5.1/manual.html#2.2\">Lua manual</a>:</p>\n<p><em>“Tables are the sole data structuring mechanism in Lua; they can be used to represent ordinary arrays, symbol tables, sets, records, graphs, trees, etc.”</em></p>\n<p>To iterate over all the elements in a table, the idiomatic way is to use the standard library function <code>pairs()</code> like this:</p>\n<pre><code>for k, v in pairs(t) do\n    -- use the key in ‘k’ and the value in ‘v’\nend\n</code></pre>\n<p>In the standard Lua manual, <code>pairs()</code> is <a href=\"https://www.lua.org/manual/5.1/manual.html#pdf-pairs\">defined</a> as “Returns three values: the <code>next</code> function, the table <code>t</code>, and <code>nil</code>”, so the previous code is the same as:</p>\n<pre><code>for k, v in next, t, nil do\n    -- use the key in ‘k’ and the value in ‘v’\nend\n</code></pre>\n<p>But unfortunately, both the <code>next()</code> and <code>pairs()</code> functions are listed as “not compiled” in the feared <a href=\"http://wiki.luajit.org/NYI#libraries_base-library\">NYI list</a>.  That means that any such code runs on the interpreter and is not compiled, unless the code inside is complex enough, and has other inner loops (loops that doesn’t use <code>next()</code> or <code>pairs()</code>, of course).  Even in that case, the code would have to fall back to the interpreter at each loop end.</p>\n<p>This sad news creates a tradeoff: for performance sensitive parts of the code, don’t use the most Lua-like code style.  That motivates people to come up with several contortions to be able to use numerical iteration (which is compiled, and very efficient), like replacing any key with a number, storing all the keys in a numbered array, or store both keys and values at even/odd numeric indices.</p>\n<h3 id=\"gettingnextoutofthenyilist\">Getting <code>next()</code> out of the NYI list</h3>\n<p>So, I finally have a non-NYI <code>next()</code> function! I'd like to say &quot;a fully JITtable <code>next()</code> function&quot;, but it wouldn't be totally true; as it happens, there's no way to avoid some annoying trace exits on table iteration.</p>\n<p>The purpose of the IR is to provide a representation of the execution path so it can be quickly optimized to generate the final mcode. For that, the IR traces are linear and type-specific; creating some interesting challenges for iteration on a generic container.</p>\n<h3 id=\"tracesarelinear\">Traces are linear</h3>\n<p>Being linear means that each trace captures a single execution path, it can't contain conditional code or internal jumps.  The only conditional branches are the &quot;guards&quot; that make sure that the code to be executed is the appropriate one.  If a condition changes and it must now do something different, the trace must be exited.  If it happens several times, it will spawn a side trace and the exit will be patched into a conditional branch.  Very nice, but this still means that there can be at most one loop on each trace.</p>\n<p>The implementation of <code>next()</code> has to internally skip over empty slots in the table to only return valid key/value pairs.  If we try to express this in IR code, this would be the &quot;inner&quot; loop and the original loop would be an &quot;outer&quot; one, which doesn't have as much optimization opportunities.  In particular, it can't hoist invariable code out of the loop.</p>\n<p>The solution is to do that slot skipping in C.  Not using the Lua C API, of course, but the inner IR CALL instruction that is compiled into a &quot;fast&quot; call, using CPU registers for arguments as much as possible.</p>\n<h3 id=\"theirisintypespecificssaform\">The IR is in Type-specific SSA form</h3>\n<p>The SSA form (<a href=\"https://en.wikipedia.org/wiki/Static_single_assignment_form\">Static Single Assignment</a>) is key for many data flow analysis heuristics that allow quick optimizations like dead code removal, allocation sinking, type narrowing, strength reduction, etc. In LuaJIT's IR it means every instruction is usable as a value for subsequent instructions and has a declared type, fixed at the moment when the trace recorder emits this particular IR instruction.  In addition, every instruction can be a type guard, if the arguments are not of the expected type the trace will be exited.</p>\n<p>Lua is dynamically typed, every value is tagged with type information so the bytecode interpreter can apply the correct operations on it.  This allows us to have variables and tables that can contain and pass around any kind of object without changing the source code.  Of course, this requires the interpreter to be coded very &quot;defensively&quot;, to consider all valid ramifications of every instruction, limiting the possibility of optimizations.  The IR traces, on the other hand, are optimized for a single variation of the code, and deal with only the value types that are actually observed while executing.</p>\n<p>For example, this simple code creates a 1,000 element array and then copies to another table:</p>\n<pre><code>local t,t2 = {},{}\nfor i=1,1000 do\n    t[i] = i\nend\nfor i,v in ipairs(t) do\n    t2[i]=v\nend\n</code></pre>\n<p>resulting in this IR for the second loop, the one that does the copy:</p>\n<pre><code>0023 ------------ LOOP ------------\n0024          num CONV   0017  num.int\n0025       &gt;  int ABC    0005  0017\n0026          p32 AREF   0007  0017\n0027          num ASTORE 0026  0022\n0028 rbp    + int ADD    0017  +1\n0029       &gt;  int ABC    0018  0028\n0030          p32 AREF   0020  0028\n0031 xmm7  &gt;+ num ALOAD  0030\n0032 xmm7     num PHI    0022  0031\n0033 rbp      int PHI    0017  0028\n0034 rbx      nil RENAME 0017  #3\n0035 xmm6     nil RENAME 0022  #2\n</code></pre>\n<p>Here we see the <code>ALOAD</code> in instruction <code>0031</code> assures that the value loaded from the table is in effect a number.  If it happens to be any other value, the guard fails and the trace is exited.</p>\n<p>But if we do an array of strings instead of numbers?</p>\n<p>a small change:</p>\n<pre><code>local t,t2 = {},{}\nfor i=1,1000 do\n    t[i] = 's'..i\nend\nfor i,v in ipairs(t) do\n    t2[i]=v\nend\n</code></pre>\n<p>gives us this:</p>\n<pre><code>0024 ------------ LOOP ------------\n0025          num CONV   0018  num.int\n0026       &gt;  int ABC    0005  0018\n0027          p32 AREF   0007  0018\n0028          str ASTORE 0027  0023\n0029 rbp    + int ADD    0018  +1\n0030       &gt;  int ABC    0019  0029\n0031          p32 AREF   0021  0029\n0032 rbx   &gt;+ str ALOAD  0031\n0033 rbx      str PHI    0023  0032\n0034 rbp      int PHI    0018  0029\n0035 r15      nil RENAME 0018  #3\n0036 r14      nil RENAME 0023  #2\n</code></pre>\n<p>It's the same code, but the type that <code>ALOAD</code> is guarding is now a string (and it now uses a different register, I guess a vector register isn't appropriate for a string pointer).</p>\n<p>And if the table has a values of a mix of types?</p>\n<pre><code>local t,t2={},{}\nfor i=1,1000,2 do\n    t[i], t[i+1] = i, 's'..i\nend\nfor i,v in ipairs(t)\n    do t2[i]=v\nend\n\n0031 ------------ LOOP ------------\n0032          num CONV   0027  num.int\n0033       &gt;  int ABC    0005  0027\n0034          p32 AREF   0007  0027\n0035          str ASTORE 0034  0030\n0036 r15      int ADD    0027  +1\n0037       &gt;  int ABC    0019  0036\n0038          p32 AREF   0021  0036\n0039 xmm7  &gt;  num ALOAD  0038\n0040       &gt;  int ABC    0005  0036\n0041          p32 AREF   0007  0036\n0042          num ASTORE 0041  0039\n0043 rbp    + int ADD    0027  +2\n0044       &gt;  int ABC    0019  0043\n0045          p32 AREF   0021  0043\n0046 rbx   &gt;+ str ALOAD  0045\n0047 rbx      str PHI    0030  0046\n0048 rbp      int PHI    0027  0043\n</code></pre>\n<p>Now there are two <code>ALOAD</code>s, (and two <code>ASTORE</code>s), one for 'num' and one for 'str'.  In other words, the JIT unrolled the loop and found that that made the types constant. <code>=8-O</code></p>\n<p>Of course, this would happen only on very simple and regular patterns.  In general, it's wiser to avoid unpredictable type mixing; but polymorphic code will be optimized for each type that it's actually used with.</p>\n<h3 id=\"backtonext\">Back to <code>next()</code></h3>\n<p>First let's see the current implementation of <code>next()</code> as used by the interpreter:</p>\n<pre><code>lj_tab.c\n/* Advance to the next step in a table traversal. */\nint lj_tab_next(lua_State *L, GCtab *t, TValue *key)\n{\n  uint32_t i = keyindex(L, t, key);  /* Find predecessor key index. */\n  for (i++; i &lt; t-&gt;asize; i++)  /* First traverse the array keys. */\n    if (!tvisnil(arrayslot(t, i))) {\n      setintV(key, i);\n      copyTV(L, key+1, arrayslot(t, i));\n      return 1;\n    }\n  for (i -= t-&gt;asize; i &lt;= t-&gt;hmask; i++) {  /* Then traverse the hash keys. */\n    Node *n = &amp;noderef(t-&gt;node)[i];\n    if (!tvisnil(&amp;n-&gt;val)) {\n      copyTV(L, key, &amp;n-&gt;key);\n      copyTV(L, key+1, &amp;n-&gt;val);\n      return 1;\n    }\n  }\n  return 0;  /* End of traversal. */\n}\n</code></pre>\n<p>It takes the input key as a <code>TValue</code> pointer and calls <code>keyindex()</code>.  This helper function searches for the key in the table and returns an index; if the key is an integer in the range of the array part, the index is the key itself.  If not, it performs a hash query and returns the index of the Node, offset by the array size, if successful, or signals an error if not found (it's an error to give a nonexistent key to <code>next()</code>).</p>\n<p>Back at <code>lj_tab_next()</code>, the index is first incremented, and if it's still within the array, it's iterated over any hole until a non-<strong><code>nil</code></strong> value is found.  If it wasn't in the array (or there’s no next value there), it performs a similar &quot;skip the **<code>nil</code>**s&quot; on the Node table.</p>\n<p>The new <code>lj_record_next()</code> function in <code>lj_record.c</code>, like some other record functions there, first checks not only the input parameters, but also the return values to generate the most appropriate code for this specific iteration, assuming that it will likely be optimal for subsequent iterations.  Of course, any such assumption must be backed by the appropriate guard.</p>\n<p>For <code>next()</code>, we choose between two different forms, if the return key is in the array part, then it uses <code>lj_tab_nexta()</code>, which takes the input key as an integer and returns the next key, also as an integer, in the <code>rax</code> register.  We don't do the equivalent to the <code>keyindex()</code> function, just check (with a guard) that the key is within the bounds of the array:</p>\n<pre><code>lj_tab.c\n/* Get the next array index */\nMSize LJ_FASTCALL lj_tab_nexta(GCtab *t, MSize k)\n{\n  for (k++; k &lt; t-&gt;asize; k++)\n    if (!tvisnil(arrayslot(t, k)))\n      break;\n  return k;\n}\n</code></pre>\n<p>The IR code looks like this:</p>\n<pre><code>0014 r13      int FLOAD  0011  tab.asize\n0015 rsi   &gt;  int CONV   0012  int.num\n0017 rax    + int CALLL  lj_tab_nexta  (0011 0015)\n0018       &gt;  int ABC    0014  0017\n0019 r12      p32 FLOAD  0011  tab.array\n0020          p32 AREF   0019  0017\n0021 [8]   &gt;+ num ALOAD  0020\n</code></pre>\n<p>Clearly, the <code>CALL</code> itself (at <code>0017</code>) is typed as '<code>int</code>', as natural for an array key; and the <code>ALOAD</code> (<code>0021</code>) is '<code>num</code>', because that's what the first few values happened to be.</p>\n<p>When we finish with the array part, the bounds check (instruction <code>ABC</code> on <code>0018</code>) would fail and soon new IR would be generated.  This time we use the <code>lj_tab_nexth()</code> function.</p>\n<pre><code>lj_tab.c\nLJ_FUNCA const Node *LJ_FASTCALL lj_tab_nexth(lua_State *L, GCtab *t, const Node *n)\n{\n  const Node *nodeend = noderef(t-&gt;node)+t-&gt;hmask;\n  for (n++; n &lt;= nodeend; n++) {\n    if (!tvisnil(&amp;n-&gt;val)) {\n      return n;\n    }\n  }\n  return &amp;G(L)-&gt;nilnode;\n}\n</code></pre>\n<p>But before doing the &quot;skip the **<code>nil</code>**s&quot;, we need to do a hash query to find the initial <code>Node</code> entry.  Fortunately, the <code>HREF</code> IR instruction does that: This is the IR:</p>\n<pre><code>0014 rdx      p32 HREF   0011  0012\n0016 r12      p32 CALLL  lj_tab_nexth  (0011 0014)\n0017 rax   &gt;+ str HKLOAD 0016\n0018 [8]   &gt;+ num HLOAD  0016\n</code></pre>\n<p>There's a funny thing here: <code>HREF</code> is supposed to return a reference to a value in the hash table, and the last argument in <code>lj_tab_nexth()</code> is a <code>Node</code> pointer.  Let's see the <code>Node</code> definition:</p>\n<pre><code>lj_obj.h\n/* Hash node. */\ntypedef struct Node {\n  TValue val;       /* Value object. Must be first field. */\n  TValue key;       /* Key object. */\n  MRef next;        /* Hash chain. */\n#if !LJ_GC64\n  MRef freetop;     /* Top of free elements (stored in t-&gt;node[0]). */\n#endif\n} Node;\n</code></pre>\n<p>Ok... the value is the first field, and it says right there &quot;Must be first field&quot;.  Looks like it's not the first place with some hand-wavy pointer casts.</p>\n<p>The return value of <code>lj_tab_next()</code> is a <code>Node</code> pointer, which can likewise be implicitly cast by <code>HLOAD</code> to get the value.  To get the key, I added the <code>HKLOAD</code> instruction. Both are guarding for the expected types of the value and key, respectively.</p>\n<h3 id=\"letstakeitforaspin\">Let's take it for a spin</h3>\n<p>So, how does it perform?  These tests do a thousand loops over a 10,000 element table, first using <code>next()</code> and then <code>pairs()</code>, with a simple addition in the inner loop.  To get <code>pairs()</code> compiled, I just disabled the <code>ISNEXT</code>/<code>ITERN</code> optimization, so it actually uses <code>next()</code>.  In the third test the variable in the addition is initialized to <code>0ULL</code> instead of just <code>0</code>, triggering the use of FFI.</p>\n<p>First test is with all 10,000 elements on sequential integers, making the table a valid sequence, so <code>ipairs()</code> (which is already compiled) can be used just as well:</p>\n<p><a href=\"http://blog.cloudflare.com/content/images/2017/02/image02.png\">![](https://blog.cloudflare<img src=\"http://blog.cloudflare.com/content/images/2017/02/image02.png\" alt=\"\" loading=\"lazy\"></a></p>\n<p>So, compiled <code>next()</code> is quite a lot faster, but the <code>pairs()</code> optimization in the interpreter is very fast.  On the other hand, the smallest smell of FFI completely trashes interpreter performance, while making compiled code slightly tighter.  Finally, <code>ipairs()</code> is faster, but a big part of it is because it stops on the first <strong><code>nil</code></strong>, while <code>next()</code> has to skip over every <strong><code>nil</code></strong> at the end of the array, which by default can be up to twice as big as the sequence itself.</p>\n<p>Now with 5,000 (sequential) integer keys and 5,000 string keys.  Of course, we can't use <code>ipairs()</code> here:</p>\n<p><a href=\"http://blog.cloudflare.com/content/images/2017/02/image01.png\">![](https://blog.cloudflare<img src=\"http://blog.cloudflare.com/content/images/2017/02/image01.png\" alt=\"\" loading=\"lazy\"></a></p>\n<p>Roughly the same pattern: the compiled <code>next()</code> performance is very much the same on the three forms (used directly, under <code>pairs()</code> and with FFI code), while the interpreter benefits from the <code>pairs()</code> optimization and almost dies with FFI.  In this case, the interpreted <code>pairs()</code> actually surpasses the compiled <code>next()</code> performance, hinting that separately optimizing <code>pairs()</code> is still desirable.</p>\n<p>A big factor in the interpreter <code>pairs()</code> is that it doesn't use <code>next()</code>; instead it directly drives the loop with a hidden variable to iterate in the <code>Node</code> table without having to perform a hash lookup on every step.</p>\n<p>Repeating that in a compiled <code>pairs()</code> would be equally beneficial; but has to be done carefully to maintain compatibility with the interpreter.  On any trace exit the interpreter would kick in and must be able to seamlessly continue iterating.  For that, the rest of the system has to be aware of that hidden variable.</p>\n<p>The best part of this is that we have lots of very challenging, yet deeply rewarding, work ahead of us! Come <a href=\"https://www.cloudflare.com/join-our-team/\">work for us</a> on making LuaJIT faster and more.</p>\n<!--kg-card-end: markdown-->",
		"comment_id": "4911",
		"feature_image": "http://blog.cloudflare.com/content/images/2018/08/6822250770_d6f8399cf2_z.jpg",
		"featured": false,
		"visibility": "public",
		"created_at": "2017-02-20T14:23:24.000+00:00",
		"updated_at": "2020-08-20T19:06:36.000+01:00",
		"published_at": "2017-02-21T13:40:23.000+00:00",
		"custom_excerpt": "At Cloudflare we’re heavy users of LuaJIT and in the past have sponsored many improvements to its performance.\n\n",
		"codeinjection_head": null,
		"codeinjection_foot": null,
		"custom_template": null,
		"canonical_url": null,
		"authors": [
			{
				"id": "5d1644b141acde0011a94f81",
				"name": "Javier Guerra",
				"slug": "javier-guerra",
				"profile_image": "http://blog.cloudflare.com/content/images/2017/02/headshot.jpeg",
				"cover_image": "http://blog.cloudflare.com/content/images/2019/03/general@2x-2.png",
				"bio": null,
				"website": null,
				"location": null,
				"facebook": null,
				"twitter": null,
				"meta_title": null,
				"meta_description": null,
				"url": "http://blog.cloudflare.com/author/javier-guerra/"
			}
		],
		"tags": [
			{
				"id": "5d16450341acde0011a95225",
				"name": "LUA",
				"slug": "lua",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/lua/"
			},
			{
				"id": "5d16450341acde0011a95214",
				"name": "Programming",
				"slug": "programming",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/programming/"
			},
			{
				"id": "5d16450341acde0011a95160",
				"name": "Speed & Reliability",
				"slug": "speed-and-reliability",
				"description": null,
				"feature_image": "http://blog.cloudflare.com/content/images/2020/10/Speed---Reliability-1.png",
				"visibility": "public",
				"meta_title": "Cloudflare Blog: Speed & Reliability",
				"meta_description": "Collection of Cloudflare blog posts tagged 'Speed & Reliability'.",
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/speed-and-reliability/"
			}
		],
		"primary_author": {
			"id": "5d1644b141acde0011a94f81",
			"name": "Javier Guerra",
			"slug": "javier-guerra",
			"profile_image": "http://blog.cloudflare.com/content/images/2017/02/headshot.jpeg",
			"cover_image": "http://blog.cloudflare.com/content/images/2019/03/general@2x-2.png",
			"bio": null,
			"website": null,
			"location": null,
			"facebook": null,
			"twitter": null,
			"meta_title": null,
			"meta_description": null,
			"url": "http://blog.cloudflare.com/author/javier-guerra/"
		},
		"primary_tag": {
			"id": "5d16450341acde0011a95225",
			"name": "LUA",
			"slug": "lua",
			"description": null,
			"feature_image": null,
			"visibility": "public",
			"meta_title": null,
			"meta_description": null,
			"og_image": null,
			"og_title": null,
			"og_description": null,
			"twitter_image": null,
			"twitter_title": null,
			"twitter_description": null,
			"codeinjection_head": null,
			"codeinjection_foot": null,
			"canonical_url": null,
			"accent_color": null,
			"url": "http://blog.cloudflare.com/tag/lua/"
		},
		"url": "http://blog.cloudflare.com/luajit-hacking-getting-next-out-of-the-nyi-list/",
		"excerpt": "At Cloudflare we’re heavy users of LuaJIT and in the past have sponsored many improvements to its performance.\n\n",
		"reading_time": 15,
		"access": true,
		"comments": false,
		"og_image": null,
		"og_title": null,
		"og_description": null,
		"twitter_image": null,
		"twitter_title": null,
		"twitter_description": null,
		"meta_title": null,
		"meta_description": null,
		"email_subject": null,
		"frontmatter": null,
		"feature_image_alt": null,
		"feature_image_caption": null
	},
	"locale": "en-us"
}