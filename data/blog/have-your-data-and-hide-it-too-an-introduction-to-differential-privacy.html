<div class="mb2 gray5">14 min read</div>
<div class="post-content lh-copy gray1"><!--kg-card-begin: markdown-->
	<p><small>This post is also available in <a href="https://blog.cloudflare.com/zh-cn/have-your-data-and-hide-it-too-an-introduction-to-differential-privacy-zh-cn">ÁÆÄ‰Ωì‰∏≠Êñá</a> and <a href="https://blog.cloudflare.com/zh-tw/have-your-data-and-hide-it-too-an-introduction-to-differential-privacy-zh-tw">ÁπÅÈ´î‰∏≠Êñá</a>.</small></p>
	<!--kg-card-end: markdown-->
	<figure class="kg-card kg-image-card"><img src="https://blog.cloudflare.com/content/images/2023/12/image1-9.png" class="kg-image" alt="Have your data and hide it too: An introduction to differential privacy" loading="lazy" width="1201" height="676"></figure>
	<p>Many applications rely on user data to deliver useful features. For instance, browser telemetry can identify network errors or buggy websites by collecting and aggregating data from individuals. However, browsing history can be sensitive, and sharing this information opens the door to privacy risks. Interestingly, these applications are often not interested in individual data points (e.g. whether a particular user faced a network error while trying to access Wikipedia) but only care about aggregated data (e.g. the total number of users who had trouble connecting to Wikipedia).</p>
	<p>The <a href="https://datatracker.ietf.org/doc/draft-ietf-ppm-dap">Distributed Aggregation Protocol (DAP)</a> allows data to be aggregated without revealing any individual data point. It is useful for applications where a data collector is interested in general trends over a population without having access to sensitive data. There are many use cases for DAP, from <a href="https://www.abetterinternet.org/post/prio-services-for-covid-en">COVID-19 exposure notification</a> to <a href="https://hacks.mozilla.org/2023/10/built-for-privacy-partnering-to-deploy-oblivious-http-and-prio-in-firefox">telemetry in Firefox</a> to <a href="https://machinelearning.apple.com/research/scenes-differential-privacy">personalizing photo albums in iOS</a>. Cloudflare is helping to standardize DAP and its underlying primitives. We are working on an <a href="https://github.com/cloudflare/daphne">open-source implementation of DAP</a> and building a service to run with current and future partners. Check out <a href="https://blog.cloudflare.com/deep-dive-privacy-preserving-measurement">this blog post</a> to learn more about how DAP works.</p>
	<p>DAP takes a significant step in the right direction, but private aggregation alone is often not sufficient to protect privacy. In this post, we explain the shortcomings of DAP, and how we can improve it by adding differential privacy.</p>
	<h3 id="the-problem-private-aggregation-is-not-enough">The problem: private aggregation is not enough</h3>
	<p>DAP uses a cryptographic technique called <em>multi-party computation</em>. At a high-level, multi-party computation increases privacy by distributing the computation of the aggregate across multiple servers such that no server sees any individual's data in the clear. (See <a href="https://blog.cloudflare.com/deep-dive-privacy-preserving-measurement">our earlier blog post on DAP for a primer on multi-party computation</a>.) At first, it may seem like this ought to be sufficient to protect the privacy of each individual user: the data collector learns only the information it <em>needs </em>(namely, the aggregate), and not the underlying data used to compute it. Unfortunately this is often not the case because the aggregate itself can sometimes reveal lots of private information.</p>
	<figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.cloudflare.com/content/images/2023/12/image9.jpg" class="kg-image" alt="" loading="lazy" width="921" height="734">
		<figcaption><em>8ft 11.1in (2.72m) tall Robert Wadlow posing for a family photograph, 1939. Credit: </em><a href="https://www.flickr.com/photos/paille-fr/24559019804"><em>Paille</em></a><em> // CC BY-SA 2.0.</em></figcaption>
	</figure>
	<p>As a trivial example, computing an average over a set of numbers with just one input in it reveals the value of the unique element in the set. But even learning the sum of some numbers can also reveal whether there is a particularly large or small number in the set. For example, suppose we're computing the average height of a group of people. If a member of the group is particularly tall (as illustrated above), then knowing how many people are in the group and the expected average height, we can infer a significant amount of information about that individual's height.</p>
	<p>More generally, releasing too many accurate aggregates about a database can allow an attacker to <a href="https://differentialprivacy.org/reconstruction-theory">reconstruct the whole database</a>.</p>
	<p>Such attacks exist in real life. For instance, deanonymization attacks <a href="https://www2.census.gov/about/training-workshops/2021/2021-05-07-das-presentation.pdf">against the U.S. Census</a> have been credibly demonstrated. <a href="https://www.cloudflare.com/learning/ai/what-is-large-language-model">Large language models</a>, such as ChatGPT, are also vulnerable; a <a href="https://www.cloudflare.com/learning/ai/what-is-machine-learning">machine learning model</a> can be seen as a particular type of statistical aggregate computed over a training dataset. Here is an example of an attack, where researchers gave a special instruction to GPT-2 and extracted the name, address and phone number of a real individual whose data appeared only once in the training dataset:</p>
	<figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.cloudflare.com/content/images/2023/12/Screenshot-2023-12-22-at-15.49.54.png" class="kg-image" alt="" loading="lazy" width="3398" height="1548">
		<figcaption><em>Figure 1 from ‚ÄúExtracting Training Data from Large Language Models‚Äù, USENIX Security ‚Äò21, </em><a href="https://arxiv.org/pdf/2012.07805.pdf"><em>https://arxiv.org/pdf/2012.07805.pdf</em></a><em>.</em></figcaption>
	</figure>
	<p>One way of protecting the inputs to model training is a technique called <em>federated learning</em>, where the data are kept on end user devices and model updates are aggregated by a central server. (The aggregation step can even be done in DAP.) Yet even these systems are vulnerable to clever attacks that can leverage the final model, along with some intermediate versions, to reconstruct sensitive data.</p>
	<p>We illustrate this idea in the figure below, which comes from a recent paper describing an attack on a machine learning model being trained for image classification. In this example we begin with 8 users, each of whom has one labeled image (e.g. an image of a cat that has been labeled ‚ÄúCat‚Äù). These starting images are referred to as the <em>Ground Truth</em>. Each user runs their image through the image classification model to see if it can accurately label what is in the photograph. When the model misses, it generates a model update ‚Äî a set of data that tells the model how to improve itself, so that it more reliably recognizes that user‚Äôs photo next time.</p>
	<p>All eight users generate their own model update locally, and then federated learning is used to take the average of those model improvements, in a manner ostensibly designed to avoid any individual update or photograph from being extracted. However, researchers were able to exploit this approach.</p>
	<p>The goal of the attack is to reconstruct the 8 Ground Truth images in the bottom row of the figure, with only access to the federated, average update. The attacker starts from a random guess ("Initial"), and progressively improves it by moving the guess in a direction that would give an update similar to the true average update. After enough iterations, we see that the images in the attacker's guess ("Fully Leaked") are close to the images in the true Ground Truth dataset, although the order can be different.</p>
	<figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.cloudflare.com/content/images/2023/12/Screenshot-2023-12-22-at-8.02.00-AM.png" class="kg-image" alt="" loading="lazy" width="1868" height="686">
		<figcaption><em>Figure 4 from ‚ÄúDeep Leakage from Gradients‚Äù, NeurIPS ‚Äò19, </em><a href="https://arxiv.org/pdf/1906.08935.pdf"><em>https://arxiv.org/pdf/1906.08935.pdf</em></a><em>.</em></figcaption>
	</figure>
	<p>These attacks suggest that private aggregation (with DAP or by some other means) is not sufficient for privacy. Luckily there is a way forward: a variety of organizations, including <a href="https://machinelearning.apple.com/research/scenes-differential-privacy">Apple</a>, and <a href="https://blog.research.google/2022/02/federated-learning-with-formal.html">Google</a>, the <a href="https://www2.census.gov/library/publications/decennial/2020/census-briefs/c2020br-03.pdf">U.S. Census Bureau</a> and a <a href="https://desfontain.es/privacy/real-world-differential-privacy.html">growing set of industry and government actors</a>, now use <strong>differential privacy</strong> to protect their data.</p>
	<h3 id="differential-privacy">Differential privacy</h3>
	<p><strong>Differential privacy (DP) is a statistical framework that provides an extra layer of data protection for secure aggregation systems</strong>. It adds noise to aggregates, to prevent attackers from learning too much about any individual. Roughly speaking, the amount of randomness added is inversely proportional to a privacy parameter, typically denoted by the Greek letter ùúñ (pronounced "epsilon"): a small ùúñ is more private but has noisy results, while a large ùúñ is less private but more accurate. In this way, ùúñ rigorously quantifies the amount of information revealed by the aggregate.</p>
	<p>To be fair, even without differential privacy, some deployments of computing statistics on sensitive datasets already provide guardrails against the most blatant privacy violations, by imposing certain restrictions. For instance, DAP has a mechanism for preventing the data collector from aggregating batches of inputs that are too small. In other settings, it's possible to redact certain attributes when they do not appear often in the dataset, or to limit the number of times a data point can be aggregated. However,<strong> it is easy for such ad-hoc privacy protections to make assumptions about the data that turn out to be invalid.</strong></p>
	<p>First, these restrictions are essentially ‚Äúpatches‚Äù against some obvious attacks, but do not necessarily cover every possible attack. For instance, some aggregation tasks are particularly sensitive to outliers could still leak whether a particularly unusual measurement is part of the aggregation set. Moreover, while simple aggregates such as sums are easier to protect with handcrafted rules, multidimensional and structured statistics such as (averaged) <a href="https://www.cloudflare.com/learning/ai/what-is-neural-network">neural network</a> updates can leak a surprisingly large amount of information, as shown in the previous section. On the contrary, <strong>differential privacy is a general property that protects complex statistics even against adversaries we know nothing about.</strong></p>
	<p>Second, another benefit of differential privacy is that it harmonizes the security parameters across applications: the privacy guarantees are expressed as a particular value for ùúñ, that can be compared across use cases going from bit counts to federated learning. The value of ùúñ can also be communicated publicly or discussed with DP experts. While setting ùúñ is still a complicated matter (see below), it is at least less application-dependent than setting parameters such as the number of measurements to aggregate. In fact, <strong>the</strong> <strong>differential privacy parameter constitutes an extra degree of freedom which disentangles privacy from other application-specific parameters</strong>, giving more control over tradeoffs between utility and privacy (e.g. it is possible to fix ùúñ first, and then independently decide on the batch size for an aggregation task).</p>
	<p>Finally, most handcrafted protection and anonymity techniques do not offer the same elegant and practical properties as differential privacy. For instance,<strong> DP guarantees degrade gracefully </strong>when groups of reports are correlated, or when the same underlying data is aggregated multiple times (which is essential in some applications like federated learning), while ad-hoc methods or definitions such as <a href="https://www.usenix.org/conference/usenixsecurity22/presentation/cohen">k-anonymity can fail catastrophically</a> in these cases. DP has other desirable properties, such as resilience to side information (for instance, some real-life privacy attacks can leverage datasets purchased from data brokers).</p>
	<p>Fundamentally, differential privacy transforms the cat-and-mouse game of privacy engineering into a rigorous, mathematical framework in which privacy is proven, not merely claimed.</p>
	<h3 id="the-science-of-privacy-engineering-making-dap-differentially-private">The science of privacy engineering: Making DAP differentially private</h3>
	<p>As an intern at Cloudflare (Summer 2023), my task was to devise a strategy for endowing DAP with differential privacy, while optimizing for some of Cloudflare's use cases for DAP that we‚Äôll explore in this post. There are many ways to do this. We highlight three techniques, that come with different threat models:</p>
	<ul>
		<li>The simplest way is to compute the aggregate as usual, and then add noise to that. The DAP protocol defines a role known as the "Collector", who is the intended recipient of the aggregate result. The Collector could add noise itself (which we might call Collector Randomization or <strong>Central DP</strong>). The problem of course is that the aggregate result is not DP from the point of view of the Collector.</li>
		<li>Another method ‚Äì called <strong>Local DP</strong>, or Client Randomization in the DAP context ‚Äì is to ask each client to add noise to its report before submitting it. This provides strong privacy guarantees (DP holds even if all the Aggregators and the Collector are malicious) but usually comes at a cost in accuracy. This is because more noise has to be added to each measurement in order to achieve privacy. Though <a href="https://differentialprivacy.org/privacy-doona">recent advances</a> make such protocols practical in some cases.</li>
		<li>DAP involves another role, called an "Aggregator", that computes a share of the aggregate result. (Combining the Aggregators' share yields the aggregate result.) As a middle-ground, <strong>we can have each Aggregator add noise to its aggregate share, thereby ensuring that the aggregate is DP from the point of view of the Collector</strong>. We must trust, of course, that at least one Aggregator is honest and adds noise from the proper distribution.</li>
	</ul>
	<p>This third method, which we'll call Aggregator Randomization, is the method we decided to investigate during my internship. It is straightforward to implement, has about the same computational overhead as basic Central DP, and satisfies the same threat model as DAP (more on that later!). Aggregator Randomization is illustrated below.</p>
	<figure class="kg-card kg-image-card"><img src="https://blog.cloudflare.com/content/images/2023/12/image4-1.png" class="kg-image" alt="" loading="lazy" width="1308" height="483"></figure>
	<p>Although our Aggregator-Randomization version of DAP seems straightforward, we need to be convinced that it provides the privacy guarantees we expect. That means writing down the protocol and carrying out a formal analysis of its guarantees.</p>
	<p>Interestingly, the <a href="https://www.cis.upenn.edu/~aaroth/Papers/privacybook.pdf">traditional definition of DP and the standard proof techniques</a> do not apply immediately to our setting. Indeed, unlike most DP mechanisms, <strong>DAP is an interactive protocol involving many parties </strong>(Clients, Aggregators, Collector) distributed across the Internet, and some of them might be malicious. Moreover, <strong>DAP‚Äôs security is based on computational assumptions</strong> (we assume that certain cryptographic problems, like cracking AES, are prohibitively costly), which consider adversaries that might run in a "reasonable" amount of time. Standard notions of DP consider adversaries that have arbitrary run time.</p>
	<p>Luckily, other protocols combining differential privacy with multiparty computation have been studied in the past, and there are suitable definitions under the umbrella of <a href="https://privacytools.seas.harvard.edu/files/privacytools/files/cdp.pdf"><strong>Computational Differential Privacy</strong></a><strong>. </strong>This definition of DP makes it possible to model a computationally bounded adversary interacting with a real-world protocol containing cryptographic components. However, more work needs to be done to build a generic framework for composing DP mechanisms with existing DAP subroutines (that already come with proven security guarantees).</p>
	<h3 id="example-making-network-error-logging-private">Example: Making Network Error Logging private</h3>
	<p>To keep things concrete and get some experimental data, we looked for real-life DAP use cases where differential privacy could be useful and immediately applicable. Consider a protocol that privately aggregates and reports client-side connection errors to an origin, as a privacy-preserving alternative to <a href="https://developers.cloudflare.com/support/network/understanding-network-error-logging">Network Error Logging (NEL)</a>. It is a good use-case for DAP, because it is desirable to collect aggregate statistics (e.g. number of <code>tcp.timed_out</code> errors for a particular domain, or domains with the most errors in the past 24 hours), but individual reports may reveal sensitive information about browsing habits.</p>
	<p>For simplicity, let‚Äôs focus on the case where the list of domains is already known, e.g., to track connection errors for a single domain, or across a closed set of paying customers. For the rest of the blog post, you can assume that we are using a DAP deployment to compute a histogram of connection errors for a single domain (but other statistics from the DAP specification share the same structure, which makes them suitable for similar DP mechanisms). The true aggregate might look something like this:</p>
	<figure class="kg-card kg-image-card"><img src="https://blog.cloudflare.com/content/images/2023/12/Screenshot-2023-12-22-at-15.55.38.png" class="kg-image" alt="" loading="lazy" width="1612" height="902"></figure>
	<p>In this figure, we see a typical distribution of errors from 1,000 reports. The actual error types are irrelevant, and thus are just represented by numbers here. error_type = 8 is by far the most common, but we observe a smattering of other error types as well.</p>
	<p>As we saw earlier, this aggregate information might still leak sensitive information ‚Äì for instance, if an error type occurs only once, we might be able to tell whether a particular user visited a certain website. Now, our goal is to modify DAP to output a slightly noisy version of the histogram, so that it doesn‚Äôt leak information about individual reports.</p>
	<p><a href="https://github.com/divviup/libprio-rs">libprio-rs</a> is a widely-used Rust implementation of the cryptographic primitives used in DAP. To add DP, we started by <a href="https://github.com/divviup/libprio-rs/pull/607">designing</a> a general API that any Aggregator Randomization scheme should satisfy, with objects to represent privacy budget and noise addition. Then, we <a href="https://github.com/divviup/libprio-rs/pull/578">implemented</a> the DP API for concrete statistical aggregates. After reviewing various DP mechanisms, we settled on the discrete Gaussian and the discrete Laplace mechanisms, because of their clear guarantees and their suitability for modular ring arithmetic. We leveraged a secure noise sampler written in Rust by the <a href="https://github.com/opendp/opendp">OpenDP</a> library. After adapting the <a href="https://github.com/cloudflare/daphne">Daphne</a> implementation of DAP, we were able to run a toy deployment of DAP with differential privacy on network error logging data!</p>
	<h3 id="the-art-of-privacy-engineering-exploring-the-privacy-utility-trade-off">The art of privacy engineering: Exploring the privacy-utility trade-off</h3>
	<p>Recall that differential privacy involves a parameter, ùúñ, that determines the degree of privacy our system can achieve. From the code's perspective, any positive real number is a valid choice here: smaller is more private, but also less useful. So what should we pick for ùúñ?</p>
	<p>Up until this point, we have treated DP engineering as a science, but choosing ùúñ remains somewhat of an art. To illustrate, let's go back to our NEL data and compute some DP histograms for the network errors on one domain. Here are noisy histograms for different values of ùúñ:</p>
	<figure class="kg-card kg-image-card"><img src="https://blog.cloudflare.com/content/images/2023/12/image3-1.png" class="kg-image" alt="" loading="lazy" width="946" height="480"></figure><!--kg-card-begin: markdown-->
	<p>We observe that decreasing ùúñ yields noisier results, even giving negative counts in some cases ‚Äì although we can always truncate or round results without losing privacy. Since this example has many reports and a few possible errors, it is reasonably easy to mask the contribution of any single individual. Here we see that ùúñ = 1 seems to be a reasonable choice for this use case. We can still observe that the relative error is higher for rare events (such as error_type = 15) than for common errors (such as error_type = 8).</p>
	<!--kg-card-end: markdown-->
	<p>Let‚Äôs focus on these two events, and look at how ùúñ impacts accuracy:</p>
	<figure class="kg-card kg-image-card"><img src="https://blog.cloudflare.com/content/images/2023/12/Screenshot-2023-12-22-at-15.58.14.png" class="kg-image" alt="" loading="lazy" width="1588" height="742"></figure><!--kg-card-begin: markdown-->
	<p>It becomes clearer that the accuracy increases with ùúñ ‚Äì an aggregate that is less noisy is also less private and more accurate. This tradeoff is known as the privacy-utility tradeoff. You can notice that the tradeoff depends on what we are measuring. If we are only interested in error_type = 8 and can tolerate at most 2% of relative error, then using ùúñ = 0.01 would be sufficient. If we are interested in error_type = 15, then we would need to use ùúñ = 0.1 to reach the same level of accuracy.</p>
	<!--kg-card-end: markdown-->
	<p>We can also look at how other parameters, such as batch size, can impact accuracy for a fixed privacy guarantee:</p>
	<figure class="kg-card kg-image-card"><img src="https://blog.cloudflare.com/content/images/2023/12/Screenshot-2023-12-22-at-15.58.38.png" class="kg-image" alt="" loading="lazy" width="1598" height="734"></figure>
	<p>Intuitively, if we wait longer before computing an aggregate, we can get more accurate results for the same privacy level, because it is easier to mask a contribution if it is drowned in a large batch. As noted previously, we can set the privacy level upfront and adjust aggregation parameters later. If we try to collect an aggregate over a batch of size 1, the DP result will simply be close to random, and therefore protect the value of the single report in that batch. This graceful degradation ‚Äì output useless results rather than breaking privacy on small batches ‚Äì can be a problem in applications where accuracy is particularly important, but it can be controlled by choosing an ùúñ that satisfies a comfortable accuracy-privacy tradeoff. <strong>It is always possible to get more accurate results, if we are willing to pay the privacy price for it.</strong></p>
	<p>Which brings us back to the question: what is a good value for ùúñ? Unfortunately, <strong>experts still haven‚Äôt reached a consensus on the right method to find ùúñ</strong>, as noted in <a href="https://journalprivacyconfidentiality.org/index.php/jpc/article/view/689">this 2019 paper</a> by Cynthia Dwork (one of the inventors of DP), Kohli and Mulligan. Indeed, some values of ùúñ are suitable for certain deployments, algorithms, datasets or threat models, but not others. Unlike cryptographic applications that force attackers to guess a key that might have 2^128 values, ùúñ has to be set to some non-negligible value in order to learn anything useful from the data. Ultimately, the notion of usefulness and what constitutes a privacy harm is dependent on the application.</p>
	<p>Until we have a better understanding, <strong>a simple approach for non-experts is to search for the ‚Äústandard‚Äù ùúñ used in similar applications, and maximize accuracy under that privacy constraint</strong>. This method works if we have access to an ‚Äú<a href="https://journalprivacyconfidentiality.org/index.php/jpc/article/view/689">ùúñ Registry</a>‚Äù, a detailed list of deployments for various use-cases and threat models. The US Census Bureau has an<a href="https://csrc.nist.gov/CSRC/media/Projects/pec/documents/stppa-01-20200127-talk03-Garfinkel-diff-priv-census.pdf"> internal registry</a>, but only some use cases are published so far. NIST gives some recommended ranges in<a href="https://www.nist.gov/blogs/cybersecurity-insights/differential-privacy-future-work-open-challenges"> this informal blog post</a> (tldr: 0 &lt; ùúñ &lt; 5 is strong, 5 &lt; ùúñ &lt; 20 can be enough in practice).<a href="https://desfontain.es/privacy/real-world-differential-privacy.html"> This blog post</a> lists ùúñs for deployments from Apple, Google and others.</p>
	<p>There are <a href="https://git.gnunet.org/bibliography.git/plain/docs/Choosing-%CE%B5-2011Lee.pdf">additional</a> <a href="https://haeberlen.cis.upenn.edu/papers/epsilon-csf2014.pdf">strategies</a> to set or evaluate the <a href="https://arxiv.org/pdf/2006.07709.pdf">empirical guarantees</a> of ùúñ. A complementary approach is to determine the maximum error you are willing to accept (e.g. 5% relative error on a count) and use simple properties of standard DP mechanisms to find the corresponding value of ùúñ and check that it falls within an acceptable range.</p>
	<h3 id="conclusion">Conclusion</h3>
	<p>As secure aggregation protocols such as DAP are increasingly deployed in real-world applications, it is important to remember that secure aggregation is not always enough to satisfy the users‚Äô expectations of privacy. Differential privacy adds an extra layer of protection to these protocols. <strong>In short, secure aggregation protects the ‚Äú</strong><em><strong>how‚Äù</strong></em><strong> (how to compute an aggregate from a set of reports), and DP protects the ‚Äú</strong><em><strong>what‚Äù</strong></em><strong> (what kind of noisy aggregate we should release to avoid leaking too much information).</strong></p>
	<p>Thanks to the growing number of open-source implementations, applied research and standardization efforts for differential privacy and secure aggregation, there is now a clear path to integrate DP and DAP, thereby strengthening the privacy guarantees of practical measurement tasks. Interestingly, during our analysis we identified some parts of the DAP protocol that could pose problems with some forms of DP guarantees, such as the fact that Aggregators have access to the number of measurements or to the IP addresses of Clients. These findings, along with more thinking about the protocol logic, nourished <a href="https://datatracker.ietf.org/doc/draft-wang-ppm-differential-privacy">debate around this and other topics at the IETF</a>.</p>
	<p>We also encountered many details that are often overlooked in the DP literature, such as modular arithmetic, API considerations, secure sampling or timing attacks. Overall, there is space for <strong>fruitful collaborations between cryptography and differential privacy</strong> experts, on protocols that can have a real impact.</p>
	<p>If you're interested in getting hands on with differential privacy, DAP, or any of Cloudflare's other privacy-focused projects, consider applying for <a href="https://research.cloudflare.com/outreach/academic-programs/interns">an internship on the Research team</a>.</p>
	<h3 id="acknowledgements">Acknowledgements</h3>
	<p>I‚Äôd like to thank my fantastic mentor Christopher Patton for guiding me during the summer ‚Äì I learned many things from cryptographic details to IETF standards, and had a lot of fun along the way. Thanks to Josh Brown and Tanya Verma for our discussions, and to Avani Wildani and the rest of the Research team for their incredible support!</p>
</div>