<div class="mb2 gray5">1 min read</div><img class="mr2" src="https:undefined" alt="">
<div class="post-content lh-copy gray1">
	<p>Here's a small Go gotcha that it's easy to fall into when using goroutines and closures. Here's a simple program that prints out the numbers 0 to 9:</p>
	<p>(You can play with this in the Go Playground <a href="https://play.golang.org/p/dLfrQ7JCf5">here</a>)</p>
	<pre class="language-bash"><code class="language-bash">package main

import "fmt"

func main() {
	for i := 0; i &lt; 10; i++ {
		fmt.Printf("%d ", i)
	}
}</code></pre>
	<p>It's output is easy to predict:</p>
	<pre class="language-bash"><code class="language-bash">0 1 2 3 4 5 6 7 8 9</code></pre>
	<p>If you decided that it would be nice to run those <code>fmt.Printf</code>s concurrently using goroutines you might be surprised by the result. Here's a version of the code that runs each <code>fmt.Printf</code> in its own goroutine and uses a <code>sync.WaitGroup</code> to wait for the goroutines to terminate.</p>
	<pre class="language-bash"><code class="language-bash">package main

import (
	"fmt"
    "runtime"
	"sync"
)

func main() {
	runtime.GOMAXPROCS(runtime.NumCPU())
    
	var wg sync.WaitGroup
	for i := 0; i &lt; 10; i++ {
		wg.Add(1)
		go func() {
			fmt.Printf("%d ", i)
			wg.Done()
		}()
	}
	
	wg.Wait()
}</code></pre>
	<p>(This code is in the Go Playground <a href="https://play.golang.org/p/VmW3H-xqsz">here</a>). If you're thinking concurrently then you'll likely predict that the output will be the numbers 0 to 9 in some random order depending on precisely when the 10 goroutines run.</p>
	<p>But the output is actually:</p>
	<pre class="language-bash"><code class="language-bash">10 10 10 10 10 10 10 10 10 10</code></pre>
	<p>Why?</p>
	<p>Because each of those goroutines is sharing the single variable <code>i</code> across the ten closures generated by the <code>func()</code> used for each goroutine.</p>
	<p>The output from the goroutines will depend on the value of <code>i</code> when they start running. In the example, above they didn't actually start running until the loop had terminated and <code>i</code> had the value 10.</p>
	<p>This programmer error can have other weird effects depending on the variable that's being shared across the goroutine closures.</p>
	<p>To solve this the simplest solution is to create a new variable, a parameter to the <code>func()</code> and pass <code>i</code> into the function call. Like this:</p>
	<pre class="language-bash"><code class="language-bash">package main

import (
	"fmt"
    "runtime"
	"sync"
)

func main() {
	runtime.GOMAXPROCS(runtime.NumCPU())
    
	var wg sync.WaitGroup
	for i := 0; i &lt; 10; i++ {
		wg.Add(1)
		go func(i int) {
			fmt.Printf("%d ", i)
			wg.Done()
		}(i)
	}
	
	wg.Wait()
}</code></pre>
	<p>(The code for that is <a href="https://play.golang.org/p/IeFgq5CNOk">here</a>). That works correctly.</p>
	<p>This is such a common gotcha that it's also in the <a href="https://golang.org/doc/faq#closures_and_goroutines">FAQ</a>.</p>
</div>