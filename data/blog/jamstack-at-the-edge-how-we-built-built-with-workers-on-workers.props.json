{
	"post": {
		"id": "5e3098e755638b02a594af21",
		"uuid": "311c69fb-3929-4ab5-a273-ea4a1588c0e6",
		"title": "JAMstack at the Edge: How we built Built with Workers… on Workers",
		"slug": "jamstack-at-the-edge-how-we-built-built-with-workers-on-workers",
		"html": "<p>I'm extremely stoked to announce <a href=\"https://workers.cloudflare.com/built-with\">Built with Workers</a> today – it's an awesome resource for exploring what you can build with <a href=\"https://workers.cloudflare.com/\">Cloudflare Workers</a>. As Adam explained in <a href=\"http://blog.cloudflare.com/built-with-workers/\">our launch post</a>, showcasing developers building incredible projects with tools like Workers KV or our <a href=\"https://developers.cloudflare.com/workers/reference/apis/html-rewriter/\">streaming HTML rewriter</a> is a great way to celebrate users of our platform. It also helps encourage developers to try building their dream app on top of Workers. In this post, I’ll explore some of the architectural and implementation designs we made while building the site.</p><p>When we first started planning Built with Workers, we wanted to use the site as an opportunity to build a new greenfield application, showcasing the strength of the Workers platform. The Workers Developer Experience team is cross-functional: while we might spend most of our time improving our docs, or developing features for our command-line interface <a href=\"https://github.com/cloudflare/wrangler\">Wrangler,</a> most of us have spent years developing on the web. The prospect of starting a new application is always fun, but in this instance, it was a prime chance to ask (and answer) the question, <em>\"If I could build this site on Workers with whatever tools I want, what would I choose?\"</em></p><p>A guiding principle for the Workers platform is ease-of-use. The programming model is simple: it's just JavaScript (or, via WASM, Rust, C, and C++), and you have complete control over the requests coming in and the requests going out from your Workers script. In the same way, while building Built with Workers, it was <strong>crucial</strong> to find a set of tools that could enable something like this throughout the process of building the entire application. To enable this, we've embraced <strong>JAMstack</strong> – a software stack comprised of JavaScript, <a href=\"https://www.cloudflare.com/learning/security/api/what-is-an-api/\">APIs</a>, and markup – with Built with Workers, deploying always up-to-date static builds of the site <em>directly to the edge</em>, using <a href=\"https://workers.cloudflare.com/sites\">Workers Sites</a>. Our framework of choice, <a href=\"https://www.gatsbyjs.org/)\">Gatsby.js</a>, provides a set of sane defaults to build a modern web application. To manage content and the layout of the site, we've chosen <a href=\"https://www.sanity.io/\">Sanity.io</a>, a powerful <a href=\"https://en.wikipedia.org/wiki/Headless_content_management_system\">headless CMS</a> that allows us to model the entire website without needing to deploy any databases or spin up any additional infrastructure.</p><p>Personally, I'm excited about JAMstack as a methodology for building web applications <em>because</em> of this emphasis on reducing infrastructure: it's incredibly similar to the motivations behind deploying serverless applications using Cloudflare Workers, and as we developed Built with Workers, we discovered a number of these philosophical similarities in JAMstack and Cloudflare Workers – exciting! To help encourage developers to explore building their own JAMstack applications on Workers, I'm also announcing today that we've made the Built with Workers codebase open-source on GitHub – you can check out how the application is developed, built and deployed from start to finish.</p><p>In this post, we'll dig into Built with Workers, exploring how it works, the technical decisions we've made, and some of the most fascinating aspects of what it means to build applications on the edge.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"http://blog.cloudflare.com/content/images/2020/01/bww.png\" class=\"kg-image\" alt loading=\"lazy\"><figcaption>A screenshot of the Built with Workers homepage</figcaption></figure><h2 id=\"exploring-the-jamstack\">Exploring the JAMstack</h2><p>My first encounter with tooling that would ultimately become part of \"JAMstack\" was in 2013. I noticed the huge proliferation of developers building personal \"static\" sites – taking blog posts written primarily in Markdown, and pushing them through frameworks like Jekyll to build full websites that could easily be deployed to a number of <a href=\"https://www.cloudflare.com/learning/cdn/what-is-a-cdn/\">CDNs</a> and file hosting platforms. These static sites were <strong>fast</strong> – they are just HTML, CSS, and JavaScript – and <strong>easy to update</strong>. The average developer spends their days maintaining large and complex software systems, so it was relaxing to just write Markdown, plug in some re-usable HTML and CSS, and deploy your website. The advent of static sites, of course, isn't new – but after years of increasingly complex full-stack technology, the return to simplicity was a promising development for many kinds of websites that didn't need databases, or any dynamic content.</p><p>In the last couple years, JAMstack has built upon that resurgence, and represents an approach to building complete, complex applications using the same tooling that has become the first choice for developers building their simple personal sites. JAMstack is comprised of three conceptual pieces – <em>JavaScript</em>, <em>APIs</em>, and <em>Markup</em> – each of which is a crucial aspect of simplifying our web applications and making them easy to write, build, and deploy.</p><h3 id=\"j-is-for-javascript\">J is for JavaScript</h3><p>The JAMstack architecture relies heavily on the ubiquity of JavaScript as the language of the web. Many modern web applications use powerful, dynamic front-end frameworks like <em>React</em> and <em>Vue</em> to render user interfaces and process state on the client for users. On the backend, or in Workers' case, on the edge, any dynamic functionality in your JAMstack application should be built on top of JavaScript, often working in the request-response model that full-stack developers are accustomed to.</p><p>The Workers platform is <strong>perfectly</strong> suited to this requirement! As a developer building on Workers, you have total control of incoming requests and outgoing responses, using the JavaScript Service Worker APIs you know and love. We built <a href=\"https://workers.cloudflare.com/sites\">Workers Sites</a> as an extension of the Workers platform (and Workers KV as a storage mechanism at the edge), making it possible to deploy your site assets using a single command in Wrangler: <code>wrangler publish</code>. </p><p>When your Workers Site receives a new request, we'll execute JavaScript at the edge to look up a piece of content from Workers KV, and serve it back to the client at lightning speed. Remarkably, you can deploy JAMstack applications on Workers with no additional configuration besides <a href=\"https://developers.cloudflare.com/workers/sites/start-from-existing\">generating your Workers Site</a> – <strong>by design, Workers Sites is built to serve as an exceptional JAMstack deployment platform</strong>.</p><h3 id=\"a-is-for-apis\">A is for APIs</h3><p>The advent of static site tooling for personal sites makes sense: your site is a few pages: a few blog posts, for instance, and the classic \"About\" or \"Contact\" page. When it's compiled to HTML, the footprint is quite small! This small footprint is what makes static sites easy to reason about: they're trivial to host in terms of bandwidth and storage costs, and they rarely change, so they're easily cacheable.</p><p>While that works for personal sites, complex applications actually have data requirements! We need to talk to the user data in our databases, and analytics information in our data warehouses. JAMstack apps tackle this by definitively stating that these data sources should be accessible via HTTPS APIs, consumable by the application as a way to provide dynamic information to clients.</p><p>Workers is a <strong>fascinating</strong> platform in regards to JAMstack APIs. It can serve as a gateway to your data, or as a place to persist and return data itself. I can, for instance, expose an API endpoint via my Workers script without giving clients access to my origin. I can also use tooling like <a href=\"https://www.cloudflare.com/products/workers-kv/\">Workers KV</a> to persist data directly on the edge, and when a user requests that data, I can resolve the data by returning JSON directly from my application.</p><p>This flexibility has been an unexpected part of the experience of developing Built with Workers. In a later section of this post, I'll talk about how we developed an integral feature of the site based on the unique strengths of Workers as a way to host static assets <em>and</em> as a dynamic JavaScript execution platform. This has remarkable implications that blur the lines between classic static sites and dynamic applications, and I'm <strong>really</strong> excited about it.</p><h3 id=\"m-is-for-markup\">M is for Markup</h3><p>A breakthrough moment in my understanding of JAMstack came at the beginning of this year. I was working on a job board for frontend developers, using the static site framework Gatsby.js and Sanity.io, a headless CMS tool that allows developers to model content without maintaining a database or any infrastructure. (As a reminder – this set of tools is <em>identical</em> to what we ultimately used to develop Built with Workers. It's a very good stack!)</p><p>SEO is crucial to a job board, and as I began to explore how to drive more traffic to my job board, I landed on the idea of generating a huge amount of search-oriented content automatically from the job data I already had. For instance, if I had job posts with the keywords <em>\"React\"</em>, <em>\"Europe\"</em>, and <em>\"Senior\"</em> (as in <em>\"senior developer\"</em>), what if I created pages with titles like <em>\"Senior React developer jobs in Europe\"</em>, or <em>\"Remote Angular jobs\"</em>? This approach would allow the site to begin ranking for a variety of job positions, locations, and experience levels, and as more jobs were posted on the site, each of these pages would be enriched with more useful information and relevant content, helping it rank higher in search.</p><p><em>\"But static sites are... static!\"</em>, I told myself. Would I need to build an entire dynamic API on top of my static site, just to be able to serve these search-engine optimized pages? This led me to a \"eureka\" moment with Gatsby – I could define markup (the <em>\"M\"</em> in JAMstack), and when I'm building my site, I could look at all the available job data I had, cycling through every available keyword combination and inserting it into my markup to generate thousands of these pages. As I later learned, this idea is not necessarily unique to Gatsby – it is possible, for instance, to automate getting data from your API and writing it to data files in earlier static site frameworks like <a href=\"https://gohugo.io/\">Hugo</a> – but it is a first-class citizen in Gatsby. There are a <em>ton</em> of data sources available via Gatsby plugins, and because they're all exposed via HTTPS, the workflow is standardized inside of the framework.</p><p>In Built with Workers, we connect to the Sanity.io CMS instance at <em>build-time</em>: crucially, by the time that the site has been deployed to Workers, the application effectively has <em>no idea</em> what Sanity even is! Our Gatsby application connects to Sanity.io via an HTTPS API, and using GraphQL, we look at all the data that we have in our CMS, and make decisions about what pages to generate and how to render the site's interface, ultimately resulting in a statically-built application that is derived from dynamic data.</p><p>This emphasis on the <em>build</em> step in JAMstack is quite different than the classic web application. In the past, a user requested data, a web server looked at what the user was requesting, and then the user <em>waits</em>, as the server gets that data, returns JSON, or interpolates it into templates written in tools like <a href=\"https://pugjs.org/\">Pug</a> or <a href=\"https://en.wikipedia.org/wiki/ERuby\">ERB</a>. With JAMstack, the pages are already built, and the deployed application is just a collection of plain HTML, CSS, and JavaScript.</p><h3 id=\"why-cloudflare-workers\">Why Cloudflare Workers?</h3><p>Cloudflare's network is a fascinating place to deploy JAMstack applications. Yes, Cloudflare's edge network can act as a CDN for your static assets, like your CSS stylesheets, or your client-side JavaScript code. But with Workers, we now have the ability to run JavaScript side-by-side with our static assets. In most JAMstack applications, the CDN is simply a bucket where your application ends up. Usually, the CDN is the most boring part of the stack! <strong>With Cloudflare Workers, we don't just have a CDN: we also have access to an extremely low-latency, fully-featured JavaScript runtime.</strong></p><p>The implications of this on the standard JAMstack workflow are, frankly, <em>mind-boggling</em>, and as part of developing Built with Workers, we've been exploring what it means to have this runtime available side-by-side with our statically-built JAMstack application. </p><p>To demonstrate this, we’ve implemented a bookmarking feature, which allows users of Built with Workers to bookmark projects. If you look at a project's usage of our streaming HTML rewriter and say <em>\"Wow, that's cool!\"</em>, you can also bookmark for the project to show your support. This feature, rendered as a <code>button</code> tag is deceptively simple: it's a single piece of the user interface that makes use of the entirety of the Workers platform, to provide user-specific dynamic functionality. We'll explore this in greater detail later in the post – see <em>\"Enhancing static sites at the edge\"</em>.</p><figure class=\"kg-card kg-embed-card\"><blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">i&#39;m super excited about this and spent some time this morning re-writing my first take at this to be something that i think is super compelling<br><br>??<a href=\"https://t.co/LJltC6j20S\">https://t.co/LJltC6j20S</a></p>&mdash; ً (@signalnerve) <a href=\"https://twitter.com/signalnerve/status/1199379423608344576?ref_src=twsrc%5Etfw\">November 26, 2019</a></blockquote>\n<script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n</figure><h2 id=\"a-modern-development-and-content-workflow\">A modern development and content workflow</h2><p>In the <a href=\"http://blog.cloudflare.com/workers-sites/\">announcement post</a> for Workers Sites, Rita outlined the motivations behind launching Workers Sites as a modern way to deploy sites:</p><p><em>\"Born on the edge, Workers Sites is what we think modern development on the web should look like, natively secure, fast, and massively scalable. Less of your time is spent on configuration, and more of your time is spent on your code, and content itself.\"</em></p><p>A few months later, I can say definitively that Workers Sites has enabled us to develop Built with Workers and spend almost no time on configuration. Using <a href=\"https://github.com/cloudflare/wrangler-action\">our GitHub Action</a> for deploying Workers applications with Wrangler, the site has been continuously deploying to a staging environment for the past couple weeks. The simplicity around this continuous deployment workflow has allowed us to focus on the important aspects of the project: development and content.</p><p>The static site framework ecosystem is fairly competitive, but as we considered our options for this site, I advocated strongly for Gatsby.js. It's an incredible tool for building JAMstack applications, with a great set of default for performant applications. It's common to see Gatsby sites with <a href=\"https://developers.google.com/web/tools/lighthouse/\">Lighthouse</a> scores in the upper 90s, and the decision to use React for implementing the UI makes it straightforward to onboard new developers if they're familiar with React.</p><p>As I mentioned in a previous section, Gatsby shines at <em>build-time</em>. Gatsby's APIs for creating pages during the build process based on API data are incredibly powerful, allowing developers to concretely define every statically-generated page on their web application, as well as any relevant data that needs to be passed in.</p><p>With Gatsby decided upon as our static site framework, we needed to evaluate where our content would live. Built with Workers has two primary data models, used to generate the UI:</p><ul><li><strong>Projects</strong>: websites, applications, and APIs created by developers using Cloudflare Workers. For instance, Built with Workers!</li><li><strong>Features</strong>: features available on the Workers platform used to build applications. For instance, Workers KV, or our streaming HTML rewriter/parser.</li></ul><p>Given these requirements, there were a number of potential approaches to take to store this data, and make it accessible. Keeping in line with JAMstack, we know that we probably should expose it via an HTTPS API, but from where? In what format?</p><p>As a full-stack developer who's comfortable with databases, it's easy to envision a world where we spin up a PostgreSQL instance, write a REST API, and write all kinds of <code>fetch('/api/projects')</code> to get the information we need. This method works, but we can do better! In the same way we built Workers Sites to simplify the deployment process, it was worthwhile to explore the JAMstack ecosystem and see what solutions exist for modeling data without being on the hook for more infrastructure.</p><p>Of the different tools in the ecosystem – databases, whether SQL or NoSQL, key-value stores (such as our own, Workers KV), etc. – the growth of \"headless CMS\" tools has made the largest impact on my development workflow. </p><p>On CSS Tricks, Chris Coyier wrote about the rise of headless CMS tools back in March 2016, and <a href=\"https://css-tricks.com/what-is-a-headless-cms/\">summarizes their function</a> well:</p><!--kg-card-begin: markdown--><p><span style=\"color:grey\"><small><em>[Headless CMSes are] very related to The Big Conversation™ on the web the last many years. How are we going to handle bringing Our Stuff™ all these different devices/screens/inputs.<br>\nResponsive design says &quot;let's let our design and media accommodate as much variation in screens as possible.&quot;<br>\nProgressive enhancement says &quot;let's make the functionality of this site work no matter what.&quot;<br>\nDesigning for accessibility says &quot;let's ensure everyone can use this regardless of their capabilities as a person.&quot;<br>\nA headless CMS says &quot;let's not tie our data to any one way of doing things.&quot;</em></small></span></p>\n<!--kg-card-end: markdown--><p>Using our headless CMS, Sanity.io, we can get every project inside our dataset, and call Gatsby's <code>createPage</code> function to create a new page for each project, using a pre-defined project template file:</p><!--kg-card-begin: markdown--><pre><code class=\"language-js\">// gatsby-node.js\n\nexports.createPages = async ({ graphql, actions }) =&gt; {\n  const { createPage } = actions;\n\n  const result = await graphql(`\n    {\n      allSanityProject {\n        edges {\n          node {\n            slug\n          }\n        }\n      }\n    }\n  `);\n\n  if (result.errors) {\n    throw result.errors;\n  }\n\n  const {\n    data: { allSanityProject }\n  } = result;\n\n  const projects = allSanityProject.edges.map(({ node }) =&gt; node);\n  projects.forEach((node, _index) =&gt; {\n    const path = `/built-with/projects/${node.slug}`;\n\n    createPage({\n      path,\n      component: require.resolve(&quot;./src/templates/project.js&quot;),\n      context: { slug: node.slug }\n    });\n  });\n};\n</code></pre>\n<!--kg-card-end: markdown--><p>Using Sanity to drive the content for Built with Workers has been a <em>huge</em> win for our team. We're no longer constrained by code deploys to make changes to content on the site – we don't need to make a pull request to create a new project, and edits to a project's name or description aren't constrained by someone with the ability to deploy the project. Instead, we can empower members of our team to log in directly to the CMS and make changes, and be confident that once the corresponding deploy has completed (see <em>\"The CDN is the deployment platform\"</em> below), their changes will be live on the site.</p><h3 id=\"dynamic-jamstack-layouts\">Dynamic JAMstack layouts</h3><p>As our team got up and running with Sanity.io, we found that the flexibility of a headless CMS platform was useful not just for creating our original data requirements – projects and features – but in rethinking and innovating on how we actually format the application itself.</p><p>With our previous objective of empowering non-technical folks to make changes to the site without deploying any code in consideration, we've also taken the entire homepage of Built with Workers and defined it as an instance of the \"layout\" data model in Sanity.io. By doing this, we can define corresponding \"collections\", which are sets of projects. When a layout has many collections defined inside of the CMS, we can rapidly re-order, re-arrange, and experiment with new collections on the homepage, seeing the updated version of the site reflected immediately, and live on the production site within only a few minutes, after our continuous deployment process has finished.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"http://blog.cloudflare.com/content/images/2020/01/bww-demo.gif\" class=\"kg-image\" alt loading=\"lazy\"><figcaption>Updating the layout of Built with Workers live from Sanity's studio</figcaption></figure><p>With this work implemented, it's easy to envision a world where our React code is purely concerned with rendering each individual aspect of the application's interface – for instance, the project title component, or the \"card\" for an individual project – and the CMS drives the entire layout of the site. In the future, I'd like to continue exploring this idea in other pages in Built with Workers, including the project pages and any other future content we put on the site.</p><h2 id=\"enhancing-static-sites-at-the-edge\">Enhancing static sites at the edge</h2><p>Much of what we've discussed so far can be thought of as features and workflows that have great DX (developer experience), but not specific to Workers. Gatsby and Sanity.io are great, and although Workers Sites is a great platform for deploying JAMstack applications due to the Workers platform's low-latency and performance characteristics, you could deploy the site to a number of different providers with no real differentiating features.</p><p>As we began building a JAMstack application on top of Built with Workers, we also wanted to explore how the Workers platform could allow developers to combine the simplicity of static site deployments with the dynamism of having a JavaScript runtime immediately available.</p><p>In particular, our recently-released streaming HTML rewriter seems like a perfect fit for \"enhancing\" our static sites. Our application is being served by Workers Sites, which itself is a Workers template that can be customized. By passing each HTML page through the HTML rewriter on its way to the client, we had an opportunity to customize the content without any negative performance implications.</p><p>As I mentioned previously, we landed on a first exploration of this platform advantage via the \"bookmark\" button. Users of Built with Workers can \"bookmark\" for a project – this action sends a request back up to the Workers application, storing the bookmark data as JSON in Workers KV.</p><!--kg-card-begin: markdown--><pre><code class=\"language-js\">// User-specific data stored in Workers KV, representing\n// per-project bookmark information\n\n{\n  &quot;bytesized_scraper_bookmarked&quot;: false,\n  &quot;web_scraper_bookmarked&quot;: true\n}\n</code></pre>\n<!--kg-card-end: markdown--><p>When a user returns to Built with Workers, we can make a request to Workers KV, looking for corresponding data for that user and the project they're currently viewing. If that data exists, we can embed the \"edge state\" directly into the HTML using the streaming HTML rewriter.</p><!--kg-card-begin: markdown--><pre><code class=\"language-js\">// workers-site/index.js\n\nimport { getAssetFromKV } from &quot;@cloudflare/kv-asset-handler&quot;\n\naddEventListener(&quot;fetch&quot;, event =&gt; { \n  event.respondWith(handleEvent(event)) \n})\n\nclass EdgeStateEmbed {\n  constructor(state) {\n    this._state = state\n  }\n  \n  element(element) {\n    const edgeStateElement = `\n      &lt;script id='edge_state' type='application/json'&gt;\n        ${JSON.stringify(this._state)}\n      &lt;/script&gt;\n    `\n    element.prepend(edgeStateElement, { html: true })\n  }\n}\n\nconst hydrateEdgeState = async ({ state, response }) =&gt; {\n  const rewriter = new HTMLRewriter().on(\n    &quot;body&quot;,\n    new EdgeStateEmbed(await state)\n  )\n  return rewriter.transform(await response)\n}\n\nasync function handleEvent(event) {\n  return hydrateEdgeState({\n    response: getAssetFromKV(event, options),\n    // Get associated state for a request, based on the user and URL\n    state: transformBookmark(event.request),\n  })\n}\n</code></pre>\n<!--kg-card-end: markdown--><p>When the React application is rendered on the client, it can then check for that embedded edge state, which influences how the \"bookmark\" icon is rendered - either as \"bookmarked\", or \"bookmarked\". To support this, we've leaned on React's <code>useContext</code>, which allows any component inside of the application component tree to pull out the edge state and use it inside of the component:</p><!--kg-card-begin: markdown--><pre><code class=\"language-js\">// edge_state.js\n\nimport React from &quot;react&quot;\nimport { useSSR } from &quot;../utils&quot;\n\nconst parseDocumentState = () =&gt; {\n  const edgeStateElement = document.querySelector(&quot;#edge_state&quot;)\n  return edgeStateElement ? JSON.parse(edgeStateElement.innerText) : {}\n}\n\nexport const EdgeStateContext = React.createContext([{}, () =&gt; {}])\nexport const EdgeStateProvider = ({ children }) =&gt; {\n  const { isBrowser } = useSSR()\n  if (!isBrowser) {\n    return &lt;&gt;{children}&lt;/&gt;\n  }\n  \n  const edgeState = parseDocumentState()\n  const [state, setState] = React.useState(edgeState)\n  const updateState = (newState, options = { immutable: true }) =&gt; options.immutable\n    ? setState(Object.assign({}, state, newState))\n    : setState(newState)\n  \n  return (\n    &lt;EdgeStateContext.Provider value={[state, updateState]}&gt;\n      {children}\n    &lt;/EdgeStateContext.Provider&gt;\n  )\n}\n\n// Inside of a React component\nconst Bookmark = ({ bookmarked, project, setBookmarked, setLoaded }) =&gt; {\nconst [state, setState] = React.useContext(EdgeStateContext)\n// `bookmarked` value is a simplification of actual code\nreturn &lt;BookmarkButton bookmarked={state[project.id]} /&gt;\n}\n</code></pre>\n<!--kg-card-end: markdown--><p>The combination of a straightforward JAMstack deployment platform with dynamic key-value object storage and a streaming HTML rewriter is really, really cool. This is an initial exploration into what I consider to be <em>a platform-defining feature</em>, and if you're interested in this stuff and want to continue to explore how this will influence how we write web applications, <a href=\"https://twitter.com/signalnerve\">get in touch with me on Twitter</a>!</p><h2 id=\"the-cdn-is-the-deployment-platform\">The CDN is the deployment platform</h2><p>While it doesn't appear in the acronym, an unsung hero of the JAMstack architecture is <strong>deployment</strong>. In my local terminal, when I run <code>gatsby build</code> inside of the Built with Workers project, the result is a folder of static HTML, CSS, and JavaScript. <em>It should be easy to deploy!</em> </p><p>The recent release of <a href=\"https://github.com/features/actions\">GitHub Actions</a> has proven to be a great companion to building JAMstack applications with Cloudflare Workers – we've open-sourced our own <a href=\"https://github.com/cloudflare/wrangler-action\">wrangler-action</a>, which allows developers to build their Workers applications and deploy directly from GitHub.</p><p>The standard workflows in the continuous deployment world – deploy every hour, deploy on new changes to the <code>master</code> branch, etc – are possible and already being used by many developers who make use of our <code>wrangler-action</code> workflow in their projects. Particular to JAMstack and to headless CMS tools is the idea of \"build-on-change\": namely, when someone publishes a change in Sanity.io, we want to do a new deploy of the site to immediately reflect our new content in production.</p><p>The versatility of Workers as a place to deploy JavaScript code comes to the rescue, again! By telling Sanity.io to make a GET request to a deployed Workers webhook, we can trigger a <code>repository_event</code> on GitHub Actions for our repository, allowing new deploys to happen immediately after a change is detected in the CMS:</p><!--kg-card-begin: markdown--><pre><code class=\"language-js\">const headers = {\n  Accept: 'application/vnd.github.everest-preview+json',\n  Authorization: 'Bearer $token',\n}\n\nconst body = JSON.stringify({ event_type: 'repository_dispatch' })\n\nconst url = `https://api.github.com/repos/cloudflare/built-with-workers/dispatches`\n\nconst handleRequest = async evt =&gt; {\n  await fetch(url, { method: 'POST', headers, body })\n  return new Response('OK')\n}\n\naddEventListener('fetch', handleRequest)\n</code></pre>\n<!--kg-card-end: markdown--><p>In doing this, we've made it possible to completely abstract away <em>every</em> deployment task around the Built with Workers project. Not only does the site deploy on a schedule, and on new commits to <code>master</code>, but it can also do additional deploys as the content changes, so that the site is always reflective of the current content in our CMS.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"http://blog.cloudflare.com/content/images/2020/01/i6sG6fa_qL9h3uHrSQWI5adnC41xFKaS3vwBIKqk_WqqjSzQ_qZhT5VGnMo8DTMyfyqc8YiPUgTiw77EzopT9cyVWUn1HSrVxsFbKCPHkI-MVtbzTxLJZH8KbYrwpTGju8YpMuj_.png\" class=\"kg-image\" alt loading=\"lazy\"><figcaption>The GitHub Actions deployment workflow for Built with Workers</figcaption></figure><h2 id=\"conclusion\">Conclusion</h2><p>We're <strong>super</strong> excited about Built with Workers, not only because it will serve as a great place to showcase the incredible things people are building with the Cloudflare Workers platform, but because it also has allowed us to explore what the future of web development may look like. I've been advocating for what I've seen referred to as <a href=\"https://www.bytesized.xyz/full-stack-serverless\">\"full-stack serverless\"</a> development throughout 2019, and I couldn't be happier to start 2020 with launching a project like Built with Workers. The full-stack serverless stack feels like the future, and it's actually fun to build with on a daily basis!</p><p>If you're building something awesome with Cloudflare Workers, we're looking for submissions to the site! Get in touch with us via <a href=\"https://forms.gle/k6fZaXJbrUygvZhp6\">this form</a> – we're excited to speak with you! </p><p>Finally, if topics like JAMstack on Cloudflare Workers, \"edge state\" and dynamic static site hydration, or continuous deployment interest you, the Built with Workers repository is open-source! <a href=\"https://github.com/cloudflare/built-with-workers\">Check it out</a>, and if you're inspired to build something cool with Workers after checking out the code, make sure to let us know!</p>",
		"comment_id": "5e3098e755638b02a594af21",
		"feature_image": "http://blog.cloudflare.com/content/images/2020/01/Cloudflare-Blog_Built-with-Workers_28JAN2020.png",
		"featured": false,
		"visibility": "public",
		"created_at": "2020-01-28T20:26:15.000+00:00",
		"updated_at": "2024-02-15T22:59:27.000+00:00",
		"published_at": "2020-01-29T13:00:00.000+00:00",
		"custom_excerpt": "I'm extremely stoked to announce Built with Workers today – it's an awesome resource for exploring what you can build with Cloudflare Workers. As Adam explained in our launch post, showcasing developers building incredible projects with tools like Workers KV ",
		"codeinjection_head": null,
		"codeinjection_foot": null,
		"custom_template": null,
		"canonical_url": null,
		"authors": [
			{
				"id": "5d1644b141acde0011a95020",
				"name": "Kristian Freeman",
				"slug": "kristian",
				"profile_image": "http://blog.cloudflare.com/content/images/2019/05/2fGb07-c_400x400.jpg",
				"cover_image": "http://blog.cloudflare.com/content/images/2019/05/general@2x-13.png",
				"bio": "Manager, Developer Advocacy team at Cloudflare. We help developers build amazing apps on Cloudflare, with tools like Workers, Pages, and more!",
				"website": "https://www.signalnerve.com",
				"location": "Austin, TX",
				"facebook": null,
				"twitter": "@kristianf_",
				"meta_title": null,
				"meta_description": null,
				"url": "http://blog.cloudflare.com/author/kristian/"
			}
		],
		"tags": [
			{
				"id": "5d16450341acde0011a95253",
				"name": "Cloudflare Workers",
				"slug": "workers",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/workers/"
			},
			{
				"id": "5d16450341acde0011a95165",
				"name": "JavaScript",
				"slug": "javascript",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/javascript/"
			},
			{
				"id": "5dde58f61dd47a0536aa8453",
				"name": "JAMstack",
				"slug": "jamstack",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/jamstack/"
			},
			{
				"id": "5d16450341acde0011a95252",
				"name": "Serverless",
				"slug": "serverless",
				"description": null,
				"feature_image": "http://blog.cloudflare.com/content/images/2020/10/Serverless.png",
				"visibility": "public",
				"meta_title": "Cloudflare Blog: Serverless",
				"meta_description": "Cloudflare blog posts tagged 'serverless'.",
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/serverless/"
			},
			{
				"id": "5d16450341acde0011a95204",
				"name": "Developers",
				"slug": "developers",
				"description": null,
				"feature_image": "http://blog.cloudflare.com/content/images/2020/10/Developers-1.png",
				"visibility": "public",
				"meta_title": "Cloudflare Blog: Developers",
				"meta_description": "Collection of Cloudflare blog posts tagged 'Developers'.",
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/developers/"
			},
			{
				"id": "64a3e2b834124c000b00b717",
				"name": "Developer Platform",
				"slug": "developer-platform",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/developer-platform/"
			}
		],
		"primary_author": {
			"id": "5d1644b141acde0011a95020",
			"name": "Kristian Freeman",
			"slug": "kristian",
			"profile_image": "http://blog.cloudflare.com/content/images/2019/05/2fGb07-c_400x400.jpg",
			"cover_image": "http://blog.cloudflare.com/content/images/2019/05/general@2x-13.png",
			"bio": "Manager, Developer Advocacy team at Cloudflare. We help developers build amazing apps on Cloudflare, with tools like Workers, Pages, and more!",
			"website": "https://www.signalnerve.com",
			"location": "Austin, TX",
			"facebook": null,
			"twitter": "@kristianf_",
			"meta_title": null,
			"meta_description": null,
			"url": "http://blog.cloudflare.com/author/kristian/"
		},
		"primary_tag": {
			"id": "5d16450341acde0011a95253",
			"name": "Cloudflare Workers",
			"slug": "workers",
			"description": null,
			"feature_image": null,
			"visibility": "public",
			"meta_title": null,
			"meta_description": null,
			"og_image": null,
			"og_title": null,
			"og_description": null,
			"twitter_image": null,
			"twitter_title": null,
			"twitter_description": null,
			"codeinjection_head": null,
			"codeinjection_foot": null,
			"canonical_url": null,
			"accent_color": null,
			"url": "http://blog.cloudflare.com/tag/workers/"
		},
		"url": "http://blog.cloudflare.com/jamstack-at-the-edge-how-we-built-built-with-workers-on-workers/",
		"excerpt": "I'm extremely stoked to announce Built with Workers today – it's an awesome resource for exploring what you can build with Cloudflare Workers. As Adam explained in our launch post, showcasing developers building incredible projects with tools like Workers KV ",
		"reading_time": 17,
		"access": true,
		"comments": false,
		"og_image": "https://blog-cloudflare-com-assets.storage.googleapis.com/2020/01/Cloudflare-Blog_Built-with-Workers_28JAN2020-2.png",
		"og_title": null,
		"og_description": "We're showcasing developers building incredible projects with tools like Workers KV or our streaming HTML rewriter.",
		"twitter_image": "https://blog-cloudflare-com-assets.storage.googleapis.com/2020/01/Cloudflare-Blog_Built-with-Workers_28JAN2020-1.png",
		"twitter_title": null,
		"twitter_description": "We're showcasing developers building incredible projects with tools like Workers KV or our streaming HTML rewriter.",
		"meta_title": null,
		"meta_description": null,
		"email_subject": null,
		"frontmatter": null,
		"feature_image_alt": null,
		"feature_image_caption": null
	},
	"locale": "en-us"
}