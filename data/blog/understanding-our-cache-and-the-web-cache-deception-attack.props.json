{
	"locale": "en-us",
	"post": {
		"id": "5d16453b41acde0011a9560b",
		"uuid": "44989a5f-7bf7-4bb0-b002-d945015899d5",
		"title": "Understanding Our Cache and the Web Cache Deception Attack",
		"slug": "understanding-our-cache-and-the-web-cache-deception-attack",
		"html": "<!--kg-card-begin: markdown--><p>About a month ago, security researcher <a href=\"https://twitter.com/omer_gil\">Omer Gil</a> published <a href=\"https://omergil.blogspot.co.il/2017/02/web-cache-deception-attack.html\">the details</a> of an attack that he calls the Web Cache Deception attack. It works against sites that sit behind a reverse proxy (like Cloudflare) and are misconfigured in a particular way. Unfortunately, the definition of &quot;misconfigured&quot; for the purposes of this attack changes depending on how the cache works. In this post, we're going to explain the attack and then describe the algorithm that our cache uses to decide whether or not to cache a given piece of content so that customers can be sure that they are secure against this attack.</p>\n<h3 id=\"theattack\">The Attack</h3>\n<p>First, we'll explain the basics of the Web Cache Deception attack. For those who want a more in-depth explanation, Omer's <a href=\"https://omergil.blogspot.co.il/2017/02/web-cache-deception-attack.html\">original post</a> is a great resource.</p>\n<p><img src=\"http://blog.cloudflare.com/content/images/2017/04/one-way.jpg\" alt=\"\" loading=\"lazy\"><center><small>CC <a href=\"https://creativecommons.org/licenses/by-sa/2.0/\">BY-SA 2.0</a> - <a href=\"https://www.flickr.com/photos/shelleygibb/2700437267/in/photolist-57CrVe-i4jqNw-gmjSdW-b4eUjD-gmk8in-cFq3pN-2uVYE-2juSjD-d7gDoh-7ac96c-ytw77e-6k2Mw-9NnUjX-6oC4tp-9wFsmg-dsd8bt-bDTPG3-co2zqU-jFdVgc-5DHRZA-66H4P6-7jaCZF-848i8G-9aUjGk-bWVLYW-aCJNHD-buaVVA-nGA4V-soHrms-9quZAv-6MsSqe-nBG2bz-dsd7HT-d7gyTS-9kCfi-4F5xjK-cYYz9N-fFUYF-fQuqJw-dQZTkX-cNMqMJ-qrNmAB-aCJPui-dQXj68-87UrJH-phtpFE-997rCh-oA1ezU-nwpSdp-kswDL6/\">image</a> by <a href=\"https://www.flickr.com/photos/shelleygibb/\">shelleygibb</a></small></center></p>\n<p>Imagine that you run the social media website <code>example.com</code>, and that each of your users has a newsfeed at <code>example.com/newsfeed</code>. When a user navigates to their newsfeed, the HTTP request generated by their browser might look something like this:</p>\n<pre><code>GET /newsfeed HTTP/1.1\nHost: example.com\n...\n</code></pre>\n<p>If you use Cloudflare, you don't want us to cache this request because if we did, some of your users might start seeing other users' newsfeeds instead of their own, which would be very bad. Luckily, as we'll explain below, this request won't be cached because the path in the request (the <code>/newsfeed</code> part) doesn't have a &quot;cacheable file extension&quot; (a file extension such as <code>.jpg</code> or <code>.css</code> that instructs Cloudflare that it's OK to cache the request).</p>\n<p>The trouble begins if your website is configured to be flexible about what kinds of paths it can handle. In particular, the issue arises when requests to a path that doesn't exist (say, <code>/x/y/z</code>) are treated as equivalent to requests to a parent path that <em>does</em> exist (say, <code>/x</code>). For example, what happens if you get a request for the nonexistent path <code>/newsfeed/foo</code>? Depending on how your website is configured, it might just treat such a request as equivalent to a request to <code>/newsfeed</code>. For example, if you're running the <a href=\"https://docs.djangoproject.com/en/1.10/topics/http/urls/\">Django web framework</a>, the following configuration would do just that because the regular expression <code>^newsfeed/</code> matches both <code>newsfeed/</code> and <code>newsfeed/foo</code> (Django routes omit the leading <code>/</code>):</p>\n<pre><code>from django.conf.urls import url\n\npatterns = [url(r'^newsfeed/', ...)]\n</code></pre>\n<p>And here's where the problem lies. If your website does this, then a request to <code>/newsfeed/foo.jpg</code> will be treated as the same as a request to <code>/newsfeed</code>. But Cloudflare, seeing the <code>.jpg</code> file extension, will think that it's OK to cache this request.</p>\n<p>Now, you might be thinking, &quot;So what? My website never has any links to <code>/newsfeed/foo.jpg</code> or anything like that.&quot; That's true, but that doesn't stop <em>other</em> people from trying to convince your users to visit paths like that. For example, an attacker could send this message to somebody:<br>\n<br></p>\n<blockquote>\n<p>Hey, check out this cool link! <a href=\"https://example.com/newsfeed/foo.jpg\">https://example.com/newsfeed/foo.jpg</a></p>\n</blockquote>\n<br>\nIf the recipient of the message clicks on the link, they will be taken to their newsfeed. But when the request passes through Cloudflare, since the path ends in `.jpg`, we will cache it. Then the attacker can visit the same URL themselves and their request will be served from our cache, exposing your user's sensitive content.<br><br>\n<h3 id=\"defendingagainstthewebcachedeceptionattack\">Defending Against the Web Cache Deception Attack</h3>\n<p>The best way to defend against this attack is to ensure that your website isn't so permissive, and never treats requests to nonexistent paths (say, <code>/x/y/z</code>) as equivalent to requests to valid parent paths (say, <code>/x</code>). In the example above, that would mean that requests to <code>/newsfeed/foo</code> or <code>/newsfeed/foo.jpg</code> wouldn't be treated as equivalent to requests to <code>/newsfeed</code>, but would instead result in some kind of error or a redirect to a legitimate page. If we wanted to modify the Django example from above, we could add a <code>$</code> to the end of the regular expression to ensure only exact matches (in this case, a request to <code>/newsfeed/foo</code> will <a href=\"https://docs.djangoproject.com/en/1.10/topics/http/urls/#error-handling\">result in a 404</a>):</p>\n<p><img src=\"http://blog.cloudflare.com/content/images/2018/01/Screen-Shot-2018-01-19-at-10.23.10-AM.png\" alt=\"Screen-Shot-2018-01-19-at-10.23.10-AM\" loading=\"lazy\"></p>\n<p>We provide many settings that allow you to customize the way our cache will treat requests to your website. For example, if you have a Page Rule enabled for <code>/newsfeed</code> with the Cache Everything setting enabled (it's off by default), then we'll cache requests to <code>/newsfeed</code>, which could be bad. Thus, the best way to ensure that your website is secure is to understand the rules that our cache uses to determine whether or not a request should be cached.</p>\n<h3 id=\"howourcacheworks\">How Our Cache Works</h3>\n<p>When a request comes in to our network, we perform two phases of processing in order to determine whether or not to cache the origin's response to that request:</p>\n<ul>\n<li>In the <em>eligibility phase</em>, which is performed when a request first reaches our edge, we inspect the request to determine whether it should be eligible for caching. If we determine that it is not eligible, then we will not cache it. If we determine that it is eligible, then we proceed to a second disqualification phase.</li>\n<li>In the <em>disqualification phase</em>, which is performed after we've received a response from the origin web server, we inspect the response to determine whether any characteristics disqualify the response from being cached. If nothing disqualifies it, then the response will be cached.</li>\n</ul>\n<p><img src=\"http://blog.cloudflare.com/content/images/2017/04/page-rule-modal.png\" alt=\"\" loading=\"lazy\"></p>\n<center>_Configuring caching via a Page Rule_</center>\n<p>Note that site-wide settings or Page Rules can affect this logic. Below, when we say &quot;a setting applies&quot; or &quot;the setting is,&quot; we mean that either a global setting exists which applies to all requests or a Page Rule with the setting exists that applies to the given request (e.g., a Page Rule for <code>/foo/* </code>applies to requests to <code>/foo/bar</code>, <code>/foo/baz</code>, <code>/foo/bar/baz</code>, etc). Page Rules override global rules if both apply to a given request.</p>\n<h3 id=\"eligibilityphase\">Eligibility Phase</h3>\n<p>In the <em>eligibility phase</em>, we use characteristics of the request from the client to determine whether or not the request is eligible to be cached. If the request is not eligible, then it will not be cached. If the request is eligible, then we will perform more processing later in the disqualification phase.</p>\n<p>The rules for eligibility are as follows:</p>\n<ul>\n<li>If the setting is Standard, Ignore Query String, or No Query String, then:\n<ul>\n<li>a request is eligible to be cached if the requested path ends in one of the file extensions listed in Figure 1 below</li>\n<li>a request <em>may</em> be eligible to be cached (depending on performance-related decisions made by our edge) if the requested path ends in one of the file extensions listed in Figure 2 below</li>\n<li>a request is eligible to be cached if the request path is <code>/robots.txt</code></li>\n</ul>\n</li>\n<li>If the setting is Cache Everything, then all requests are eligible to be cached.</li>\n</ul>\n<p>In addition to the above rules, if either of the following two conditions hold, then any decision made so far about eligibility will be overridden, and the request will not be eligible to be cached:</p>\n<ul>\n<li>If the Cache on Cookie setting is enabled and the configured cookie is <em>not</em> present in a <code>Cookie</code> header, then the request is not eligible to be cached.</li>\n<li>If the Bypass Cache on Cookie setting is enabled and the configured cookie <em>is</em> present in a <code>Cookie</code> header, then the request is not eligible to be cached.</li>\n</ul>\n<h3 id=\"disqualificationphase\">Disqualification Phase</h3>\n<p>In the <em>disqualification phase</em>, which only occurs if a request has been marked as eligible, characteristics of the response from the origin web server can disqualify a request. If a request is disqualified, then the response will not be cached. If a request is not disqualified, then the response will be cached.</p>\n<p>The rules for disqualification are as follows:</p>\n<ul>\n<li>If the setting is Standard, Ignore Query String, or No Query String, or if the setting is Cache Everything <em>and</em> no Edge Cache TTL is present, then:\n<ul>\n<li>A <code>Cache-Control</code> header in the response from the origin with any of the following values will disqualify a request, causing it not to be cached:\n<ul>\n<li><code>no-cache</code></li>\n<li><code>max-age=0</code></li>\n<li><code>private</code></li>\n<li><code>no-store</code></li>\n</ul>\n</li>\n<li>An <code>Expires</code> header in the response from the origin indicating any time in the past will disqualify a request, causing it not to be cached.</li>\n</ul>\n</li>\n<li>If the setting is Cache Everything and an Edge Cache TTL <em>is</em> present, then a request will never be disqualified under any circumstances, and will always be cached.</li>\n</ul>\n<p>There is one further set of rules relating to the <code>Set-Cookie</code> header. The following rules only apply if a <code>Set-Cookie</code> header is present:</p>\n<ul>\n<li>If the setting is Standard, Ignore Query String, or No Query String, or if the setting is Cache Everything and an Edge Cache TTL is present, then the request will not be disqualified, but the <code>Set-Cookie</code> header will be stripped from the version of the response stored in our cache.</li>\n<li>If the setting is Cache Everything and no Edge Cache TTL is present, then the request will be disqualified, and it will not be cached. The <code>Set-Cookie</code> header will be stripped from the response that is sent to the client making the request.</li>\n</ul>\n<pre><code>class\ncss\njar\njs\njpg\njpeg\ngif\nico\npng\nbmp\npict\ncsv\ndoc\ndocx\nxls\nxlsx\nps\npdf\npls\nppt\npptx\ntif\ntiff\nttf\notf\nwebp\nwoff\nwoff2\nsvg\nsvgz\neot\neps\nejs\nswf\ntorrent\nmidi\nmid\n</code></pre>\n<center>_Figure 1: Always Cacheable File Extensions_</center>\n<pre><code>mp3\nmp4\nmp4v\nmpg\nmpeg\nmov\nmkv\nflv\nwebm\nwmv\navi\nogg\nm4a\nwav\naac\nogv\nzip\nsit\ntar\n7z\nrar\nrpm\ndeb\ndmg\niso\nimg\nmsi\nmsp\nmsm\nbin\nexe\ndll\nra\nmka\nts\nm4v\nasf\nmk3d\nrm\nswf\n</code></pre>\n<center>_Figure 2: Sometimes Cacheable File Extensions_</center>\n<br>\nSo there you have it. So long as you make sure to follow the advice above, and make sure that your site plays nicely with our cache, you should be secure against the Web Cache Deception attack.\n<!--kg-card-end: markdown-->",
		"comment_id": "4938",
		"feature_image": "http://blog.cloudflare.com/content/images/2018/01/one-way.jpg",
		"featured": false,
		"visibility": "public",
		"created_at": "2017-04-13T00:54:53.000+01:00",
		"updated_at": "2024-02-20T17:23:11.000+00:00",
		"published_at": "2017-04-14T16:00:00.000+01:00",
		"custom_excerpt": "About a month ago, security researcher Omer Gil published the details of an attack that he calls the Web Cache Deception attack. It works against sites that sit behind a reverse proxy (like Cloudflare) and are misconfigured in a particular way.",
		"codeinjection_head": null,
		"codeinjection_foot": null,
		"custom_template": null,
		"canonical_url": null,
		"authors": [
			{
				"id": "5d1644b141acde0011a94f8c",
				"name": "Joshua Liebow-Feeser",
				"slug": "joshlf",
				"profile_image": "http://blog.cloudflare.com/content/images/2017/04/1046063-1.jpg",
				"cover_image": "http://blog.cloudflare.com/content/images/2019/05/general@2x-16.png",
				"bio": null,
				"website": null,
				"location": null,
				"facebook": null,
				"twitter": null,
				"meta_title": null,
				"meta_description": null,
				"url": "http://blog.cloudflare.com/author/joshlf/"
			}
		],
		"tags": [
			{
				"id": "5d16450341acde0011a951c1",
				"name": "Page Rules",
				"slug": "page-rules",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/page-rules/"
			},
			{
				"id": "5d16450341acde0011a95169",
				"name": "Attacks",
				"slug": "attacks",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/attacks/"
			},
			{
				"id": "5d16450341acde0011a95265",
				"name": "Security",
				"slug": "security",
				"description": null,
				"feature_image": "http://blog.cloudflare.com/content/images/2020/10/Security.png",
				"visibility": "public",
				"meta_title": "Cloudflare Blog: Security",
				"meta_description": "Collection of Cloudflare blog posts tagged 'Security'.",
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/security/"
			},
			{
				"id": "5d16450341acde0011a951ce",
				"name": "Reliability",
				"slug": "reliability",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/reliability/"
			},
			{
				"id": "5d16450341acde0011a95221",
				"name": "Best Practices",
				"slug": "best-practices",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/best-practices/"
			},
			{
				"id": "5d16450341acde0011a95157",
				"name": "Cache",
				"slug": "cache",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/cache/"
			},
			{
				"id": "5d16450341acde0011a95160",
				"name": "Speed & Reliability",
				"slug": "speed-and-reliability",
				"description": null,
				"feature_image": "http://blog.cloudflare.com/content/images/2020/10/Speed---Reliability-1.png",
				"visibility": "public",
				"meta_title": "Cloudflare Blog: Speed & Reliability",
				"meta_description": "Collection of Cloudflare blog posts tagged 'Speed & Reliability'.",
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/speed-and-reliability/"
			}
		],
		"primary_author": {
			"id": "5d1644b141acde0011a94f8c",
			"name": "Joshua Liebow-Feeser",
			"slug": "joshlf",
			"profile_image": "http://blog.cloudflare.com/content/images/2017/04/1046063-1.jpg",
			"cover_image": "http://blog.cloudflare.com/content/images/2019/05/general@2x-16.png",
			"bio": null,
			"website": null,
			"location": null,
			"facebook": null,
			"twitter": null,
			"meta_title": null,
			"meta_description": null,
			"url": "http://blog.cloudflare.com/author/joshlf/"
		},
		"primary_tag": {
			"id": "5d16450341acde0011a951c1",
			"name": "Page Rules",
			"slug": "page-rules",
			"description": null,
			"feature_image": null,
			"visibility": "public",
			"meta_title": null,
			"meta_description": null,
			"og_image": null,
			"og_title": null,
			"og_description": null,
			"twitter_image": null,
			"twitter_title": null,
			"twitter_description": null,
			"codeinjection_head": null,
			"codeinjection_foot": null,
			"canonical_url": null,
			"accent_color": null,
			"url": "http://blog.cloudflare.com/tag/page-rules/"
		},
		"url": "http://blog.cloudflare.com/understanding-our-cache-and-the-web-cache-deception-attack/",
		"excerpt": "About a month ago, security researcher Omer Gil published the details of an attack that he calls the Web Cache Deception attack. It works against sites that sit behind a reverse proxy (like Cloudflare) and are misconfigured in a particular way.",
		"reading_time": 7,
		"access": true,
		"comments": false,
		"og_image": null,
		"og_title": null,
		"og_description": null,
		"twitter_image": null,
		"twitter_title": null,
		"twitter_description": null,
		"meta_title": null,
		"meta_description": null,
		"email_subject": null,
		"frontmatter": null,
		"feature_image_alt": null,
		"feature_image_caption": null
	}
}