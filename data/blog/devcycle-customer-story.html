<div class="mb2 gray5">6 min read</div>
<div class="post-content lh-copy gray1">
	<figure class="kg-card kg-image-card"><img src="https://blog.cloudflare.com/content/images/2022/11/image3-15.png" class="kg-image" alt="Cloudflare Workers scale too well and broke our infrastructure, so we are rebuilding it on Workers" loading="lazy"></figure>
	<p>While scaling our new Feature Flagging product <a href="https://devcycle.com">DevCycle</a>, weâ€™ve encountered an interesting challenge: our Cloudflare Workers-based infrastructure can handle way more instantaneous load than our traditional AWS infrastructure. This led us to rethink how we design our infrastructure to always use Cloudflare Workers for everything.</p>
	<h3 id="the-origin-of-devcycle">The origin of DevCycle</h3>
	<p>For almost 10 years, Taplytics has been a leading provider of no-code A/B testing and feature flagging solutions for product and marketing teams across a wide range of use cases for some of the largest consumer-facing companies in the world. So when we applied ourselves to build a new engineering-focused feature management product, DevCycle, we built upon our experience using Workers which have served over 140 billion requests for Taplytics customers.</p>
	<p>The inspiration behind DevCycle is to build a focused feature management tool for engineering teams, empowering them to build their software more efficiently and deploy it faster. Helping engineering teams reach their goals, whether it be continuous deployment, lower change failure rate, or a faster recovery time. DevCycle is the culmination of our vision of how teams should use Feature Management to build high-quality software faster. We've used DevCycle to <em>build</em> DevCycle, enabling us to implement continuous deployment successfully.</p>
	<h3 id="devcycle-architecture">DevCycle architecture</h3>
	<p>One of the first things we asked ourselves when ideating DevCycle was how we could get out of the business of managing 1000â€™s of vCPUs worth of AWS instances and move our core business logic closer to our end-user devices. Based on our experience with Cloudflare Workers at Taplytics we knew we wanted it to be a core part of our future infrastructure for DevCycle.</p>
	<p>By using the global computing power of Workers and moving as much logic to the SDKs as possible with our local bucketing server-side SDKs, we were able to massively reduce or eliminate the latency of fetching feature flag configurations for our users. In addition, we used a shared WASM library across our Workers and local bucketing SDKs to dramatically reduce the amount of code we need to maintain per SDK, and increase the consistency of our platform. This architecture has also fundamentally changed our business's cost structure to easily serve any customer of any scale.</p>
	<p>The core architecture of DevCycle revolves around publishing and consuming JSON configuration files per project environment. The publishing side is managed in our AWS services, while Cloudflare manages the consumption of these config files at scale. This split in responsibilities allows for all high-scale requests to be managed by Cloudflare, while keeping our AWS services simple and low-scale.</p>
	<figure class="kg-card kg-image-card"><img src="https://blog.cloudflare.com/content/images/2022/11/image1-22.png" class="kg-image" alt="" loading="lazy"></figure>
	<h3 id="-workers-are-breaking-our-events-pipeline-">â€œWorkers are breaking our events pipelineâ€</h3>
	<p>One of the primary challenges as a feature management platform is that we donâ€™t have direct control over the load from our customersâ€™ applications using our SDKs; our systems need the ability to scale instantly to match their load. For example, we have a couple of large customers whose mobile traffic is primarily driven by push notifications, which causes massive instantaneous spikes in traffic to our APIs in the range of 10x increases in load. As you can imagine, any traditional auto-scaled API service and the load balancer cannot manage that type of increase in load. Thus, our choices are to dramatically increase the minimum size of our cluster and load balancer to handle these unknown load spikes, accept that some requests will be rate-limited, or move to an architecture that can handle this load.</p>
	<figure class="kg-card kg-image-card"><img src="https://blog.cloudflare.com/content/images/2022/11/image4-10.png" class="kg-image" alt="" loading="lazy"></figure>
	<p>Given that all our SDK API requests are already served with Workers, they have no problem scaling instantly to 10x+ their base load. Sadly we canâ€™t say the same about the traditional parts of our infrastructure.</p>
	<p>For each feature flag configuration request to a Worker, a corresponding events request is sent to our AWS events infrastructure. The events are received by our events API container in Kubernetes, where they are then published to Kafka and eventually ingested by Snowflake. While Cloudflare Workers have no problem handling instantaneous spikes in feature flag requests, the events system can't keep up. Our cluster and events API containers need to be scaled up faster to prevent the existing instances from being overwhelmed. Even the load balancer has issues accepting the sudden increase. Cloudflare Workers just work too well in comparison to EC2 instances + EKS.</p>
	<p>To solve this issue we are moving towards a new events Cloudflare Worker which will be able to handle the instantaneous events load from these requests and make use of the Kinesis Data Firehose to write events to our existing S3 bucket which is ingested by Snowflake. In the future, we look forward to testing out Cloudflare Queues writing to R2 once a Snowflake connector has been created. This architecture should allow us to ingest events at almost any scale and withstand instantaneous traffic spikes with a predictable and efficient cost structure.</p>
	<figure class="kg-card kg-image-card"><img src="https://blog.cloudflare.com/content/images/2022/11/image2-21.png" class="kg-image" alt="" loading="lazy"></figure>
	<h3 id="building-without-a-database-next-to-your-code">Building without a database next to your code</h3>
	<p>Workers provide many benefits, including fast response times, infinite scalability, serverless architecture, and excellent up-time performance. However, if you want to see all these benefits, you need to architect your Workers to assume that you donâ€™t have direct access to a centralized SQL / NoSQL database (or <a href="https://blog.cloudflare.com/whats-new-with-d1">D1</a>) like you would with a traditional API service. For example, suppose you build your workers to require reaching out to a database to fetch and update user data every time a request is made to your Workers. In that case, your request latency will be tied to the geographic distance between your Worker and the database plus the latency of the database. In addition, your Workers will be able to scale significantly beyond the number of database connections you can support, and your uptime will be tied to the uptime of your external database. Therefore, when architecting your systems to use Workers, we advise relying primarily on data sent as part of the API request and cacheable data on Cloudflareâ€™s global network.</p>
	<p>Cloudflare provides multiple products and services to help with data on their global network:</p><!--kg-card-begin: markdown-->
	<ul>
		<li><a href="https://developers.cloudflare.com/workers/learning/how-kv-works">KV</a>: â€œglobal, low-latency, key-value data store.â€
			<ul>
				<li>However, the lowest latency way of retrieving data from within a Worker is limited by a minimum 60-second TTL. So youâ€™ll need to be ok with cached data that is 60 seconds stale.</li>
			</ul>
		</li>
		<li><a href="https://developers.cloudflare.com/workers/learning/using-durable-objects/'">Durable Objects</a>: â€œprovide low-latency coordination and consistent storage for the Workers platform through two features: global uniqueness and a transactional storage API.â€
			<ul>
				<li>Ability to store user-level information closer to the end user.</li>
				<li>Unfamiliar worker interface for accessing data for developers with SQL / NoSQL experience.</li>
			</ul>
		</li>
		<li><a href="https://developers.cloudflare.com/r2/data-access/workers-api/workers-api-usage">R2</a>: â€œstore large amounts of unstructured data.â€
			<ul>
				<li>Ability to store arbitrarily large amounts of unstructured data using familiar S3 APIs.</li>
				<li>Cloudflareâ€™s cache can be used to provide low-latency access within workers.</li>
			</ul>
		</li>
		<li><a href="https://blog.cloudflare.com/introducing-d1">D1</a>: â€œserverless SQLite databaseâ€</li>
	</ul>
	<!--kg-card-end: markdown-->
	<p>Each of these tools that Cloudflare provides has made building APIs far more accessible than when Workers launched initially; however, each service has aspects which need to be accounted for when architecting your systems. Being an open platform, you can also access any publically available database you want from a Worker. For example, we are making use of <a href="https://www.macrometa.com/platform/global-data-mesh">Macrometa</a> for our <a href="https://devcycle.com/features/edge-flags">EdgeDB</a> product built into our Workers to help customers access their user data.</p>
	<h3 id="the-predictable-cost-structure-of-workers">The predictable cost structure of Workers</h3>
	<p>One of the greatest advantages of moving most of our workloads towards Cloudflare Workers is the predictable cost structure that can scale 1:1 with our request loads and can be easily mapped to usage-based billing for our customers. In addition, we no longer have to run excess EC2 instances to handle random spikes in load, just in case they happen.</p>
	<p>Too many SaaS services have opaque billing based on max usage or other metrics that donâ€™t relate directly to their costs. Moving from our legacy AWS architecture with high fixed costs like databases and caching layers to Workers has resulted in our infrastructure spending is directly tied to using our APIs and SDKs. For DevCycle, this architecture has been over ~5x more cost-efficient to operate.</p>
	<h3 id="the-future-of-devcycle-and-cloudflare">The future of DevCycle and Cloudflare</h3>
	<p>With DevCycle we will continue to invest in leveraging serverless computing and moving our core business logic as close to our users as possible, either on Cloudflareâ€™s global network or locally within our SDKs. Weâ€™re excited to integrate even more deeply with the Cloudflare developer platform as new services evolve. We already see future use cases for R2, Queues and Durable Objects and look forward to whatâ€™s coming next from Cloudflare.</p>
</div>