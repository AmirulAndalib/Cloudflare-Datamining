<div class="mb2 gray5">6 min read</div><img class="mr2" src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/3IUnaw1pw2LBCYW75IBVm7/00cbf720db23e2d565e597b40822d4ad/understanding-our-cache-and-the-web-cache-deception-attack.jpg" alt="">
<div class="post-content lh-copy gray1">
	<p>About a month ago, security researcher <a href="https://twitter.com/omer_gil">Omer Gil</a> published <a href="https://omergil.blogspot.co.il/2017/02/web-cache-deception-attack.html">the details</a> of an attack that he calls the Web Cache Deception attack. It works against sites that sit behind a reverse proxy (like Cloudflare) and are misconfigured in a particular way. Unfortunately, the definition of "misconfigured" for the purposes of this attack changes depending on how the cache works. In this post, we're going to explain the attack and then describe the algorithm that our cache uses to decide whether or not to cache a given piece of content so that customers can be sure that they are secure against this attack.</p>
	<div class="flex anchor relative">
		<h3 id="the-attack">The Attack</h3>
		<a href="https://blog.cloudflare.com/#the-attack" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>First, we'll explain the basics of the Web Cache Deception attack. For those who want a more in-depth explanation, Omer's <a href="https://omergil.blogspot.co.il/2017/02/web-cache-deception-attack.html">original post</a> is a great resource.</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/3Wy262IiC2ykqjHqHRbOwk/47d8332bbd458bfaa68f40a27763da21/one-way.jpg" alt="" class="kg-image" width="465" height="653" loading="lazy">

	</figure>
	<p>CC <a href="https://creativecommons.org/licenses/by-sa/2.0">BY-SA 2.0</a> - <a href="https://www.flickr.com/photos/shelleygibb/2700437267/in/photolist-57CrVe-i4jqNw-gmjSdW-b4eUjD-gmk8in-cFq3pN-2uVYE-2juSjD-d7gDoh-7ac96c-ytw77e-6k2Mw-9NnUjX-6oC4tp-9wFsmg-dsd8bt-bDTPG3-co2zqU-jFdVgc-5DHRZA-66H4P6-7jaCZF-848i8G-9aUjGk-bWVLYW-aCJNHD-buaVVA-nGA4V-soHrms-9quZAv-6MsSqe-nBG2bz-dsd7HT-d7gyTS-9kCfi-4F5xjK-cYYz9N-fFUYF-fQuqJw-dQZTkX-cNMqMJ-qrNmAB-aCJPui-dQXj68-87UrJH-phtpFE-997rCh-oA1ezU-nwpSdp-kswDL6">image</a> by <a href="https://www.flickr.com/photos/shelleygibb">shelleygibb</a></p>
	<p>Imagine that you run the social media website <code>example.com</code>, and that each of your users has a newsfeed at <code>example.com/newsfeed</code>. When a user navigates to their newsfeed, the HTTP request generated by their browser might look something like this:</p>
	<pre class="language-bash"><code class="language-bash">GET /newsfeed HTTP/1.1
Host: example.com
...</code></pre>
	<p>If you use Cloudflare, you don't want us to cache this request because if we did, some of your users might start seeing other users' newsfeeds instead of their own, which would be very bad. Luckily, as we'll explain below, this request won't be cached because the path in the request (the <code>/newsfeed</code> part) doesn't have a "cacheable file extension" (a file extension such as <code>.jpg</code> or <code>.css</code> that instructs Cloudflare that it's OK to cache the request).</p>
	<p>The trouble begins if your website is configured to be flexible about what kinds of paths it can handle. In particular, the issue arises when requests to a path that doesn't exist (say, <code>/x/y/z</code>) are treated as equivalent to requests to a parent path that <i>does</i> exist (say, <code>/x</code>). For example, what happens if you get a request for the nonexistent path <code>/newsfeed/foo</code>? Depending on how your website is configured, it might just treat such a request as equivalent to a request to <code>/newsfeed</code>. For example, if you're running the <a href="https://docs.djangoproject.com/en/1.10/topics/http/urls">Django web framework</a>, the following configuration would do just that because the regular expression <code>^newsfeed/</code> matches both <code>newsfeed/</code> and <code>newsfeed/foo</code> (Django routes omit the leading <code>/</code>):</p>
	<pre class="language-bash"><code class="language-bash">from django.conf.urls import url

patterns = [url(r'^newsfeed/', ...)]</code></pre>
	<p>And here's where the problem lies. If your website does this, then a request to <code>/newsfeed/foo.jpg</code> will be treated as the same as a request to <code>/newsfeed</code>. But Cloudflare, seeing the <code>.jpg</code> file extension, will think that it's OK to cache this request.</p>
	<p>Now, you might be thinking, "So what? My website never has any links to <code>/newsfeed/foo.jpg</code> or anything like that." That's true, but that doesn't stop <i>other</i> people from trying to convince your users to visit paths like that. For example, an attacker could send this message to somebody:</p>
	<blockquote>
		<p>Hey, check out this cool link! <a href="https://example.com/newsfeed/foo.jpg">https://example.com/newsfeed/foo.jpg</a></p>
	</blockquote>
	<p>If the recipient of the message clicks on the link, they will be taken to their newsfeed. But when the request passes through Cloudflare, since the path ends in `.jpg`, we will cache it. Then the attacker can visit the same URL themselves and their request will be served from our cache, exposing your user's sensitive content.</p>
	<div class="flex anchor relative">
		<h3 id="defending-against-the-web-cache-deception-attack">Defending Against the Web Cache Deception Attack</h3>
		<a href="https://blog.cloudflare.com/#defending-against-the-web-cache-deception-attack" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>The best way to defend against this attack is to ensure that your website isn't so permissive, and never treats requests to nonexistent paths (say, <code>/x/y/z</code>) as equivalent to requests to valid parent paths (say, <code>/x</code>). In the example above, that would mean that requests to <code>/newsfeed/foo</code> or <code>/newsfeed/foo.jpg</code> wouldn't be treated as equivalent to requests to <code>/newsfeed</code>, but would instead result in some kind of error or a redirect to a legitimate page. If we wanted to modify the Django example from above, we could add a <code>$</code> to the end of the regular expression to ensure only exact matches (in this case, a request to <code>/newsfeed/foo</code> will <a href="https://docs.djangoproject.com/en/1.10/topics/http/urls/#error-handling">result in a 404</a>):</p>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/EctCR6DDUYFIWG9EatWeC/52274b8a49ac7a8c7a9cb15921f9fe45/Screen-Shot-2018-01-19-at-10.23.10-AM.png" alt="Screen-Shot-2018-01-19-at-10.23.10-AM" class="kg-image" width="711" height="80" loading="lazy">

	</figure>
	<p>We provide many settings that allow you to customize the way our cache will treat requests to your website. For example, if you have a Page Rule enabled for <code>/newsfeed</code> with the Cache Everything setting enabled (it's off by default), then we'll cache requests to <code>/newsfeed</code>, which could be bad. Thus, the best way to ensure that your website is secure is to understand the rules that our cache uses to determine whether or not a request should be cached.</p>
	<div class="flex anchor relative">
		<h3 id="how-our-cache-works">How Our Cache Works</h3>
		<a href="https://blog.cloudflare.com/#how-our-cache-works" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>When a request comes in to our network, we perform two phases of processing in order to determine whether or not to cache the origin's response to that request:</p>
	<ul>
		<li>
			<p>In the <i>eligibility phase</i>, which is performed when a request first reaches our edge, we inspect the request to determine whether it should be eligible for caching. If we determine that it is not eligible, then we will not cache it. If we determine that it is eligible, then we proceed to a second disqualification phase.</p>
		</li>
		<li>
			<p>In the <i>disqualification phase</i>, which is performed after we've received a response from the origin web server, we inspect the response to determine whether any characteristics disqualify the response from being cached. If nothing disqualifies it, then the response will be cached.</p>
		</li>
	</ul>
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/2TLTgYd4yL4nBAkczqkQHn/7013cba8117f2dd83e68cd6eeddf8b29/page-rule-modal.png" alt="" class="kg-image" width="1600" height="918" loading="lazy">

	</figure>
	<p>_Configuring caching via a Page Rule_</p>
	<p>Note that site-wide settings or Page Rules can affect this logic. Below, when we say "a setting applies" or "the setting is," we mean that either a global setting exists which applies to all requests or a Page Rule with the setting exists that applies to the given request (e.g., a Page Rule for <code>/foo/*</code> applies to requests to <code>/foo/bar</code>, <code>/foo/baz</code>, <code>/foo/bar/baz</code>, etc). Page Rules override global rules if both apply to a given request.</p>
	<div class="flex anchor relative">
		<h3 id="eligibility-phase">Eligibility Phase</h3>
		<a href="https://blog.cloudflare.com/#eligibility-phase" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>In the <i>eligibility phase</i>, we use characteristics of the request from the client to determine whether or not the request is eligible to be cached. If the request is not eligible, then it will not be cached. If the request is eligible, then we will perform more processing later in the disqualification phase.</p>
	<p>The rules for eligibility are as follows:</p>
	<ul>
		<li>
			<p>If the setting is Standard, Ignore Query String, or No Query String, then:</p>
			<ul>
				<li>
					<p>a request is eligible to be cached if the requested path ends in one of the file extensions listed in Figure 1 below</p>
				</li>
				<li>
					<p>a request <i>may</i> be eligible to be cached (depending on performance-related decisions made by our edge) if the requested path ends in one of the file extensions listed in Figure 2 below</p>
				</li>
				<li>
					<p>a request is eligible to be cached if the request path is <code>/robots.txt</code></p>
				</li>
			</ul>
		</li>
		<li>
			<p>If the setting is Cache Everything, then all requests are eligible to be cached.</p>
		</li>
	</ul>
	<p>In addition to the above rules, if either of the following two conditions hold, then any decision made so far about eligibility will be overridden, and the request will not be eligible to be cached:</p>
	<ul>
		<li>
			<p>If the Cache on Cookie setting is enabled and the configured cookie is <i>not</i> present in a <code>Cookie</code> header, then the request is not eligible to be cached.</p>
		</li>
		<li>
			<p>If the Bypass Cache on Cookie setting is enabled and the configured cookie <i>is</i> present in a <code>Cookie</code> header, then the request is not eligible to be cached.</p>
		</li>
	</ul>
	<div class="flex anchor relative">
		<h3 id="disqualification-phase">Disqualification Phase</h3>
		<a href="https://blog.cloudflare.com/#disqualification-phase" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>In the <i>disqualification phase</i>, which only occurs if a request has been marked as eligible, characteristics of the response from the origin web server can disqualify a request. If a request is disqualified, then the response will not be cached. If a request is not disqualified, then the response will be cached.</p>
	<p>The rules for disqualification are as follows:</p>
	<ul>
		<li>
			<p>If the setting is Standard, Ignore Query String, or No Query String, or if the setting is Cache Everything <i>and</i> no Edge Cache TTL is present, then:</p>
			<ul>
				<li>
					<p>A <code>Cache-Control</code> header in the response from the origin with any of the following values will disqualify a request, causing it not to be cached:</p>
					<ul>
						<li>
							<p><code>no-cache</code></p>
						</li>
						<li>
							<p><code>max-age=0</code></p>
						</li>
						<li>
							<p><code>private</code></p>
						</li>
						<li>
							<p><code>no-store</code></p>
						</li>
					</ul>
				</li>
				<li>
					<p>An <code>Expires</code> header in the response from the origin indicating any time in the past will disqualify a request, causing it not to be cached.</p>
				</li>
			</ul>
		</li>
		<li>
			<p>If the setting is Cache Everything and an Edge Cache TTL <i>is</i> present, then a request will never be disqualified under any circumstances, and will always be cached.</p>
		</li>
	</ul>
	<p>There is one further set of rules relating to the <code>Set-Cookie</code> header. The following rules only apply if a <code>Set-Cookie</code> header is present:</p>
	<ul>
		<li>
			<p>If the setting is Standard, Ignore Query String, or No Query String, or if the setting is Cache Everything and an Edge Cache TTL is present, then the request will not be disqualified, but the <code>Set-Cookie</code> header will be stripped from the version of the response stored in our cache.</p>
		</li>
		<li>
			<p>If the setting is Cache Everything and no Edge Cache TTL is present, then the request will be disqualified, and it will not be cached. The <code>Set-Cookie</code> header will be stripped from the response that is sent to the client making the request.</p>
		</li>
	</ul>
	<pre class="language-bash"><code class="language-bash">class
css
jar
js
jpg
jpeg
gif
ico
png
bmp
pict
csv
doc
docx
xls
xlsx
ps
pdf
pls
ppt
pptx
tif
tiff
ttf
otf
webp
woff
woff2
svg
svgz
eot
eps
ejs
swf
torrent
midi
mid</code></pre>
	<p>_Figure 1: Always Cacheable File Extensions_</p>
	<pre class="language-bash"><code class="language-bash">mp3
mp4
mp4v
mpg
mpeg
mov
mkv
flv
webm
wmv
avi
ogg
m4a
wav
aac
ogv
zip
sit
tar
7z
rar
rpm
deb
dmg
iso
img
msi
msp
msm
bin
exe
dll
ra
mka
ts
m4v
asf
mk3d
rm
swf</code></pre>
	<p>_Figure 2: Sometimes Cacheable File Extensions_</p>
	<p>So there you have it. So long as you make sure to follow the advice above, and make sure that your site plays nicely with our cache, you should be secure against the Web Cache Deception attack.</p>
</div>