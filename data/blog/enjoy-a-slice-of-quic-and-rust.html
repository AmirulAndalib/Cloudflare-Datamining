<div class="mb2 gray5">4 min read</div>
<div class="post-content lh-copy gray1">
	<p>During last yearâ€™s Birthday Week we announced <a href="https://blog.cloudflare.com/head-start-with-quic">early support</a> for <a href="https://blog.cloudflare.com/the-road-to-quic">QUIC</a>, the next generation encrypted-by-default network transport protocol designed to secure and accelerate web traffic on the Internet.</p>
	<p>We are not quite ready to make this feature available to every Cloudflare customer yet, but while you wait we thought you might enjoy a slice of <a href="https://github.com/cloudflare/quiche">quiche</a>, our own open-source implementation of the QUIC protocol written in Rust.</p>
	<figure class="kg-card kg-image-card"><img src="https://blog.cloudflare.com/content/images/2019/01/quiche-1.png" class="kg-image" alt="quiche-1" loading="lazy"></figure>
	<p>Quiche will allow us to keep on top of changes to the QUIC protocol as the standardization process progresses and experiment with new features more easily. Letâ€™s have a quick look at it together.</p>
	<h3 id="simple-and-genuine-ingredients">Simple and genuine ingredients</h3>
	<p>The main design principle that guided quicheâ€™s initial development was exposing most of the QUIC complexity to applications through a minimal and intuitive API, but without making too many assumptions about the application itself, in order to allow us to reuse the same library in different contexts.</p>
	<p>For example, while we think Rust is great, most of the stack that deals with HTTP requests on Cloudflareâ€™s edge network is still written in good olâ€™ C, which means that our QUIC implementation would need to be integrated into that.</p>
	<p>The quiche API can process QUIC packets received from network sockets and generate packets to send back, but will not touch the sockets themselves. It also exposes <a href="https://github.com/cloudflare/quiche/blob/master/include/quiche.h">a thin layer</a> on top on the Rust API itself to make integration into C/C++ (and other languages) easier.</p>
	<p>The application is responsible for fetching data from the network (e.g. via sockets), passing it to quiche, and sending the data that quiche generates back into the network. The application also needs to handle timers, with quiche telling it when to wake-up (this is required for retransmitting lost packets once the corresponding retransmission timeouts expire for example). This leaves the application free to decide how to best implement the I/O and event loop support, depending on the support offered by the operating system or the networking framework used.</p>
	<p>Thanks to this we were able to integrate quiche into our NGINX fork (though this is not ready to be open-sourced just yet) without major changes to NGINX internals. Quiche can also be built <a href="https://github.com/curl/curl/pull/3314#issuecomment-455778313">together with cURL</a> to power cURLâ€™s very early (and very experimental) QUIC support. And of course you can use quiche to implement QUIC <a href="https://github.com/cloudflare/quiche/blob/master/examples/client.rs">clients</a> and <a href="https://github.com/cloudflare/quiche/blob/master/examples/server.rs">servers</a> written in Rust as well.</p>
	<h3 id="more-boring-than-ever">More boring than ever</h3>
	<p>A couple years ago we <a href="https://blog.cloudflare.com/make-ssl-boring-again">migrated our entire HTTPS stack to BoringSSL</a>, the crypto and TLS library developed by Google. This allowed us to streamline our stack (weâ€™d previously had to maintain our own internal patches to OpenSSL for many of the features that BoringSSL offers out-of-the-box) as well as ship exciting new features more quickly.</p>
	<p>For those not following the QUIC standardization process, the QUIC protocol itself makes use of <a href="https://blog.cloudflare.com/rfc-8446-aka-tls-1-3">TLS 1.3</a> as part of its connection handshake, so it made sense that our QUIC implementation would also use BoringSSL to implement that part of the protocol.</p>
	<p>As far as QUIC is concerned, the TLS library needs to provide negotiation of cryptographic parameters (including encryption secrets), which are then used by the QUIC layer itself to encrypt/decrypt the packets on the wire. The TLS record layer is replaced by QUIC framing to avoid overhead and duplication so that TLS handshake messages are carried directly on top of encrypted QUIC packets.</p>
	<p>This makes integrating with existing TLS implementations more challenging since they would need to expose the raw TLS handshake messages as-is, without record layer or protection which would be handled by quiche itself.<br>BoringSSL offers a dedicated API that can be used by QUIC implementations, which required <a href="https://boringssl-review.googlesource.com/c/boringssl/+/29464">a</a> <a href="https://boringssl-review.googlesource.com/c/boringssl/+/33724">few</a> <a href="https://boringssl-review.googlesource.com/c/boringssl/+/33904">tweaks</a> along the way as you would expect with something so new and experimental, but was overall a breeze to integrate into quiche.</p>
	<h3 id="one-ring-to-rule-them-all">One ring to rule them all</h3>
	<p>While the TLS handshake is implemented using BoringSSLâ€™s API directly (via Rustâ€™s FFI support), to implement QUICâ€™s packet protection we decided to use <a href="https://github.com/briansmith/ring">ring</a>, a very popular Rust library that provides safe and fast cryptographic primitives.</p>
	<p>Ring offers most of the same cryptographic primitives youâ€™d get with BoringSSLâ€™s libcrypto, but exposed through an intuitive and safe Rust API. In fact, ring uses some of the same fast implementations of cryptographic algorithms that BoringSSL also uses, but exposed through a nicer API.</p>
	<p>However QUICâ€™s use of cryptography is somewhat unique and, uhm, exotic: the packetâ€™s payload protection uses standard AEAD (â€œauthenticated encryption with associated dataâ€) algorithms like AES-GCM and ChaCha20-Poly1305, but the protection for the packetâ€™s header is different and was designed specifically for QUIC to prevent middle-boxes on the network from intercepting some of the packetâ€™s metadata (like the packet number).</p>
	<p>Ring didnâ€™t originally expose the primitives required to implement QUICâ€™s header protection, but adding support for them was easy enough, and our changes, now <a href="https://github.com/briansmith/ring/pull/749">also</a> <a href="https://github.com/briansmith/ring/pull/756">open-source</a>, were officially released in ring v0.14.0 and available for everyone to use.</p>
	<h3 id="conclusion">Conclusion</h3>
	<p>While quiche is one of the more recent additions to the <a href="https://github.com/quicwg/base-drafts/wiki/Implementations">list of QUIC implementations</a> (its first commit only dates back 3 months or so), itâ€™s already able to interoperate with the other more mature implementations and exercise many of QUICâ€™s features.</p>
	<p>Quiche, just like QUIC itself, is not â€œdoneâ€ (or perfect for that matter) yet. Bugs will be found and fixed, new exciting features implemented (and then more bugs will be found), and API compatibility broken, as we gain experience and learn from wider deployment of QUIC on the Internet.</p>
</div>