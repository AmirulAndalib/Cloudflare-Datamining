<div class="mb2 gray5">8 min read</div>
<div class="post-content lh-copy gray1">
	<p>Le délai de réception du premier octet (« Time to First Byte », ou « TTFB ») d'un site désigne le temps écoulé entre le moment où l'utilisateur commence à naviguer et celui où commence à arriver le code HTML de la page qu'il demande. Le TTFB trop lent est le fléau de mon existence depuis plus de dix ans que j'utilise </p>
	<figure class="kg-card kg-embed-card">
		<blockquote class="twitter-tweet">
			<p lang="en" dir="ltr">Looking at a recent test data set (~100k pages):<br><br>20% TTFB &gt; 3s<br>80% start render &gt; 5s (10% &gt; 10s)<br>500 pages were &gt; 15MB<br><br>So much slow to fix</p>— Patrick Meenan (@patmeenan) <a href="https://twitter.com/patmeenan/status/763372155052494852?ref_src=twsrc%5Etfw" target="_blank">August 10, 2016</a>
		</blockquote>
		<script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
	</figure>
	<p>Si le TTFB figure parmi les quelques éléments d'évaluation sur lesquels se base WebpPageTest pour noter un site, c'est qu'il y a une bonne raison. Et s'il est le premier d'entre eux, c'est également pour une bonne raison.</p>
	<figure class="kg-card kg-image-card"><img src="https://blog.cloudflare.com/content/images/2019/04/image2.png" class="kg-image" alt="" loading="lazy"></figure>
	<p>Si le délai de réception du premier octet est long, <strong>TOUS</strong> les autres indicateurs seront ralentis. Fait rare : en l'améliorant, on peut prédire quelles seront les répercussions sur tous les autres indicateurs. Chaque milliseconde d'amélioration du TTFB se traduit directement par une milliseconde de réduction pour tous les autres indicateurs (c'est-à-dire que le premier arrière-plan apparaîtra 500 ms plus vite si le TTFB est raccourci de 500 ms). Cela dit, ce n'est pas parce que le TTFB est rapide que tout est rapide, mais l'inverse est vrai. Je dirais qu'environ 50 % de toutes les demandes d'aide relatives aux résultats de WebPageTest proviennent de webmasters confrontés à un TTFB trop lent.</p>
	<p>Le TTFB peut contenir de nombreux éléments, parmi lesquels les redirections, le DNS, la configuration de la connexion, la négociation SSL et le temps de réponse réel du serveur. La plupart d'entre eux peuvent être corrigés relativement facilement en utilisant un service comme Cloudflare, mais le temps de réponse du serveur pour le HTML lui-même est souvent le plus gros problème et le plus difficile à résoudre.</p>
	<p>Le diagramme en cascade ci-dessous montre le temps de réponse du serveur sous la forme d'une barre bleu clair à la première requête. Lorsqu'il est lent, cela ne se voit que trop bien. Dans des conditions optimales, le temps de réponse du serveur ne serait pas plus long que la barre orange représentant la connexion au socket qui le précède immédiatement.</p>
	<p></p>
	<figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.cloudflare.com/content/images/2019/04/waterfall.png" class="kg-image" alt="" loading="lazy">
		<figcaption>Plus de trois secondes pour que le serveur réponde.</figcaption>
	</figure>
	<p></p>
	<p>La lenteur des temps de réponse d'origine peut être due à une multitude de problèmes allant de la configuration du serveur, de la charge du système, des bases de données back-end et des systèmes auxquels il parle, au code applicatif lui-même. Pour enrayer les problèmes de performances à la racine, les équipes d'ingénieurs <a href="https://en.wikipedia.org/wiki/DevOps" target="_blank">DevOps</a> travaillent généralement avec des <a href="https://en.wikipedia.org/wiki/Application_performance_management" target="_blank">outils de gestion des performances des applications</a> pour repérer les éléments les plus lents de l'application et les améliorer.</p>
	<p>Une grande partie des administrateurs de sites avec lesquels j'ai travaillé n'ont pas les ressources ou l'expertise nécessaires pour mener ce genre d'enquête. Dans la plupart des cas, ils ont payé un spécialiste pour le développement de leur site, ou l'ont développé eux-mêmes sur WordPress et l'hébergent sur un service d'hébergement bon marché. En général, les solutions d'hébergement sont conçues pour gérer autant de sites que possible, pas nécessairement pour obtenir des performances optimales.</p>
	<h3 id="mise-en-cache-p-riph-rique-du-html"><strong>Mise en cache périphérique du HTML</strong></h3>
	<p>Le fait est que la plupart des contenus HTML ne sont pas vraiment dynamiques. Ils doivent pouvoir changer relativement rapidement lorsque le site est mis à jour, mais, pour une grande partie du Web, le contenu reste statique pendant des mois ou des années.</p>
	<p>Dans certains cas particuliers, comme lorsqu'un utilisateur est connecté (administrateur ou autre), le contenu doit être différent, mais la grande majorité des visites sont effectuées par des utilisateurs anonymes. Si le HTML peut être mis en cache et transmis directement à partir de la périphérie, les gains de performance peuvent être substantiels (plus de 3 secondes plus rapides sur tous les indicateurs).</p>
	<p></p>
	<figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.cloudflare.com/content/images/2019/04/waterfall-fast.png" class="kg-image" alt="" loading="lazy">
		<figcaption>Un temps de réponse du serveur beaucoup plus rapide.</figcaption>
	</figure>
	<p></p>
	<p>Il existe des douzaines de plugins pour WordPress permettant de mettre en cache le contenu à l'origine, mais ils nécessitent une configuration (où mettre les pages en cache) et les performances dépendent toujours fortement des performances du service d'hébergement lui-même. Le fait de déplacer le cache de contenu un peu plus vers la périphérie réduit la complexité, élimine le temps supplémentaire nécessaire pour revenir à l'origine et exclut complètement du calcul les performances du service d'hébergement. Il peut également réduire considérablement la charge pesant sur les systèmes d'hébergement en supprimant la totalité du trafic anonyme.</p>
	<p>Cloudflare prend en charge la <a href="https://support.cloudflare.com/hc/en-us/articles/236166048-Caching-Static-HTML-with-WordPress-WooCommerce" target="_blank">mise en cache HTML statique</a>, et les clients professionnels et les entreprises peuvent permettre aux utilisateurs connectés d'ignorer le cache en activant le « contournement du cache des cookies ». Cette fonctionnalité interagit avec le <a href="https://wordpress.org/plugins/cloudflare" target="_blank">plugin Cloudflare pour WordPress</a> afin que le cache puisse être effacé chaque fois que le contenu est mis à jour. Il existe également plusieurs autres plugins de mise en cache qui s'intègrent avec différents RDC, mais dans tous les cas, ils doivent être configurés avec des clés API pour RDC et les implémentations sont spécifiques à chaque RDC.</p>
	<h3 id="mise-en-cache-p-riph-rique-du-html-sans-configuration"><strong>Mise en cache périphérique du HTML sans configuration</strong></h3>
	<p>Pour une adoption massive, nous devons faire en sorte que la mise en cache du HTML se fasse automatiquement (ou le plus automatiquement possible). Pour cela, nous avons besoin d'un moyen de communiquer entre une origine (comme un site WordPress) et un cache périphérique (comme les nœuds périphériques de Cloudflare) pour gérer un cache distant pouvant être purgé facilement.</p>
	<p>L’origine doit être capable de :</p>
	<ul>
		<li>savoir quand un cache périphérique compatible se trouve devant elle ;</li>
		<li>préciser le contenu qui doit être mis en cache et pour quels visiteurs (c'est-à-dire ceux sans cookie de connexion) ;</li>
		<li>purger le contenu du cache lorsqu'il a changé (au niveau de toutes les zones périphériques).</li>
	</ul>
	<p>Au lieu de demander à l'origine de s'intégrer avec une API pour purger les modifications et de nécessiter une configuration manuelle pour savoir quoi mettre en cache et quand nous pouvons tout accomplir en utilisant des en-têtes HTTP sur les requêtes qui font des allers-retours entre la périphérie et l'origine :</p>
	<p>1 - Un en-tête HTTP est ajouté aux requêtes allant de la périphérie à l'origine pour annoncer la présence d'un cache périphérique et des fonctionnalités qu'il peut prendre en charge :</p>
	<p><code>x-HTML-Edge-Cache: supports=cache|purgeall|bypass-cookies</code></p>
	<figure class="kg-card kg-image-card"><img src="https://blog.cloudflare.com/content/images/2019/04/get.png" class="kg-image" alt="" loading="lazy"></figure>
	<p>2 - Lorsque l'origine répond avec une page pouvant être mise en cache, elle ajoute un en-tête HTTP à la réponse pour indiquer qu'elle doit être mise en cache et préciser toute consigne concernant les situations où la version en cache ne doit pas être utilisée (pour permettre aux utilisateurs connectés d'éviter la mise en cache) :</p>
	<p><code>x-HTML-Edge-Cache: cache,bypass-cookies=wp-|wordpress</code><br></p>
	<figure class="kg-card kg-image-card"><img src="https://blog.cloudflare.com/content/images/2019/04/get-response.png" class="kg-image" alt="" loading="lazy"></figure>
	<p>Dans ce cas, le HTML sera mis en cache, mais toutes les requêtes dont les cookies ont un nom commençant par « wordpress » ou « wp- », car le nom du cookie contournera le cache et ira à l'origine.</p>
	<p>3 - Lorsqu'une requête modifie le contenu du site (mise à jour d'un message, modification d'un thème, ajout d'un commentaire), l'origine ajoute un en-tête de réponse HTTP indiquant que le cache doit être purgé :</p>
	<p><code>x-HTML-Edge-Cache: purgeall</code></p>
	<figure class="kg-card kg-image-card"><img src="https://blog.cloudflare.com/content/images/2019/04/update-1.png" class="kg-image" alt="" loading="lazy"></figure>
	<figure class="kg-card kg-image-card"><img src="https://blog.cloudflare.com/content/images/2019/04/update-response.png" class="kg-image" alt="" loading="lazy"></figure>
	<p>Seul point délicat : la purge doit purger le cache de TOUTES les zones périphériques, et pas seulement de la zone par laquelle est passée la requête.</p>
	<p>4 - Lorsqu'une nouvelle requête de HTML se trouvant dans le cache périphérique est reçue, les cookies de requête sont vérifiés par rapport aux critères de réponse en cache. Si les cookies ne sont pas présents, la version en cache est envoyée ; dans le cas contraire, la requête est transmise à l'origine.</p>
	<figure class="kg-card kg-image-card"><img src="https://blog.cloudflare.com/content/images/2019/04/cached.png" class="kg-image" alt="" loading="lazy"></figure>
	<p>Grâce à cette interface de commande et de contrôle simple reposant sur des en-têtes, plus besoin d'une origine pour communiquer avec une API ou d'une configuration spécifique. Cela rend également la logique sur l'origine beaucoup plus facile à implémenter, car il n'y a pas de configuration (ou d'UI) et pas de nécessité de requêtes sortantes vers une API propre à un fournisseur. Le <a href="https://github.com/cloudflare/worker-examples/blob/master/examples/edge-cache-html/WordPress%20Plugin/cloudflare-page-cache/cloudflare-page-cache.php" target="_blank">plugin WordPress en exemple</a> compte moins de 50 lignes de code, dont la grande majorité consiste à connecter des rappels pour tous les événements qui modifient le contenu.</p>
	<h3 id="commencez-utiliser-la-mise-en-cache-d-s-aujourd-hui-avec-wordpress-et-workers"><strong>Commencez à utiliser la mise en cache dès aujourd'hui avec WordPress et Workers</strong></h3>
	<p>L'une des choses que j'aime le plus avec Workers, c'est que vous obtenez une zone périphérique totalement programmable qui vous permet de tester vos idées et d'appliquer votre propre logique. J’ai créé un <a href="https://github.com/cloudflare/worker-examples/tree/master/examples/edge-cache-html" target="_blank">script Worker</a> qui implémente le protocole basé sur les en-têtes et la mise en cache dans les zones périphériques de Cloudflare, et un <a href="https://github.com/cloudflare/worker-examples/tree/master/examples/edge-cache-html/WordPress%20Plugin" target="_blank">plugin WordPress</a> qui implémente la logique de l’origine pour WordPress.</p>
	<p>Le seul problème avec le Worker a été de trouver un moyen de purger tous les éléments du cache. Les caches Worker sont propres à chaque zone périphérique et ne disposent pas d'une interface permettant d'effectuer des opérations au niveau global. Il est possible de le faire en utilisant l'API Cloudflare pour purger le cache global, mais la purge de tout le cache, y compris des scripts et des images, est un peu lourde et nécessite une certaine configuration. Si vous connaissez précisément les URL qui seront modifiées par un changement de contenu, la meilleure solution serait probablement de procéder à une purge ciblée via l'API uniquement pour ces URL.</p>
	<p>Avec le nouveau <a href="https://developers.cloudflare.com/workers/kv" target="_blank">magasin de données Workers KV</a>, nous pouvons purger la cache d'une autre manière. Le script Worker utilise un schéma de gestion des versions pour le cache qui attribue un numéro de version à chaque URL (par exemple, <a href="http://www.example.com/?cf_edge_cache_ver=32" target="_blank">http://www.example.com/?cf_edge_cache_ver=32</a>). L'URL modifiée n'est utilisée que localement par le worker comme clé pour les réponses mises en cache, et le numéro de version actuel est stocké dans KV, un magasin de données global. Lorsque le cache est purgé, le numéro de version passe au suivant, ce qui modifie l'URL pour toutes les ressources. Les anciennes écritures seront retirées du cache, car elles ne seront plus accessibles. Il est nécessaire de configurer un peu KV pour pouvoir utiliser le worker, mais on peut espérer que cela devienne automatique à l'avenir.</p>
	<h3 id="et-ensuite"><strong>Et ensuite ?</strong></h3>
	<p>Je pense que le Web aurait grand intérêt à normaliser un moyen de communication entre les caches périphériques et les origines pour que le contenu dynamique puisse être mis en cache. Cela inciterait les systèmes de gestion de contenu à intégrer la prise en charge directement dans les plates-formes et à fournir une interface standard qui pourrait être utilisée par différents fournisseurs (et même pour les caches périphériques locaux dans les équilibreurs de charge ou d'autres proxies inverses). Après avoir effectué d'autres tests avec différents types de sites, je pense proposer le concept au <a href="https://httpwg.org" target="_blank">groupe de travail HTTP de l'IETF</a> pour voir si nous pouvons nous mettre d'accord sur une norme officielle en matière d'en-têtes de contrôle (en utilisant différents noms). Si vous avez des idées concernant son fonctionnement ou les fonctionnalités dont vous auriez besoin, je serais ravi de les connaître (comme la purge d'URL spécifiques, la modification du contenu selon le type d'appareil ou la zone géographique, son extension à tous types de contenus, etc).<br></p>
</div>