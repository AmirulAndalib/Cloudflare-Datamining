{
	"post": {
		"id": "5db35c0bfd9e450505d994b1",
		"uuid": "b1f1d1d9-1051-4540-8491-619401d79ce6",
		"title": "Supporting the latest version of the Privacy Pass Protocol",
		"slug": "supporting-the-latest-version-of-the-privacy-pass-protocol",
		"html": "<figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"http://blog.cloudflare.com/content/images/2019/10/Privacy-Pass-@2x-2.png\" class=\"kg-image\" alt loading=\"lazy\"></figure><p>At Cloudflare, we are committed to supporting and developing new privacy-preserving technologies that benefit all Internet users. In November 2017, we announced server-side support for the <a href=\"http://blog.cloudflare.com/cloudflare-supports-privacy-pass/\">Privacy Pass protocol</a>, a piece of work developed in <a href=\"https://petsymposium.org/2018/files/papers/issue3/popets-2018-0026.pdf\">collaboration with the academic community</a>. Privacy Pass, in a nutshell, allows clients to provide proof of trust <a href=\"https://privacypass.github.io/protocol/\">without revealing where and when the trust was provided</a>. The aim of the protocol is then to allow anyone to prove they are trusted by a server, without that server being able to track the user via the trust that was assigned.</p><p>On a technical level, Privacy Pass clients receive attestation tokens from a server, that can then be redeemed in the future. These tokens are provided when a server deems the client to be trusted; for example, after they have logged into a service or if they prove certain characteristics. The redeemed tokens are cryptographically unlinkable to the attestation originally provided by the server, and so they do not reveal anything about the client.</p><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"http://blog.cloudflare.com/content/images/2019/10/imageLikeEmbed--2-.png\" class=\"kg-image\" alt loading=\"lazy\"></figure><figure class=\"kg-card kg-image-card\"><img src=\"http://blog.cloudflare.com/content/images/2019/10/imageLikeEmbed--1-.png\" class=\"kg-image\" alt loading=\"lazy\"></figure><p>To use Privacy Pass, clients can install an <a href=\"https://github.com/privacypass/challenge-bypass-extension\">open-source</a> browser extension available in <a href=\"https://chrome.google.com/webstore/detail/privacy-pass/ajhmfdgkijocedmfjonnpjfojldioehi?hl=en\">Chrome</a> &amp; <a href=\"https://addons.mozilla.org/en-US/firefox/addon/privacy-pass/\">Firefox</a>. There have been over 150,000 individual downloads of Privacy Pass worldwide; approximately 130,000 in Chrome and more than 20,000 in Firefox. The extension is supported by Cloudflare to make websites more accessible for users. This complements previous work, including the launch of <a href=\"http://blog.cloudflare.com/cloudflare-onion-service/\">Cloudflare onion services</a> to help improve accessibility for users of the Tor Browser.</p><p>The initial release was almost two years ago, and it was followed up with a <a href=\"https://petsymposium.org/2018/files/papers/issue3/popets-2018-0026.pdf\">research publication</a> that was presented at the <a href=\"https://www.youtube.com/watch?v=9DsUi-UF2pM&amp;list=PLWSQygNuIsPd6YJmGV9kn1mP2A6-IBCoU&amp;index=10\">Privacy Enhancing Technologies Symposium 2018</a> (winning a Best Student Paper award). Since then, Cloudflare has been working with the wider community to build on the initial design and improve Privacy Pass. We’ll be talking about the work that we have done to develop the existing implementations, alongside the protocol itself.</p><h1 id=\"what-s-new\">What’s new?</h1><!--kg-card-begin: markdown--><p><strong>Support for Privacy Pass v2.0 browser extension:</strong></p>\n<ul>\n<li>Easier configuration of workflow.</li>\n<li>Integration with new service provider (hCaptcha).</li>\n<li>Compliance with hash-to-curve draft.</li>\n<li>Possible to rotate keys outside of extension release.</li>\n<li>Available in <a href=\"https://chrome.google.com/webstore/detail/privacy-pass/ajhmfdgkijocedmfjonnpjfojldioehi?hl=en\">Chrome</a> and <a href=\"https://addons.mozilla.org/en-US/firefox/addon/privacy-pass/\">Firefox</a> (works best with up-to-date browser versions).</li>\n</ul>\n<p><strong>Rolling out a new server backend using Cloudflare Workers platform:</strong></p>\n<ul>\n<li>Cryptographic operations performed using internal V8 engine.</li>\n<li>Provides public redemption API for Cloudflare Privacy Pass v2.0 tokens.</li>\n<li>Available by making POST requests to <a href=\"https://privacypass.cloudflare.com/api/redeem\">https://privacypass.cloudflare.com/api/redeem</a>. See the documentation for <a href=\"https://privacypass.github.io/api-redeem\">example usage</a>.</li>\n<li>Only compatible with extension v2.0 (check that you have updated!).</li>\n</ul>\n<p><strong>Standardization:</strong></p>\n<ul>\n<li>Continued development of oblivious pseudorandom functions (OPRFs) <a href=\"https://datatracker.ietf.org/doc/draft-irtf-cfrg-voprf/\">draft</a> in prime-order groups with CFRG@IRTF.</li>\n<li><a href=\"https://github.com/alxdavids/draft-privacy-pass\">New draft</a> specifying Privacy Pass protocol.</li>\n</ul>\n<!--kg-card-end: markdown--><h1 id=\"extension-v2-0\">Extension v2.0</h1><p>In the time since the release, we’ve been working on a number of new features. Today we’re excited to announce support for version 2.0 of the extension, the first update since the original release. The extension continues to be available for <a href=\"https://chrome.google.com/webstore/detail/privacy-pass/ajhmfdgkijocedmfjonnpjfojldioehi?hl=en\">Chrome</a> and <a href=\"https://addons.mozilla.org/en-US/firefox/addon/privacy-pass/\">Firefox</a>. You may need to download v2.0 manually from the store if you have auto-updates disabled in your browser.</p><p>The extension remains under active development and we still regard our support as in the beta phase. This will continue to be the case as the draft specification of the protocol continues to be written in collaboration with the wider community.</p><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"http://blog.cloudflare.com/content/images/2019/10/pasted-image-0-2.png\" class=\"kg-image\" alt loading=\"lazy\"></figure><h3 id=\"new-integrations\">New Integrations</h3><p>The client implementation uses the <a href=\"https://developer.chrome.com/extensions/webRequest\">WebRequest API</a> to look for certain types of HTTP requests. When these requests are spotted, they are rewritten to include some cryptographic data required for the Privacy Pass protocol. This allows Privacy Pass providers receiving this data to authorize access for the user.</p><p>For example, a user may receive Privacy Pass tokens for completing some server security checks. These tokens are stored by the browser extension, and any future request that needs similar security clearance can be modified to add a stored token as an extra HTTP header. The server can then check the client token and verify that the client has the correct authorization to proceed.</p><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"http://blog.cloudflare.com/content/images/2019/10/imageLikeEmbed--4-.png\" class=\"kg-image\" alt loading=\"lazy\"></figure><p>While Cloudflare supports a particular type of request flow, it would be impossible to expect different service providers to all abide by the same exact interaction characteristics. One of the major changes in the v2.0 extension has been a technical rewrite to instead use a central configuration file. The config is specified in the <a href=\"https://github.com/privacypass/challenge-bypass-extension/blob/master/src/ext/config.js\">source code</a> of the extension and allows easier modification of the browsing characteristics that initiate Privacy Pass actions. This makes adding new, completely different request flows possible by simply cloning and adapting the configuration for new providers.</p><p>To demonstrate that such integrations are now possible with other services beyond Cloudflare, a new version of the extension will soon be rolling out that is supported by the CAPTCHA provider <a href=\"https://www.hcaptcha.com/\">hCaptcha</a>. Users that solve ephemeral challenges provided by hCaptcha will receive privacy-preserving tokens that will be redeemable at other hCaptcha customer sites.</p><figure class=\"kg-card kg-image-card\"><img src=\"http://blog.cloudflare.com/content/images/2019/10/image-8-1.png\" class=\"kg-image\" alt loading=\"lazy\"></figure><!--kg-card-begin: markdown--><p><span style=\"color:grey\"><small><em>“hCaptcha is focused on user privacy, and supporting Privacy Pass is a natural extension of our work in this area. We look forward to working with Cloudflare and others to make this a common and widely adopted standard, and are currently exploring other applications. Implementing Privacy Pass into our globally distributed service was relatively straightforward, and we have enjoyed working with the Cloudflare team to improve the open source Chrome browser extension in order to deliver the best experience for our users.”</em></p>\n<p>— <strong>Eli-Shaoul Khedouri</strong>, founder of hCaptcha</small></span></p>\n<!--kg-card-end: markdown--><p>This hCaptcha integration with the Privacy Pass browser extension acts as a proof-of-concept in establishing support for new services. Any new providers that would like to integrate with the Privacy Pass browser extension can do so simply by making a PR to the <a href=\"https://github.com/privacypass/challenge-bypass-extension/\">open-source repository</a>.</p><h2 id=\"improved-cryptographic-functionality\">Improved cryptographic functionality</h2><p>After the release of v1.0 of the extension, there were features that were still unimplemented. These included proper zero-knowledge proof validation for checking that the server was always using the same committed key. In v2.0 this functionality has been completed, verifiably preventing a malicious server from attempting to deanonymize users by using a different key for each request.</p><p>The cryptographic operations required for Privacy Pass are performed using <a href=\"http://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography/\">elliptic curve cryptography</a> (ECC). The extension currently uses the <a href=\"https://www.secg.org/SEC2-Ver-1.0.pdf\">NIST P-256</a> curve, for which we have included some optimisations. Firstly, this makes it possible to store elliptic curve points in compressed and uncompressed data formats. This means that browser storage can be reduced by 50%, and that server responses can be made smaller too.</p><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"http://blog.cloudflare.com/content/images/2019/10/imageLikeEmbed--5-.png\" class=\"kg-image\" alt loading=\"lazy\"></figure><p>Secondly, support has been added for hashing to the P-256 curve using the “Simplified Shallue-van de Woestijne-Ulas” (SSWU) method specified in an ongoing draft (<a href=\"https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-03\">https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-03</a>) for standardizing encodings for hashing to elliptic curves. The implementation is compliant with the specification of the “P256-SHA256-SSWU-” ciphersuite in this draft.</p><p>These changes have a dual advantage, firstly ensuring that the P-256 hash-to-curve specification is compliant with the draft specification. Secondly this ciphersuite removes the necessity for using probabilistic methods, such as <a href=\"https://tools.ietf.org/html/draft-irtf-cfrg-vrf-05#section-5.4.1.1\">hash-and-increment</a>. The hash-and-increment method has a non-negligible chance of failure, and the running time is highly dependent on the hidden client input. While it is not clear how to abuse timing attack vectors currently, using the SSWU method should reduce the potential for attacking the implementation, and learning the client input.</p><h2 id=\"key-rotation\">Key rotation</h2><p>As we mentioned above, verifying that the server is always using the same key is an important part of ensuring the client’s privacy. This ensures that the server cannot segregate the user base and reduce client privacy by using different secret keys for each client that it interacts with. The server guarantees that it’s always using the same key by publishing a commitment to its public key somewhere that the client can access.</p><p>Every time the server issues Privacy Pass tokens to the client, it also produces a <a href=\"https://en.wikipedia.org/wiki/Zero-knowledge_proof\">zero-knowledge proof</a> that it has produced these tokens using the correct key.</p><figure class=\"kg-card kg-image-card\"><img src=\"http://blog.cloudflare.com/content/images/2019/10/imageLikeEmbed--6-.png\" class=\"kg-image\" alt loading=\"lazy\"></figure><p>Before the extension stores any tokens, it first verifies the proof against the commitments it knows. Previously, these commitments were stored directly in the source code of the extension. This meant that if the server wanted to rotate its key, then it required releasing a new version of the extension, which was unnecessarily difficult. The extension has been modified so that the commitments are stored in a <a href=\"https://github.com/privacypass/ec-commitments\">trusted location</a> that the client can access when it needs to verify the server response. Currently this location is a separate Privacy Pass <a href=\"https://github.com/privacypass/ec-commitments\">GitHub repository</a>. For those that are interested, we have provided a more detailed description of the new commitment format in Appendix A at the end of this post.</p><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"http://blog.cloudflare.com/content/images/2019/10/imageLikeEmbed--7-.png\" class=\"kg-image\" alt loading=\"lazy\"></figure><h1 id=\"implementing-server-side-support-in-workers\">Implementing server-side support in Workers</h1><p>So far we have focused on client-side updates. As part of supporting v2.0 of the extension, we are rolling out some major changes to the server-side support that Cloudflare uses. For version 1.0, we used a <a href=\"https://github.com/privacypass/challenge-bypass-server\">Go implementation</a> of the server. In v2.0 we are introducing a new server implementation that runs in the <a href=\"https://www.cloudflare.com/products/cloudflare-workers/\">Cloudflare Workers</a> platform. This server implementation is only compatible with v2.0 releases of Privacy Pass, so you may need to update your extension if you have auto-updates turned off in your browser.</p><p>Our server will run at <a href=\"https://privacypass.cloudflare.com\">https://privacypass.cloudflare.com</a>, and all Privacy Pass requests sent to the Cloudflare edge are handled by Worker scripts that run on this domain. Our implementation has been rewritten using Javascript, with cryptographic operations running in the <a href=\"https://v8.dev/\">V8 engine</a> that powers Cloudflare Workers. This means that we are able to run highly efficient and constant-time cryptographic operations. On top of this, we benefit from the enhanced performance provided by running our code in the Workers Platform, as close to the user as possible.</p><h2 id=\"webcrypto-support\">WebCrypto support</h2><p>Firstly, you may be asking, how do we manage to implement cryptographic operations in Cloudflare Workers? Currently, support for performing cryptographic operations is provided in the Workers platform via the <a href=\"https://developers.cloudflare.com/workers/reference/apis/web-crypto/\">WebCrypto API</a>. This API allows users to compute functionality such as cryptographic hashing, alongside more complicated operations like ECDSA signatures.</p><p>In the Privacy Pass protocol, as we’ll discuss a bit later, the main cryptographic operations are performed by a protocol known as a verifiable oblivious pseudorandom function (VOPRF). Such a protocol allows a client to learn function outputs computed by a server, without revealing to the server what their actual input was. The verifiable aspect means that the server must also prove (in a publicly verifiable way) that the evaluation they pass to the user is correct. Such a function is pseudorandom because the server output is indistinguishable from a random sequence of bytes.</p><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"http://blog.cloudflare.com/content/images/2019/10/imageLikeEmbed--8-.png\" class=\"kg-image\" alt loading=\"lazy\"></figure><p>The VOPRF functionality requires a server to perform low-level ECC operations that are not currently exposed in the WebCrypto API. We balanced out the possible ways of getting around this requirement. First we trialled trying to use the WebCrypto API in a non-standard manner, using EC Diffie-Hellman key exchange as a method for performing the scalar multiplication that we needed. We also tried to implement all operations using pure JavaScript. Unfortunately both methods were unsatisfactory in the sense that they would either mean integrating with large external cryptographic libraries, or they would be far too slow to be used in a performant Internet setting.</p><!--kg-card-begin: markdown--><p>In the end, we settled on a solution that adds functions necessary for Privacy Pass to the internal WebCrypto interface in the Cloudflare V8 Javascript engine. This algorithm mimics the sign/verify interface provided by signature algorithms like ECDSA. In short, we use the <code>sign()</code> function to issue Privacy Pass tokens to the client. While <code>verify()</code> can be used by the server to verify data that is redeemed by the client. These functions are implemented directly in the V8 layer and so they are much more performant and secure (running in constant-time, for example) than pure JS alternatives.</p>\n<!--kg-card-end: markdown--><p>The Privacy Pass WebCrypto interface is not currently available for public usage. If it turns out there is enough interest in using this additional algorithm in the Workers platform, then we will consider making it public.</p><h3 id=\"applications\">Applications</h3><p>In recent times, VOPRFs have been shown to be a highly useful primitive in establishing many cryptographic tools. Aside from Privacy Pass, they are also essential for constructing password-authenticated key exchange protocols such as <a href=\"https://datatracker.ietf.org/doc/draft-krawczyk-cfrg-opaque/\">OPAQUE</a>. They have also been used in designs of <a href=\"https://eprint.iacr.org/2016/799\">private set intersection</a>, <a href=\"https://eprint.iacr.org/2014/650\">password-protected secret-sharing</a> protocols, and <a href=\"https://medium.com/least-authority/the-path-from-s4-to-privatestorage-ae9d4a10b2ae\">privacy-preserving access-control</a> for private data storage.</p><h2 id=\"public-redemption-api\">Public redemption API</h2><p>Writing the server in Cloudflare Workers means that we will be providing server-side support for Privacy Pass on a <a href=\"https://privacypass.cloudflare.com\">public domain</a>! While we only issue tokens to clients after we are sure that we can trust them, anyone will be able to redeem the tokens using our public redemption API at <a href=\"https://privacypass.cloudflare.com/api/redeem\">https://privacypass.cloudflare.com/api/redeem</a>. As we roll-out the server-side component worldwide, you will be able to interact with this API and verify Cloudflare Privacy Pass tokens <a href=\"https://privacypass.github.io/api-redeem\">independently of the browser extension</a>.</p><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"http://blog.cloudflare.com/content/images/2019/10/imageLikeEmbed--9-.png\" class=\"kg-image\" alt loading=\"lazy\"></figure><p>This means that any service can accept Privacy Pass tokens from a client that were issued by Cloudflare, and then verify them with the Cloudflare redemption API. Using the result provided by the API, external services can check whether Cloudflare has authorized the user in the past.</p><p>We think that this will benefit other service providers because they can use the attestation of authorization from Cloudflare in their own decision-making processes, without sacrificing the privacy of the client at any stage. We hope that this ecosystem can grow further, with potentially more services providing public redemption APIs of their own. With a more diverse set of issuers, these attestations will become more useful.</p><p>By running our server on a public domain, we are effectively a customer of the Cloudflare Workers product. This means that we are also able to make use of <a href=\"https://developers.cloudflare.com/workers/reference/storage/\">Workers KV</a> for protecting against malicious clients. In particular, servers must check that clients are not re-using tokens during the redemption phase. The performance of Workers KV in analyzing reads makes this an obvious choice for providing double-spend protection globally.</p><p>If you would like to use the public redemption API, we provide documentation for using it at <a href=\"https://privacypass.github.io/api-redeem\">https://privacypass.github.io/api-redeem</a>. We also provide some example requests and responses in Appendix B at the end of the post.</p><h1 id=\"standardization-new-applications\">Standardization &amp; new applications</h1><p>In tandem with the recent engineering work that we have been doing on supporting Privacy Pass, we have been collaborating with the wider community in an attempt to standardize both the <a href=\"https://datatracker.ietf.org/doc/draft-irtf-cfrg-voprf/\">underlying VOPRF functionality</a>, and the <a href=\"https://github.com/alxdavids/draft-privacy-pass\">protocol itself</a>. While the process of standardization for oblivious pseudorandom functions (OPRFs) has been running for over a year, the recent efforts to standardize the Privacy Pass protocol have been driven by very recent applications that have come about in the last few months.</p><p>Standardizing protocols and functionality is an important way of providing interoperable, secure, and performant interfaces for running protocols on the Internet. This makes it easier for developers to write their own implementations of this complex functionality. The process also provides helpful peer reviews from experts in the community, which can lead to better surfacing of potential security risks that should be mitigated in any implementation. Other benefits include coming to a consensus on the most reliable, scalable and performant protocol designs for all possible applications.</p><h2 id=\"oblivious-pseudorandom-functions\">Oblivious pseudorandom functions</h2><p>Oblivious pseudorandom functions (OPRFs) are a generalization of VOPRFs that do not require the server to prove that they have evaluated the functionality properly. Since July 2019, we have been collaborating <a href=\"https://datatracker.ietf.org/doc/draft-irtf-cfrg-voprf/\">on a draft</a> with the <a href=\"https://irtf.org/cfrg\">Crypto Forum Research Group</a> (CFRG) at the Internet Research Task Force (IRTF) to standardize an OPRF protocol that operates in prime-order groups. This is a generalisation of the setting that is provided by <a href=\"http://blog.cloudflare.com/tag/elliptic-curves/\">elliptic curves</a>. This is the same VOPRF construction that was <a href=\"http://blog.cloudflare.com/privacy-pass-the-math/\">originally specified</a> by the Privacy Pass protocol and is based heavily on the original protocol design from the <a href=\"https://eprint.iacr.org/2014/650.pdf\">paper of Jarecki, Kiayias and Krawczyk</a>.</p><p>One of the recent changes that we've made in the draft is to increase the size of the key that we consider for performing OPRF operations on the server-side. Existing research suggests that it is possible to create specific queries that can lead to small amounts of the key being leaked. For keys that provide only 128 bits of security this can be a problem as leaking too many bits would reduce security <a href=\"https://www.keylength.com/en/4/\">beyond currently accepted levels</a>. To counter this, we have effectively increased the minimum key size to 192 bits. This prevents this leakage becoming an attack vector using any practical methods. We discuss these attacks in more detail later on when discussing our future plans for VOPRF development.</p><h2 id=\"recent-applications-and-standardizing-the-protocol\">Recent applications and standardizing the protocol</h2><p>The application that we demonstrated when originally supporting Privacy Pass was always intended as a proof-of-concept for the protocol. Over the past few months, a number of new possibilities have arisen in areas that go far beyond what was previously envisaged.</p><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"http://blog.cloudflare.com/content/images/2019/10/imageLikeEmbed--10-.png\" class=\"kg-image\" alt loading=\"lazy\"></figure><p>For example, the <a href=\"https://github.com/WICG/trust-token-api\">trust token API</a>, developed by the <a href=\"https://wicg.io/\">Web Incubator Community Group</a>, has been proposed as an interface for using Privacy Pass. This applications allows third-party vendors to check that a user has received a trust attestation from a set of central issuers. This allows the vendor to make decisions about the honesty of a client without having to associate a behaviour profile with the identity of the user. The objective is to prevent against fraudulent activity from users who are not trusted by the central issuer set. Checking trust attestations with central issuers would be possible using similar redemption APIs to the one that <a href=\"https://privacypass.cloudflare.com\">we have introduced</a>.</p><p>A <a href=\"https://engineering.fb.com/security/partially-blind-signatures/\">separate piece of work from Facebook</a> details a similar application for preventing fraudulent behavior that may also be compatible with the Privacy Pass protocol. Finally, other applications have arisen in the areas of providing access to <a href=\"https://medium.com/least-authority/the-path-from-s4-to-privatestorage-ae9d4a10b2ae\">private storage</a> and <a href=\"https://github.com/brave/brave-browser/wiki/Security-and-privacy-model-for-ad-confirmations\">establishing security and privacy models in advertisement confirmations</a>.</p><h3 id=\"a-new-draft\">A new draft</h3><p>With the applications above in mind, we have recently started collaborative work on a <a href=\"https://github.com/alxdavids/draft-privacy-pass\">new IETF draft</a> that specifically lays out the required functionality provided by the Privacy Pass protocol as a whole. Our aim is to develop, alongside wider industrial partners and the academic community, a functioning specification of the Privacy Pass protocol. We hope that by doing this we will be able to design a base-layer protocol, that can then be used as a cryptographic primitive in wider applications that require some form of lightweight authorization. Our plan is to present the first version of this draft at the upcoming <a href=\"https://www.ietf.org/how/meetings/106/\">IETF 106 meeting</a> in Singapore next month.</p><p>The draft is still in the early stages of development and we are actively looking for people who are interested in helping to shape the protocol specification. We would be grateful for any help that contributes to this process. See <a href=\"https://github.com/alxdavids/draft-privacy-pass\">the GitHub repository</a> for the current version of the document.</p><h1 id=\"future-avenues\">Future avenues</h1><p>Finally, while we are actively working on a number of different pathways in the present, the future directions for the project are still open. We believe that there are many applications out there that we have not considered yet and we are excited to see where the protocol is used in the future. Here are some other ideas we have for novel applications and security properties that we think might be worth pursuing in future.</p><h2 id=\"publicly-verifiable-tokens\">Publicly verifiable tokens</h2><p>One of the disadvantages of using a VOPRF is that redemption tokens are only verifiable by the original issuing server. If we used an underlying primitive that allowed public verification of redemption tokens, then anyone could verify that the issuing server had issued the particular token. Such a protocol could be constructed on top of so-called blind signature schemes, such as <a href=\"https://en.wikipedia.org/wiki/Blind_signature#Blind_RSA_signatures\">Blind RSA</a>. Unfortunately, there are performance and security concerns arising from the usage of blind signature schemes in a browser environment. Existing schemes (especially RSA-based variants) require cryptographic computations that are much heavier than the construction used in our VOPRF protocol.</p><h2 id=\"post-quantum-voprf-alternatives\">Post-quantum VOPRF alternatives</h2><p>The only constructions of VOPRFs exist in pre-quantum settings, usually based on the hardness of well-known problems in group settings such as the <a href=\"https://en.wikipedia.org/wiki/Decisional_Diffie%E2%80%93Hellman_assumption\">discrete-log assumption</a>. No constructions of VOPRFs are known to provide security against adversaries that can run <a href=\"http://blog.cloudflare.com/the-quantum-menace/\">quantum computational algorithms</a>. This means that the Privacy Pass protocol is only believed to be secure against adversaries running  on classical hardware.</p><p>Recent developments suggest that quantum computing may arrive <a href=\"https://www.nature.com/articles/s41586-019-1666-5\">sooner than previously thought</a>. As such, we believe that investigating the possibility of <a href=\"http://blog.cloudflare.com/introducing-circl/\">constructing practical post-quantum alternatives</a> for our current cryptographic toolkit is a task of great importance for ourselves and the wider community. In this case, devising performant post-quantum alternatives for VOPRF constructions would be an important theoretical advancement. Eventually this would lead to a Privacy Pass protocol that still provides privacy-preserving authorization in a post-quantum world.</p><h2 id=\"voprf-security-and-larger-ciphersuites\">VOPRF security and larger ciphersuites</h2><p>We mentioned previously that VOPRFs (or simply OPRFs) are susceptible to small amounts of possible leakage in the key. Here we will give a brief description of the actual attacks themselves, along with further details on our plans for implementing higher security ciphersuites to mitigate the leakage.</p><!--kg-card-begin: markdown--><p>Specifically, malicious clients can interact with a VOPRF for creating something known as a <a href=\"https://eprint.iacr.org/2010/215.pdf\">q-Strong-Diffie-Hellman</a> (q-sDH) sample. Such samples are created in mathematical groups (usually in the elliptic curve setting). For any group there is a public element <code>g</code> that is central to all <a href=\"https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange\">Diffie-Hellman</a> type operations, along with the server key <code>K</code>, which is usually just interpreted as a randomly generated number from this group. A q-sDH sample takes the form:</p>\n<pre><code>( g, g^K, g^(K^2), … , g^(K^q) )\n</code></pre>\n<p>and asks the malicious adversary to create a pair of elements satisfying <code>(g^(1/(s+K)),s)</code>. It is possible for a client in the VOPRF protocol to create a q-SDH sample by just submitting the result of the previous VOPRF evaluation back to the server.</p>\n<!--kg-card-end: markdown--><p>While this problem is believed to be hard to break, there are a number of past works that show that the problem is somewhat easier than the size of the group suggests (for example, see <a href=\"https://eprint.iacr.org/2004/306\">here</a> and <a href=\"https://www.iacr.org/archive/eurocrypt2006/40040001/40040001.pdf\">here</a>). Concretely speaking, the bit security implied by the group can be reduced by up to log<sub>2</sub>(q) bits. While this is not immediately fatal, even to groups that should provide 128 bits of security, it can lead to a loss of security that means that the setting is no longer future-proof. As a result, any group providing VOPRF functionality that is instantiated using an elliptic curve such as P-256 or Curve25519 provides weaker than advised security guarantees.</p><p>With this in mind, we have taken the recent decision to upgrade the ciphersuites that we recommend for OPRF usage to only those that provide &gt; 128 bits of security, as standard. For example, Curve448 provides 192 bits of security. To launch an attack that reduced security to an amount lower than 128 bits would require making 2^(68) client OPRF queries. This is a significant barrier to entry for any attacker, and so we regard these ciphersuites as safe for instantiating the OPRF functionality.</p><p>In the near future, it will be necessary to upgrade the ciphersuites that are used in our support of the Privacy Pass browser extension to the recommendations made in the current VOPRF draft. In general, with a more iterative release process, we hope that the Privacy Pass implementation will be able to follow the current draft standard more closely as it evolves during the standardization process.</p><h2 id=\"get-in-touch-\">Get in touch!</h2><p>You can now install v2.0 of the Privacy Pass extension in <a href=\"https://chrome.google.com/webstore/detail/privacy-pass/ajhmfdgkijocedmfjonnpjfojldioehi?hl=en\">Chrome</a> or <a href=\"https://addons.mozilla.org/en-US/firefox/addon/privacy-pass/\">Firefox</a>.</p><p>If you would like to help contribute to the development of this extension then you can do so on <a href=\"https://github.com/privacypass/challenge-bypass-extension\">GitHub</a>. Are you a service provider that would like to integrate server-side support for the extension? Then we would be very interested in <a href=\"mailto:privacy-pass-support@cloudflare.com\">hearing from you!</a></p><p>We will continue to work with the wider community in developing the standardization of the protocol; taking our motivation from the available applications that have been developed. We are always looking for new applications that can help to expand the Privacy Pass ecosystem beyond its current boundaries.</p><figure class=\"kg-card kg-image-card\"><img src=\"http://blog.cloudflare.com/content/images/2019/10/tales-from-the-crypto-team@2x--1-.png\" class=\"kg-image\" alt loading=\"lazy\"></figure><!--kg-card-begin: markdown--><h1 id=\"appendix\">Appendix</h1>\n<!--kg-card-end: markdown--><p>Here are some extra details related to the topics that we covered above.</p><h2 id=\"a-commitment-format-for-key-rotations\">A. Commitment format for key rotations</h2><p>Key commitments are necessary for the server to prove that they’re acting honestly during the Privacy Pass protocol. The commitments that Privacy Pass uses for the v2.0 release have a slightly different format from the previous release.</p><!--kg-card-begin: markdown--><pre><code class=\"language-json\">&quot;2.00&quot;: {\n  &quot;H&quot;: &quot;BPivZ+bqrAZzBHZtROY72/E4UGVKAanNoHL1Oteg25oTPRUkrYeVcYGfkOr425NzWOTLRfmB8cgnlUfAeN2Ikmg=&quot;,\n  &quot;expiry&quot;: &quot;2020-01-11T10:29:10.658286752Z&quot;,\n  &quot;sig&quot;: &quot;MEUCIQDu9xeF1q89bQuIMtGm0g8KS2srOPv+4hHjMWNVzJ92kAIgYrDKNkg3GRs9Jq5bkE/4mM7/QZInAVvwmIyg6lQZGE0=&quot;\n}\n</code></pre>\n<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>First, the version of the server key is <code>2.00</code>, the server must inform the client which version it intends to use in the response to a client containing issued tokens. This is so that the client can always use the correct commitments when verifying the zero-knowledge proof that the server sends.</p>\n<p>The value of the member <code>H</code> is the public key commitment to the secret key used by the server. This is base64-encoded elliptic curve point of the form <code>H=kG</code> where <code>G</code> is the fixed generator of the curve, and <code>k</code> is the secret key of the server. Since the discrete-log problem is believed to be hard to solve, deriving k from H is believed to be difficult. The value of the member <code>expiry</code> is an expiry date for the commitment that is used. The value of the member <code>sig</code> is an ECDSA signature evaluated using a long-term signing key associated with the server, and over the values of <code>H</code> and <code>expiry</code>.</p>\n<p>When a client retrieves the commitment, it checks that it hasn’t expired and that the signature verifies using the corresponding verification key that is embedded into the configuration of the extension. If these checks pass, it retrieves <code>H</code> and verifies the issuance response sent by the server. Previous versions of these commitments did not include signatures, but these signatures will be validated from v2.0 onwards.</p>\n<p>When a server wants to rotate the key, it simply generates a new key <code>k2</code> and appends a new commitment to <code>k2</code> with a new identifier such as <code>2.01</code>. It can then use <code>k2</code> as the secret for the VOPRF operations that it needs to compute.</p>\n<!--kg-card-end: markdown--><h2 id=\"b-example-redemption-api-request\">B. Example Redemption API request</h2><p>The redemption API at is available over HTTPS by sending POST requests to <a href=\"https://privacypass.cloudflare.com/api/redeem\">https://privacypass.cloudflare.com/api/redeem</a>. Requests to this endpoint must specify Privacy Pass data using JSON-RPC 2.0 syntax in the body of the request. Let’s look at an example request:</p><!--kg-card-begin: markdown--><pre><code class=\"language-json\">{\n  &quot;jsonrpc&quot;: &quot;2.0&quot;,\n  &quot;method&quot;: &quot;redeem&quot;,\n  &quot;params&quot;: {\n    &quot;data&quot;: [\n      &quot;lB2ZEtHOK/2auhOySKoxqiHWXYaFlAIbuoHQnlFz57A=&quot;,\n      &quot;EoSetsN0eVt6ztbLcqp4Gt634aV73SDPzezpku6ky5w=&quot;,\n      &quot;eyJjdXJ2ZSI6InAyNTYiLCJoYXNoIjoic2hhMjU2IiwibWV0aG9kIjoic3d1In0=&quot;\n    ],\n    &quot;bindings&quot;: [\n      &quot;string1&quot;,\n      &quot;string2&quot;\n    ],\n    &quot;compressed&quot;:&quot;false&quot;\n  },\n  &quot;id&quot;: 1\n}\n</code></pre>\n<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>In the above: <code>params.data[0]</code> is the client input data used to generate a token in the issuance phase; <code>params.data[1]</code> is the HMAC tag that the server uses to verify a redemption; and <code>params.data[2]</code> is a stringified, base64-encoded JSON object that specifies the hash-to-curve parameters used by the client. For example, the last element in the array corresponds to the object:</p>\n<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code class=\"language-json\">{\n    curve: &quot;p256&quot;,\n    hash: &quot;sha256&quot;,\n    method: &quot;swu&quot;,\n}\n</code></pre>\n<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>Which specifies that the client has used the curve P-256, with hash function SHA-256, and the SSWU method for hashing to curve. This allows the server to verify the transaction with the correct ciphersuite. The client must bind the redemption request to some fixed information, which it stores as multiple strings in the array <code>params.bindings</code>. For example, it could send the Host header of the HTTP request, and the HTTP path that was used (this is what is used in the Privacy Pass browser extension). Finally, <code>params.compressed</code> is an optional boolean value (defaulting to false) that indicates whether the HMAC tag was computed over compressed or uncompressed point encodings.</p>\n<p>Currently the only supported ciphersuites are the example above, or the same except with <code>method</code> equal to <code>increment</code> for the hash-and-increment method of hashing to a curve. This is the original method used in v1.0 of Privacy Pass, and is supported for backwards-compatibility only. See the <a href=\"https://privacypass.github.io/api-redeem\">provided documentation</a> for more details.</p>\n<!--kg-card-end: markdown--><h3 id=\"example-response\">Example response</h3><p>If a request is sent to the redemption API and it is successfully verified, then the following response will be returned.</p><!--kg-card-begin: markdown--><pre><code class=\"language-json\">{\n  &quot;jsonrpc&quot;: &quot;2.0&quot;,\n  &quot;result&quot;: &quot;success&quot;,\n  &quot;id&quot;: 1\n}\n</code></pre>\n<!--kg-card-end: markdown--><p>When an error occurs something similar to the following will be returned.</p><!--kg-card-begin: markdown--><pre><code class=\"language-json\">{\n  &quot;jsonrpc&quot;: &quot;2.0&quot;,\n  &quot;error&quot;: {\n    &quot;message&quot;: &lt;error-message&gt;,\n    &quot;code&quot;: &lt;error-code&gt;,\n  },\n  &quot;id&quot;: 1\n}\n</code></pre>\n<!--kg-card-end: markdown--><p>The error codes that we provide are specified as JSON-RPC 2.0 codes, we document the types of errors that we provide in the <a href=\"https://privacypass.github.io/api-redeem\">API documentation</a>.</p>",
		"comment_id": "5db35c0bfd9e450505d994b1",
		"feature_image": "http://blog.cloudflare.com/content/images/2019/10/Screen-Shot-2019-10-27-at-7.05.21-PM-1.png",
		"featured": false,
		"visibility": "public",
		"created_at": "2019-10-25T21:33:15.000+01:00",
		"updated_at": "2023-10-24T21:00:27.000+01:00",
		"published_at": "2019-10-28T13:00:00.000+00:00",
		"custom_excerpt": "At Cloudflare, we are committed to supporting and developing new privacy-preserving technologies that benefit all Internet users. In November 2017, we announced server-side support for the Privacy Pass protocol, a piece of work developed in collaboration with the academic community.",
		"codeinjection_head": null,
		"codeinjection_foot": null,
		"custom_template": null,
		"canonical_url": null,
		"authors": [
			{
				"id": "5d1644b141acde0011a94fa2",
				"name": "Alex Davidson",
				"slug": "alex-davidson",
				"profile_image": "https://blog-cloudflare-com-assets.storage.googleapis.com/2019/10/pic_of_me.jpg",
				"cover_image": null,
				"bio": null,
				"website": null,
				"location": null,
				"facebook": null,
				"twitter": null,
				"meta_title": null,
				"meta_description": null,
				"url": "http://blog.cloudflare.com/author/alex-davidson/"
			}
		],
		"tags": [
			{
				"id": "5d16450341acde0011a95275",
				"name": "Crypto Week",
				"slug": "crypto-week",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/crypto-week/"
			},
			{
				"id": "5d16450341acde0011a95227",
				"name": "Privacy Pass",
				"slug": "privacy-pass",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/privacy-pass/"
			},
			{
				"id": "5d16450341acde0011a95265",
				"name": "Security",
				"slug": "security",
				"description": null,
				"feature_image": "http://blog.cloudflare.com/content/images/2020/10/Security.png",
				"visibility": "public",
				"meta_title": "Cloudflare Blog: Security",
				"meta_description": "Collection of Cloudflare blog posts tagged 'Security'.",
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/security/"
			},
			{
				"id": "5fce48a395ca4301baec175e",
				"name": "Research",
				"slug": "research",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/research/"
			},
			{
				"id": "5d16450341acde0011a95277",
				"name": "Cryptography",
				"slug": "cryptography",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/cryptography/"
			}
		],
		"primary_author": {
			"id": "5d1644b141acde0011a94fa2",
			"name": "Alex Davidson",
			"slug": "alex-davidson",
			"profile_image": "https://blog-cloudflare-com-assets.storage.googleapis.com/2019/10/pic_of_me.jpg",
			"cover_image": null,
			"bio": null,
			"website": null,
			"location": null,
			"facebook": null,
			"twitter": null,
			"meta_title": null,
			"meta_description": null,
			"url": "http://blog.cloudflare.com/author/alex-davidson/"
		},
		"primary_tag": {
			"id": "5d16450341acde0011a95275",
			"name": "Crypto Week",
			"slug": "crypto-week",
			"description": null,
			"feature_image": null,
			"visibility": "public",
			"meta_title": null,
			"meta_description": null,
			"og_image": null,
			"og_title": null,
			"og_description": null,
			"twitter_image": null,
			"twitter_title": null,
			"twitter_description": null,
			"codeinjection_head": null,
			"codeinjection_foot": null,
			"canonical_url": null,
			"accent_color": null,
			"url": "http://blog.cloudflare.com/tag/crypto-week/"
		},
		"url": "http://blog.cloudflare.com/supporting-the-latest-version-of-the-privacy-pass-protocol/",
		"excerpt": "At Cloudflare, we are committed to supporting and developing new privacy-preserving technologies that benefit all Internet users. In November 2017, we announced server-side support for the Privacy Pass protocol, a piece of work developed in collaboration with the academic community.",
		"reading_time": 19,
		"access": true,
		"comments": false,
		"og_image": null,
		"og_title": null,
		"og_description": null,
		"twitter_image": "https://blog-cloudflare-com-assets.storage.googleapis.com/2020/01/Screen-Shot-2020-01-22-at-3.11.58-PM.png",
		"twitter_title": null,
		"twitter_description": null,
		"meta_title": null,
		"meta_description": null,
		"email_subject": null,
		"frontmatter": null,
		"feature_image_alt": null,
		"feature_image_caption": null
	},
	"locale": "en-us"
}