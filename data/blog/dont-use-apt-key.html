<div class="mb2 gray5">4 min read</div>
<div class="post-content lh-copy gray1">
	<figure class="kg-card kg-image-card ">

		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/2oaXxSl3ccKgOfLLGNL1n3/2df3207c60020356052f2ade105dccb1/image1-79.png" alt="An exposed apt signing key and how to improve apt security" class="kg-image" width="815" height="404" loading="lazy">

	</figure>
	<p>Recently, we received a bug bounty report regarding the GPG signing key used for pkg.cloudflareclient.com, the Linux package repository for our Cloudflare WARP products. The report stated that this private key had been exposed. We’ve since rotated this key and we are taking steps to ensure a similar problem can’t happen again. Before you read on, if you are a Linux user of Cloudflare WARP, please <a href="https://pkg.cloudflareclient.com/install#package-rotation">follow these instructions</a> to rotate the Cloudflare GPG Public Key trusted by your package manager. This only affects WARP users who have installed WARP on Linux. It does not affect Cloudflare customers of any of our other products or WARP users on mobile devices.</p>
	<p>But we also realized that the impact of an improperly secured private key can have consequences that extend beyond the scope of one third-party repository. The remainder of this blog shows how to improve the security of apt with third-party repositories.</p>
	<div class="flex anchor relative">
		<h3 id="the-unexpected-impact">The unexpected impact</h3>
		<a href="https://blog.cloudflare.com/#the-unexpected-impact" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>At first, we thought that the exposed signing key could only be used by an attacker to forge packages distributed through our package repository. However, when reviewing impact for Debian and Ubuntu platforms we found that our instructions were outdated and insecure. In fact, we found the majority of Debian package repositories on the Internet were providing the same poor guidance: download the GPG key from a website and then either pipe it directly into apt-key or copy it into <code>/etc/apt/trusted.gpg.d/</code>. This method adds the key as a trusted root for software installation from <i>any source</i>. To see why this is a problem, we have to understand how apt downloads and verifies software packages.</p>
	<div class="flex anchor relative">
		<h3 id="how-apt-verifies-packages">How apt verifies packages</h3>
		<a href="https://blog.cloudflare.com/#how-apt-verifies-packages" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>In the early days of Linux, package maintainers wanted to make sure users could trust that the software being installed on their machines came from a trusted source.</p>
	<p>Apt has a list of places to pull packages from (sources) and a method to validate those sources (trusted public keys). Historically, the keys were stored in a single keyring file: <code>/etc/apt/trusted.gpg</code>. Later, as third party repositories became more common, apt could also look inside <code>/etc/apt/trusted.gpg.d/</code> for individual key files.</p>
	<p>What happens when you run apt update? First, apt fetches a signed file called InRelease from each source. Some servers supply separate Release and signature files instead, but they serve the same purpose. InRelease is a file containing metadata that can be used to cryptographically validate every package in the repository. Critically, it is also signed by the repository owner’s private key. As part of the update process, apt verifies that the InRelease file has a valid signature, and that the signature was generated by a trusted root. If everything checks out, a local package cache is updated with the repository’s contents. This cache is directly used when installing packages. The chain of signed InRelease files and cryptographic hashes ensures that each downloaded package hasn’t been corrupted or tampered with along the way.</p>
	<figure class="kg-card kg-image-card kg-width-wide">

		<img src="https://cf-assets.www.cloudflare.com/zkvhlag99gkb/1D8XXtbwU25pQ7eViP4FFz/98d53164d30968a85a412e592ce7f391/BLOG-895.png" alt="Graphical diagram of Cloudflare Client repository update. Alt text description: " apt="" update"="" gets="" dists="" focal="" inrelease.="" the="" contents="" of="" inrelease="" are="" shown:="" a="" list="" sha256="" sums="" for="" files="" such="" as="" contents-amd64.gz="" and="" packages.gz,="" followed="" by="" gpg="" signature."="" class="kg-image" width="1325" height="872" loading="lazy">

	</figure>
	<div class="flex anchor relative">
		<h3 id="a-typical-third-party-repository-today">A typical third-party repository today</h3>
		<a href="https://blog.cloudflare.com/#a-typical-third-party-repository-today" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>For most Ubuntu/Debian users today, this is what adding a third-party repository looks like in practice:</p>
	<ol>
		<li>
			<p>Add a file in <code>/etc/apt/sources.list.d/</code> telling apt where to look for packages.</p>
		</li>
		<li>
			<p>Add the gpg public key to <code>/etc/apt/trusted.gpg.d/</code>, probably via apt-key.</p>
		</li>
	</ol>
	<p>If apt-key is used in the second step, the command typically pops up a deprecation warning, telling you not to use apt-key. There’s a good reason: adding a key like this trusts it for any repository, not just the source from step one. This means if the private key associated with this new source is compromised, attackers can use it to bypass apt’s signature verification and install their own packages.</p>
	<p>What would this type of attack look like? Assume you’ve got a stock Debian setup with a default sources list<sup>1</sup>:</p>
	<pre class="language-bash"><code class="language-bash">deb http://deb.debian.org/debian/ bullseye main non-free contrib
deb http://security.debian.org/debian-security bullseye-security main contrib non-free</code></pre>
	<p>At some point you installed a trusted key that was later exposed, and the attacker has the private key. This key was added alongside a source pointing at https, assuming that even if the key is broken an attacker would have to break TLS encryption as well to install software via that route.</p>
	<p>You’re enjoying a hot drink at your local cafe, where someone nefarious has managed to hack the router without your knowledge. They’re able to intercept http traffic and modify it without your knowledge. An auto-update script on your laptop runs <code>apt update</code>. The attacker pretends to be deb.debian.org, and because at least one source is configured to use http, the attacker doesn’t need to break https. They return a modified InRelease file signed with the compromised key, indicating that a newer update of the bash package is available. apt pulls the new package (again from the attacker) and installs it, as root. Now you’ve got a big problem<sup>2</sup>.</p>
	<div class="flex anchor relative">
		<h3 id="a-better-way">A better way</h3>
		<a href="https://blog.cloudflare.com/#a-better-way" aria-hidden="true" class="relative sm:absolute sm:-left-5">
			<svg width="16" height="16" viewBox="0 0 24 24">
				<path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path>
			</svg>
		</a>
	</div>
	<p>It seems the way most folks are told to set up third-party Debian repositories is wrong. What if you could tell apt to <a href="https://wiki.debian.org/DebianRepository/UseThirdParty">only trust that GPG key for a specific source</a>? That, combined with the use of https, would significantly reduce the impact of a key compromise. As it turns out, there’s a way to do that! You’ll need to do two things:</p>
	<ol>
		<li>
			<p>Make sure the key isn’t in <code>/etc/apt/trusted.gpg</code> or <code>/etc/apt/trusted.gpg.d/</code> anymore. If the key is its own file, the easiest way to do this is to move it to <code>/usr/share/keyrings/</code>. Make sure the file is owned by root, and only root can write to it. This step is important, because it prevents apt from using this key to check all repositories in the sources list.</p>
		</li>
		<li>
			<p>Modify the sources file in <code>/etc/apt/sources.list.d/</code> telling apt that this particular repository can be “signed by” a specific key. When you’re done, the line should look like this:</p>
		</li>
	</ol>
	<pre class="language-bash"><code class="language-bash">deb [signed-by=/usr/share/keyrings/cloudflare-client.gpg] https://pkg.cloudflareclient.com/ bullseye main</code></pre>
	<p>Some source lists contain other metadata indicating that the source is only valid for certain architectures. If that’s the case, just add a space in the middle, like so:</p>
	<pre class="language-bash"><code class="language-bash">deb [amd64 signed-by=/usr/share/keyrings/cloudflare-client.gpg] https://pkg.cloudflareclient.com/ bullseye main</code></pre>
	<p>We’ve updated the instructions on our own repositories for the <a href="https://pkg.cloudflareclient.com">WARP Client</a> and <a href="https://pkg.cloudflare.com">Cloudflare</a> with this information, and we hope others will follow suit.</p>
	<p>If you run <code>apt-key list</code> on your own machine, you’ll probably find several keys that are trusted far more than they should be. Now you know how to fix them!</p>
	<p>For those running your own repository, now is a great time to review your installation instructions. If your instructions tell users to curl a public key file and pipe it straight into sudo apt-key, maybe there’s a safer way. While you’re in there, ensuring the package repository supports https is a great way to add an extra layer of security (and if you host your traffic via Cloudflare, <a href="https://www.cloudflare.com/ssl">it’s easy to set up, and free</a>. You can follow <a href="https://blog.cloudflare.com/cloudflare-repositories-ftw">this blog post</a> to learn how to properly configure Cloudflare to cache Debian packages).</p>
	<hr>
	<p><sup>1</sup>RPM-based distros like Fedora, CentOS, and RHEL also use a common trusted GPG store to validate packages, but since they generally use https by default to fetch updates they aren’t vulnerable to this particular attack.</p>
	<p><sup>2</sup>The attack described above requires an active on-path network attacker. If you are using the WARP client or Cloudflare for Teams to tunnel your traffic to Cloudflare, your network traffic cannot be tampered with on local networks.</p>
</div>