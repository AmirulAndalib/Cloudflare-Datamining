<div class="post-content lh-copy gray1">
	<figure class="kg-card kg-image-card kg-width-wide"><img src="https://blog.cloudflare.com/content/images/2019/10/Privacy-Pass-@2x-2.png" class="kg-image" alt="" loading="lazy"></figure>
	<p>Bei Cloudflare unterstützen und entwickeln wir Datenschutztechnologien, von denen alle Internetnutzer profitieren. Im November 2017 haben wir die serverseitige Unterstützung für das <a href="https://blog.cloudflare.com/cloudflare-supports-privacy-pass">Privacy-Pass-Protokoll</a> bekanntgegeben. Diese Entwicklung erfolgte in <a href="https://petsymposium.org/2018/files/papers/issue3/popets-2018-0026.pdf" target="_blank">Zusammenarbeit mit der akademischen Community</a>. Einfach ausgedrückt, kann ein Client mit Privacy Pass seine Vertrauenswürdigkeit nachweisen, <a href="https://privacypass.github.io/protocol" target="_blank">ohne offenzulegen, wo und wann dieser Beweis erbracht wurde</a>. Ziel des Protokolls ist letztlich, dass jeder Nutzer beweisen kann, dass ein Server ihm vertraut, ohne dass der Server den Nutzer über den zugewiesenen Vertrauensbeweis zurückverfolgen kann.</p>
	<p>Technisch gesehen funktioniert das so: Privacy-Pass-Clients bekommen Bestätigungstoken von einem Server, die dann später eingelöst werden können. Diese Token werden zur Verfügung gestellt, wenn ein Server den Client als vertrauenswürdig erachtet. Das kann zum Beispiel der Fall sein, wenn er sich bei einem Dienst angemeldet oder bestimmte Merkmale nachgewiesen hat. Die eingelösten Token können kryptographisch nicht mit der ursprünglich vom Server bereitgestellten Bestätigung verknüpft werden. Sie verraten also nichts über den Client.</p>
	<figure class="kg-card kg-image-card kg-width-wide"><img src="https://blog.cloudflare.com/content/images/2019/10/imageLikeEmbed--2-.png" class="kg-image" alt="" loading="lazy"></figure>
	<figure class="kg-card kg-image-card"><img src="https://blog.cloudflare.com/content/images/2019/10/imageLikeEmbed--1-.png" class="kg-image" alt="" loading="lazy"></figure>
	<p>Für den Privacy Pass kann auf einem Client eine <a href="https://github.com/privacypass/challenge-bypass-extension" target="_blank">Open-Source</a>-Browsererweiterung installiert werden, die es für <a href="https://chrome.google.com/webstore/detail/privacy-pass/ajhmfdgkijocedmfjonnpjfojldioehi?hl=en" target="_blank">Chrome</a> und <a href="https://addons.mozilla.org/en-US/firefox/addon/privacy-pass" target="_blank">Firefox</a> gibt. Weltweit wurde der Privacy Pass schon über 150.000 Mal heruntergeladen, davon etwa 130.000 Mal die Chrome-Version und über 20.000 Mal die Firefox-Version. Die Erweiterung wird von Cloudflare unterstützt, um Websites für Nutzer besser zugänglich zu machen. Sie ergänzt frühere Entwicklungen, zum Beispiel <a href="https://blog.cloudflare.com/cloudflare-onion-service">Cloudflares Onion-Dienste</a> für bessere Zugänglichkeit für Nutzer mit dem Tor-Browser.</p>
	<p>Die erste Veröffentlichung liegt fast zwei Jahre zurück. Danach folgte eine <a href="https://petsymposium.org/2018/files/papers/issue3/popets-2018-0026.pdf" target="_blank">Forschungspublikation</a>, die auf dem <a href="https://www.youtube.com/watch?v=9DsUi-UF2pM&amp;list=PLWSQygNuIsPd6YJmGV9kn1mP2A6-IBCoU&amp;index=10" target="_blank">Privacy Enhancing Technologies Symposium 2018</a> vorgestellt wurde (und dort den Best Student Paper Award erhielt). Seitdem arbeitet Cloudflare mit der Community daran, den Privacy Pass auf der Grundlage des ursprünglichen Designs zu verbessern. Wir werden darüber sprechen, welche Arbeit wir neben dem eigentlichen Protokoll in die Weiterentwicklung der vorhandenen Implementierungen gesteckt haben.</p>
	<h1 id="was-ist-neu"><strong>Was ist neu?</strong></h1>
	<p>Unterstützung für die Browsererweiterung Privacy Pass v2.0:</p>
	<ul>
		<li>Einfachere Workflow-Konfiguration.</li>
		<li>Integration eines neuen Dienstleisters (hCaptcha).</li>
		<li>Konformität mit dem Hash-to-Curve-Entwurf.</li>
		<li>Möglichkeit der Schlüsselrotation außerhalb der Erweiterungsversion.</li>
		<li>Verfügbar in <a href="https://chrome.google.com/webstore/detail/privacy-pass/ajhmfdgkijocedmfjonnpjfojldioehi?hl=en" target="_blank">Chrome</a> und <a href="https://addons.mozilla.org/en-US/firefox/addon/privacy-pass" target="_blank">Firefox</a> (funktioniert mit den neuesten Browser-Versionen am besten).</li>
	</ul>
	<p>Einführung eines neuen Server-Backends auf der Plattform Cloudflare Workers:</p>
	<ul>
		<li>Ausführung kryptografischer Operationen mit der internen V8-Engine.</li>
		<li>Bereitstellung einer öffentlichen API zur Einlösung der Token für Cloudflare Privacy Pass v2.0.</li>
		<li>Verfügbar über POST-Anfragen an <a href="https://privacypass.cloudflare.com/api/redeem" target="_blank">https://privacypass.cloudflare.com/api/redeem</a>. Für <a href="https://privacypass.github.io/api-redeem" target="_blank">Anwendungsbeispiele</a> siehe Dokumentation.</li>
		<li>Nur kompatibel mit der Version 2.0 der Erweiterung (prüfen Sie, ob Sie das Update haben!).</li>
	</ul>
	<p>Standardisierung:</p>
	<ul>
		<li>Weiterentwicklung des <a href="https://datatracker.ietf.org/doc/draft-irtf-cfrg-voprf" target="_blank">Entwurfs</a> für oblivious pseudorandom functions (OPRFs, „vergessliche Pseudozufallsfunktionen“) in Prime-Order-Gruppen mit CFRG@IRTF.</li>
		<li><a href="https://github.com/alxdavids/draft-privacy-pass" target="_blank">Neuer Entwurf</a> der Spezifikation des Privacy-Pass-Protokolls.</li>
	</ul>
	<h1 id="erweiterung-v2-0"><strong>Erweiterung v2.0</strong></h1>
	<p>Seit der letzten Version haben wir an einer Reihe neuer Funktionen gearbeitet. Heute können wir stolz bekanntgeben, dass Version 2.0 der Erweiterung unterstützt wird – das erste Update seit der ursprünglichen Version. Die Erweiterung ist weiterhin für <a href="https://chrome.google.com/webstore/detail/privacy-pass/ajhmfdgkijocedmfjonnpjfojldioehi?hl=en" target="_blank">Chrome</a> und <a href="https://addons.mozilla.org/en-US/firefox/addon/privacy-pass" target="_blank">Firefox</a>verfügbar. Möglicherweise müssen Sie die Version 2.0 manuell aus dem Store herunterladen, wenn Sie die automatischen Updates in Ihrem Browser deaktiviert haben.</p>
	<p>Die Erweiterung wird weiterhin aktiv entwickelt und die Unterstützung ist immer noch in der Beta-Phase. Dies wird vorerst auch so bleiben, denn der Entwurf der Protokollspezifikation wird in Zusammenarbeit mit der Community fortgeschrieben.</p>
	<figure class="kg-card kg-image-card kg-width-wide"><img src="https://blog.cloudflare.com/content/images/2019/10/pasted-image-0-2.png" class="kg-image" alt="" loading="lazy"></figure>
	<h3 id="neue-integrationen"><strong>Neue Integrationen</strong></h3>
	<p>Die Client-Implementierung nutzt die <a href="https://developer.chrome.com/extensions/webRequest" target="_blank">WebRequest API</a> zur Suche nach bestimmten Typen von HTTP-Anfragen. Solche Anfragen werden umgeschrieben und um einige kryptografische Daten ergänzt, die für das Privacy-Pass-Protokoll erforderlich sind. Dadurch können Privacy-Pass-Anbieter, die diese Daten erhalten, den Zugriff für den Nutzer autorisieren.</p>
	<p>Nehmen wir an, ein Nutzer erhält Privacy-Pass-Token für einige Sicherheitsprüfungen auf dem Server. Diese Token werden von der Browsererweiterung gespeichert, und jede zukünftige Anfrage, für die eine ähnliche Sicherheitsfreigabe notwendig ist, kann mit einen zusätzlichen HTTP-Header mit einem gespeicherten Token ergänzt werden. Der Server kann dann anhand des Client-Tokens überprüfen, ob der Client die richtige Berechtigung besitzt.</p>
	<figure class="kg-card kg-image-card kg-width-wide"><img src="https://blog.cloudflare.com/content/images/2019/10/imageLikeEmbed--4-.png" class="kg-image" alt="" loading="lazy"></figure>
	<p>Cloudflare unterstützt zwar einen bestimmten Typ von Anfrageabläufen, man kann jedoch unmöglich erwarten, dass sich verschiedene Dienstanbieter genau an die gleichen Interaktionsmerkmale halten. Eine der wichtigsten Änderungen in der Erweiterungsversion 2.0 war eine technische Änderung dahingehend, dass nun eine zentrale Konfigurationsdatei verwendet wird. Die Konfiguration ist im <a href="https://github.com/privacypass/challenge-bypass-extension/blob/master/src/ext/config.js" target="_blank">Quellcode</a> der Erweiterung spezifiziert. Mit ihr können Browsereigenschaften, die Privacy-Pass-Aktionen auslösen, einfacher modifiziert werden. So können neue, völlig unterschiedliche Anfrageabläufe aufgenommen werden. Dazu wird die Konfiguration für einen neuen Anbieter einfach geklont und angepasst.</p>
	<p>Um zu zeigen, dass solche Integrationen jetzt auch mit anderen Diensten als Cloudflare möglich sind, wird bald eine neue Erweiterungsversion ausgeliefert, die vom CAPTCHA-Anbieter <a href="https://www.hcaptcha.com" target="_blank">hCaptcha</a> unterstützt wird. Nutzer, die von hCaptcha bereitgestellte Aufgaben lösen, bekommen private Token, die auf Websites anderer hCaptcha-Kunden eingelöst werden können.</p>
	<figure class="kg-card kg-image-card"><img src="https://blog.cloudflare.com/content/images/2019/10/image-8-1.png" class="kg-image" alt="" loading="lazy"></figure><!--kg-card-begin: markdown-->
	<p><span style="color:grey"><small><em>„Schwerpunkt bei hCaptcha ist die Privatsphäre der Nutzer. Dass wir Privacy Pass unterstützen, ist für uns in diesem Bereich eine natürliche Ergänzung. Wir freuen uns darauf, es in Zusammenarbeit mit Cloudflare und anderen auf breiter Basis als Standard zu etablieren, und prüfen derzeit weitere Anwendungsmöglichkeiten. Es war relativ einfach, Privacy Pass in unserem weltweit verteilten Dienst zu implementieren. Die gemeinsame Arbeit mit dem Cloudflare-Team an der Verbesserung der Open-Source-Browsererweiterung für Chrome hat uns Freude gemacht, und unsere Nutzer werden davon profitieren.“</em></small></span></p>
	<p>— <strong>Eli-Shaoul Khedouri</strong>, Gründer von hCaptcha</p>
	<!--kg-card-end: markdown-->
	<p>Die Integration von hCaptcha in die Privacy-Pass-Browsererweiterung dient als Proof-of-Concept für weitere neue Dienste und deren Unterstützung. Neue Anbieter, die ebenfalls eine Integration in die Privacy-Pass-Browsererweiterung anstreben, können hierfür einfach ein Pull Request an das <a href="https://github.com/privacypass/challenge-bypass-extension" target="_blank">Open-Source-Repository</a> richten.</p>
	<h2 id="verbesserte-kryptografische-funktionalit-t"><strong>Verbesserte kryptografische Funktionalität</strong></h2>
	<p>Bei der Freigabe der Erweiterungsversion 1.0 waren bestimmte Funktionen noch nicht implementiert. Dazu gehörte die ordnungsgemäße Validierung des Zero-Knowledge-Beweises zur Feststellung, ob der Server immer denselben festgelegten Schlüssel verwendet. In der Version 2.0 ist diese Funktionalität enthalten. Dadurch wird in überprüfbarer Form verhindert, dass ein böswilliger Server Nutzer durch Einsatz verschiedener Schlüssel für jede Anfrage deanonymisieren kann.</p>
	<p>Die für Privacy Pass erforderlichen kryptografischen Operationen werden mit <a href="https://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography">elliptischer Kurvenkryptografie</a> (elliptic curve cryptography, ECC) ausgeführt. In der Erweiterung wird derzeit die Kurve <a href="https://www.secg.org/SEC2-Ver-1.0.pdf" target="_blank">NIST P-256</a> eingesetzt, für die wir noch einige Optimierungen aufgenommen haben. Erstens können wir dadurch Kurvenpunkte einer Ellipse in komprimierten und unkomprimierten Datenformaten speichern. Der Speicherbedarf des Browsers kann dadurch um 50 % reduziert und auch die Serverantworten können verkleinert werden.</p>
	<figure class="kg-card kg-image-card kg-width-wide"><img src="https://blog.cloudflare.com/content/images/2019/10/imageLikeEmbed--5-.png" class="kg-image" alt="" loading="lazy"></figure>
	<p>Zweitens wurde die Hashwertberechnung auf der P-256-Kurve mit der sogenannten „Simplified Shallue-van de Woestijne-Ulas“-Methode (SSWU) eingebaut. Sie ist in einem noch laufenden Entwurf (<a href="https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-03" target="_blank">https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-03</a>) zur Standardisierung von Codierungen für die Hashwertberechnung auf elliptischen Kurven spezifiziert. Die Implementierung ist konform mit der Spezifikation der Chiffriersuite „P256-SHA256-SSWU-“ in diesem Entwurf.</p>
	<p>Diese Änderungen haben gleich zwei Vorteile. Erstens ist die Spezifikation der P-256-Hashwertberechnung auf der Kurve konform mit der Spezifikation im Entwurf. Zweitens sind durch diese Chiffriersuite probabilistische Methoden wie <a href="https://tools.ietf.org/html/draft-irtf-cfrg-vrf-05#section-5.4.1.1" target="_blank">Hash-and-Increment</a> nicht mehr erforderlich. Die Hash-and-Increment-Methode ist mit einer nicht nur geringfügigen Fehlerwahrscheinlichkeit verbunden, und die Laufzeit ist stark von der versteckten Clienteingabe abhängig. Es ist zwar nicht klar, wie man Timing-Angriffsvektoren derzeit missbrauchen könnte, aber durch die SSWU-Methode wird die Implementierung weniger angreifbar und die Clienteingabe ist nicht so leicht zu ermitteln.</p>
	<h2 id="schl-sselrotation"><strong>Schlüsselrotation</strong></h2>
	<p>Wie oben erwähnt, muss überprüft werden, ob der Server immer denselben Schlüssel verwendet, damit die Privatsphäre des Clients gewährleistet werden kann. Dadurch wird sichergestellt, dass der Server die Nutzerbasis nicht aufteilen und die Privatsphäre des Clients beeinträchtigen kann, indem er für jeden Client, mit dem er interagiert, unterschiedliche geheime Schlüssel verwendet. Der Server gibt an einem für den Client zugänglichen Ort ein sogenanntes Commitment für einen öffentlichen Schlüssel bekannt und garantiert so, dass er immer denselben Schlüssel verwendet.</p>
	<p>Jedes Mal, wenn der Server Privacy-Pass-Token an den Client ausgibt, erzeugt er auch einen <a href="https://en.wikipedia.org/wiki/Zero-knowledge_proof" target="_blank">Zero-Knowledge-Beweis</a> dafür, dass er diese Token mit dem richtigen Schlüssel erstellt hat.</p>
	<figure class="kg-card kg-image-card"><img src="https://blog.cloudflare.com/content/images/2019/10/imageLikeEmbed--6-.png" class="kg-image" alt="" loading="lazy"></figure>
	<p>Bevor die Erweiterung Token speichert, überprüft sie zunächst den Beweis anhand des bekannten Schlüssel-Commitments. Zuvor wurden diese Commitments direkt im Quellcode der Erweiterung gespeichert. Das führte dazu, dass eine neue Erweiterungsversion herausgegeben werden musste, wenn der Schlüssel eines Servers rotiert werden sollte, eine unnötige Komplikation. Die Erweiterung wurde so geändert, dass die Commitments an einem <a href="https://github.com/privacypass/ec-commitments" target="_blank">vertrauenswürdigen Speicherort</a> gespeichert werden, auf den der Client zugreifen kann, wenn er die Serverantwort überprüfen muss. Derzeit handelt es sich bei diesem Speicherort um ein separates <a href="https://github.com/privacypass/ec-commitments" target="_blank">GitHub-Repository</a> für Privacy Pass. Für Interessierte haben wir eine ausführlichere Beschreibung des neuen Commitment-Formats in Anhang A am Ende dieses Beitrags bereitgestellt.</p>
	<figure class="kg-card kg-image-card kg-width-wide"><img src="https://blog.cloudflare.com/content/images/2019/10/imageLikeEmbed--7-.png" class="kg-image" alt="" loading="lazy"></figure>
	<h1 id="implementierung-der-serverseitigen-unterst-tzung-in-workers"><strong>Implementierung der serverseitigen Unterstützung in Workers</strong></h1>
	<p>Bisher haben wir uns auf clientseitige Updates konzentriert. Im Rahmen der Erweiterungsversion 2.0 führen wir einige wichtige Änderungen an der serverseitigen Unterstützung durch, die Cloudflare verwendet. Für Version 1.0 haben wir eine <a href="https://github.com/privacypass/challenge-bypass-server" target="_blank">Go-Implementierung</a> des Servers verwendet. In Version 2.0 führen wir eine neue Serverimplementierung ein, die in der Plattform <a href="https://www.cloudflare.com/products/cloudflare-workers" target="_blank">Cloudflare Workers</a> ausgeführt wird. Diese Serverimplementierung ist nur mit v2.0-Releases des Privacy Pass kompatibel, sodass Sie möglicherweise Ihre Erweiterung aktualisieren müssen, wenn Sie automatische Updates in Ihrem Browser deaktiviert haben.</p>
	<p>Unser Server wird unter <a href="https://privacypass.cloudflare.com" target="_blank">https://privacypass.cloudflare.com</a> ausgeführt werden, und alle Privacy-Pass-Anfragen an die Cloudflare-Edge werden von Worker-Skripts verarbeitet, die auf dieser Domain ausgeführt werden. Unsere Implementierung wurde in JavaScript neu geschrieben, wobei die kryptografischen Operationen in der <a href="https://v8.dev" target="_blank">V8-Engine</a> ausgeführt werden, auf der auch Cloudflare Workers betrieben wird. Dies bedeutet, dass wir hocheffiziente und zeitlich konstante kryptografische Operationen durchführen können. Darüber hinaus profitieren wir von der verbesserten Leistung durch die Ausführung unseres Codes in der Workers-Plattform, also so nah wie möglich am Nutzer.</p>
	<h2 id="webcrypto-unterst-tzung"><strong>WebCrypto-Unterstützung</strong></h2>
	<p>Nun fragen Sie sich vielleicht, wie wir es schaffen, kryptografische Operationen in Cloudflare Workers zu implementieren. Derzeit werden kryptografische Vorgänge in der Workers-Plattform über die <a href="https://developers.cloudflare.com/workers/reference/apis/web-crypto" target="_blank">WebCrypto-API</a> unterstützt. Mit dieser API kann man Berechnungen für kryptografisches Hashing ebenso durchführen wie kompliziertere Vorgänge, etwa ECDSA-Signaturen.</p>
	<p>Wie wir unten erläutern, werden im Privacy-Pass-Protokoll die wichtigsten kryptografischen Operationen von einem Protokoll ausgeführt, das als überprüfbare vergessliche Pseudozufallsfunktion (verifiable oblivious pseudorandom function, VOPRF) bezeichnet wird. Mit so einem Protokoll kann ein Client von einem Server berechnete Funktionsausgaben erhalten, ohne dem Server die eigentliche Eingabe zu verraten. Dass es „überprüfbar“ ist, bedeutet, dass der Server außerdem (in einer öffentlich überprüfbaren Weise) nachweisen muss, dass die an den Nutzer übergebene Berechnung korrekt ist. Eine solche Funktion ist pseudozufällig, denn die Serverausgabe ist nicht von einer zufälligen Folge von Byte zu unterscheiden.</p>
	<figure class="kg-card kg-image-card kg-width-wide"><img src="https://blog.cloudflare.com/content/images/2019/10/imageLikeEmbed--8-.png" class="kg-image" alt="" loading="lazy"></figure>
	<p>Für die VOPRF-Funktionalität muss ein Server ECC-Operationen auf niedriger Ebene ausführen, die derzeit nicht in der WebCrypto-API verfügbar gemacht werden. Wir haben die Möglichkeiten abgewogen, diese Bedingung zu umgehen. Zuerst haben wir versucht, die WebCrypto-API in einer nicht standardmäßigen Weise zu verwenden. Dazu haben wir EC-Diffie-Hellman-Schlüsselaustausch als Methode für die benötigte skalare Multiplikation verwendet. Wir haben auch versucht, alle Operationen in reinem JavaScript zu implementieren. Leider waren beide Methoden unbefriedigend. Entweder hätten sie eine Integration in große externe Kryptografiebibliotheken bedeutet oder sie wären für eine performante Internetumgebung viel zu langsam.</p>
	<p>Letztendlich haben wir uns für eine Lösung entschieden, bei der die Funktionen für Privacy Pass in die interne WebCrypto-Schnittstelle der Cloudflare-V8-Javascript-Engine aufgenommen werden.. Dieser Algorithmus imitiert die Sign/Verify-Schnittstelle, die von Signaturalgorithmen wie ECDSA bereitgestellt wird. Kurz gesagt, wir verwenden die Funktion sign(), um Privacy-Pass-Token an den Client auszugeben. Mit verify() wiederum kann der Server Daten überprüfen, die vom Client eingelöst werden. Diese Funktionen werden direkt in der V8-Schicht implementiert und sind daher wesentlich leistungsfähiger und sicherer (z. B. zeitlich konstant) als reines JavaScript.</p>
	<p>Die WebCrypto-Schnittstelle in Privacy Pass ist derzeit nicht für die öffentliche Nutzung verfügbar. Wenn sich herausstellt, dass es genügend Interesse an diesem zusätzlichen Algorithmus in der Workers-Plattform gibt, machen wir ihn möglicherweise öffentlich.</p>
	<h3 id="anwendungen"><strong>Anwendungen</strong></h3>
	<p>In jüngster Zeit haben sich VOPRFs als sehr nützliches Primitiv für viele kryptografische Werkzeuge erwiesen. Neben dem Privacy Pass sind sie auch für die Erstellung von mit Passwort authentifizierten Schlüsselaustauschprotokollen wie <a href="https://datatracker.ietf.org/doc/draft-krawczyk-cfrg-opaque" target="_blank">OPAQUE</a> unerlässlich. Sie wurden auch bei der Entwicklung <a href="https://eprint.iacr.org/2016/799" target="_blank">privater Schnittmengen</a>, <a href="https://eprint.iacr.org/2014/650" target="_blank">passwortgeschützter Protokolle mit gemeinsamem Schlüssel</a> und <a href="https://medium.com/least-authority/the-path-from-s4-to-privatestorage-ae9d4a10b2ae" target="_blank">datenschutzerhaltender Zugriffskontrolle</a> für private Datenspeicherung verwendet.</p>
	<h2 id="-ffentliche-einl-se-api"><strong>Öffentliche Einlöse-API</strong></h2>
	<p>Den Server in Cloudflare Workers zu schreiben bedeutet, dass wir die serverseitige Unterstützung für Privacy Pass auf einer <a href="https://privacypass.cloudflare.com" target="_blank">öffentlichen Domain</a> bereitstellen! Wir geben Token zwar nur an Clients aus, wenn wir sicher sind, dass wir ihnen vertrauen können, aber mit unserer öffentlichen Einlöse-API kann jeder diese Token bei <a href="https://privacypass.cloudflare.com/api/redeem" target="_blank">https://privacypass.cloudflare.com/api/redeem</a> einlösen. Wenn wir die serverseitige Komponente weltweit eingeführt haben, können Sie mit dieser API Privacy-Pass-Token von Cloudflare <a href="https://privacypass.github.io/api-redeem" target="_blank">unabhängig von der Browsererweiterung</a> überprüfen.</p>
	<figure class="kg-card kg-image-card kg-width-wide"><img src="https://blog.cloudflare.com/content/images/2019/10/imageLikeEmbed--9-.png" class="kg-image" alt="" loading="lazy"></figure>
	<p>Jeder Dienst kann also von Cloudflare ausgestellte Privacy-Pass-Token von einem Client akzeptieren und sie dann mit der Einlöse-API von Cloudflare überprüfen. Mit dem von der API zurückgegebenen Ergebnis können externe Dienste überprüfen, ob Cloudflare den Nutzer in der Vergangenheit autorisiert hat.</p>
	<p>Wir glauben, dass andere Dienstanbieter davon profitieren werden, denn sie können die Autorisierungsbestätigung von Cloudflare in ihren eigenen Entscheidungsprozessen nutzen, ohne irgendwelche Kompromisse bei der Privatsphäre des Clients zu machen. Wir hoffen, dass dieses Ökosystem weiter wachsen wird und mehr Dienste mit eigenen öffentlichen Einlöse-APIs entstehen. Wenn die Vielfalt bei den Ausstellern zunimmt, nimmt auch der Nutzen dieser Bestätigungen zu.</p>
	<p>Dadurch, dass unser Server auf einer öffentlichen Domain läuft, sind wir praktisch selbst Kunde des Cloudflare-Workers-Produkts. Somit können auch wir <a href="https://developers.cloudflare.com/workers/reference/storage" target="_blank">Workers KV</a> zum Schutz vor böswilligen Clients nutzen. Insbesondere muss ein Server überprüfen, ob ein Client während der Einlösungsphase ein Token wiederverwendet. Die Performance, die Workers KV bei der Analyse von Lesevorgängen bietet, macht es zur ersten Wahl für den globalen Schutz vor Doppelnutzung.</p>
	<p>Wenn Sie die öffentliche Einlöse-API verwenden möchten, finden Sie unsere Dokumentation dafür unter <a href="https://privacypass.github.io/api-redeem" target="_blank">https://privacypass.github.io/api-redeem</a>. In Anhang B am Ende dieses Beitrags finden Sie außerdem einige Beispiele für Anfragen und Antworten.</p>
	<h1 id="standardisierung-und-neue-anwendungen"><strong>Standardisierung und neue Anwendungen</strong></h1>
	<p>Parallel zu unseren jüngsten Entwicklungsarbeiten zur Unterstützung des Privacy Pass haben wir mit gemeinsam mit der Community versucht, die <a href="https://datatracker.ietf.org/doc/draft-irtf-cfrg-voprf" target="_blank">zugrundeliegende VOPRF-Funktionalität</a> und auch das <a href="https://github.com/alxdavids/draft-privacy-pass" target="_blank">Protokoll selbst</a> zu standardisieren. Die Standardisierung für vergessliche Pseudozufallsfunktionen (OPRFs) ist nun seit über einem Jahr im Gang, aber die jüngsten Bemühungen, das Privacy-Pass-Protokoll zu standardisieren, gehen auf ganz neue Anwendungen zurück, die in den letzten Monaten entstanden sind.</p>
	<p>Die Standardisierung von Protokollen und Funktionen ist eine wichtige Möglichkeit, interoperable, sichere und leistungsstarke Schnittstellen für die Ausführung von Protokollen im Internet zu schaffen. So können Entwickler leichter eigene Implementierungen dieser komplexen Funktionalität schreiben. Zu diesem Prozess gehören auch hilfreiche Peer Reviews von Experten in der Community, durch die potenzielle Sicherheitsrisiken besser zutage treten, die bei jeder Implementierung entschärft werden sollten. Außerdem hat er den Vorteil, dass man sich auf die zuverlässigsten, skalierbarsten und leistungsfähigsten Protokollentwürfe für alle möglichen Anwendungen einigen kann.</p>
	<h2 id="vergessliche-pseudozufallsfunktionen"><strong>Vergessliche Pseudozufallsfunktionen</strong></h2>
	<p>Vergessliche Pseudozufallsfunktionen (oblivious pseudorandom functions, OPRFs) sind eine Verallgemeinerung von VOPRFs, bei denen der Server nicht nachweisen muss, dass er die Funktionalität ordnungsgemäß ausgewertet hat. Seit Juli 2019 arbeiten wir gemeinsam mit der <a href="https://irtf.org/cfrg" target="_blank">Crypto Forum Research Group</a> (CFRG) der Internet Research Task Force (IRTF) <a href="https://datatracker.ietf.org/doc/draft-irtf-cfrg-voprf" target="_blank">an einem Entwurf</a> zur Standardisierung eines OPRF-Protokolls, das in Prime-Order-Gruppen arbeitet. Dies ist eine Verallgemeinerung der Fassung mit <a href="https://blog.cloudflare.com/tag/elliptic-curves">elliptischen Kurven</a>. Es ist die gleiche VOPRF-Konstruktion, die <a href="https://blog.cloudflare.com/privacy-pass-the-math">ursprünglich durch das Privacy-Pass-Protokoll spezifiziert</a> wurde. Sie beruht vor allem auf dem ursprünglichen Protokollentwurf aus der <a href="https://eprint.iacr.org/2014/650.pdf" target="_blank">Abhandlung von Jarecki, Kiayias und Krawczyk</a>.</p>
	<p>Eine unserer jüngsten Änderungen des Entwurfs besteht darin, den Schlüssel zu vergrößern, den wir für die Durchführung von OPRF-Operationen auf der Serverseite benutzen möchten. Untersuchungen legen nahe, dass man spezifische Abfragen erstellen kann, durch die kleine Anteile des Schlüssels „durchsickern“ können. Bei Schlüsseln mit nur 128 Bit Sicherheit kann dies ein Problem sein, denn wenn zu viele Bits durchsickern, nimmt die Sicherheit <a href="https://www.keylength.com/en/4" target="_blank">auf ein derzeit nicht mehr akzeptables Niveau ab</a>. Um dem entgegenzuwirken, haben wir die Mindestschlüsselgröße effektiv auf 192 Bit erhöht. Dadurch kann dieses Durchsickern nicht mit praktikablen Methoden zu einem Angriffsvektor gemacht werden. Wir besprechen diese Angriffe später ausführlicher, wenn es um unsere zukünftigen VOPRF-Entwicklungspläne geht.</p>
	<h2 id="aktuelle-anwendungen-und-standardisierung-des-protokolls"><strong>Aktuelle Anwendungen und Standardisierung des Protokolls</strong></h2>
	<p>Die Anwendung, die wir bei der ursprünglichen Privacy-Pass-Unterstützung demonstriert haben, war immer als Proof-of-Concept für das Protokoll gedacht. In den letzten Monaten sind viele neue Möglichkeiten entstanden, die weit über das hinausgehen, was bisher angedacht war.</p>
	<figure class="kg-card kg-image-card kg-width-wide"><img src="https://blog.cloudflare.com/content/images/2019/10/imageLikeEmbed--10-.png" class="kg-image" alt="" loading="lazy"></figure>
	<p>So wurde zum Beispiel die von der <a href="https://wicg.io" target="_blank">Web Incubator Community Group</a> entwickelte <a href="https://github.com/WICG/trust-token-api" target="_blank">Trust Token API</a> als Schnittstelle für die Verwendung von Privacy Pass vorgeschlagen. Mit diesen Anwendungen können Drittanbieter bei einer Reihe zentraler Aussteller überprüfen, ob ein Nutzer eine Vertrauensbestätigung erhalten hat. So kann der Anbieter die Ehrlichkeit eines Clients beurteilen, ohne ein Verhaltensprofil mit der Identität des Nutzers verknüpfen zu müssen. Ziel ist es, betrügerische Aktivitäten von Nutzern zu verhindern, denen die Gruppe der zentralen Aussteller nicht vertraut. Mit ähnlichen Einlöse-APIs, <a href="https://privacypass.cloudflare.com" target="_blank">wie wir sie vorgestellt haben</a>, könnte man Vertrauensbestätigungen bei zentralen Ausstellern überprüfen.</p>
	<p>In einer <a href="https://engineering.fb.com/security/partially-blind-signatures" target="_blank">separaten Arbeit von Facebook</a> wird eine ähnliche Anwendung zur Verhinderung betrügerischen Verhaltens vorgestellt, die auch mit dem Privacy-Pass-Protokoll kompatibel sein könnte. Außerdem sind weitere Anwendungen in den Bereichen Zugang zu <a href="https://medium.com/least-authority/the-path-from-s4-to-privatestorage-ae9d4a10b2ae" target="_blank">privatem Speicher</a> und <a href="https://github.com/brave/brave-browser/wiki/Security-and-privacy-model-for-ad-confirmations" target="_blank">Sicherheits- und Datenschutzmodelle in Werbebestätigungen</a> entstanden.</p>
	<h3 id="ein-neuer-entwurf"><strong>Ein neuer Entwurf</strong></h3>
	<p>Unter Berücksichtigung der oben genannten Anwendungen haben wir vor Kurzem mit der Gemeinschaftsarbeit an einem <a href="https://github.com/alxdavids/draft-privacy-pass" target="_blank">neuen IETF-Entwurf</a> begonnen, in dem insbesondere die erforderliche Funktionalität des Privacy-Pass-Protokolls als Ganzes festgelegt wird. Unser Ziel ist es, zusammen mit Partnern aus der erweiterten Branche und der akademischen Gemeinschaft eine funktionierende Spezifikation des Privacy-Pass-Protokolls zu entwickeln. Wir hoffen, so ein Grundlagenprotokoll entwerfen zu können, das dann als kryptografisches Primitiv in breiteren Anwendungen verwendet werden kann, für die eine Art einfache Autorisierung benötigt wird. Wir haben vor, die erste Version dieses Entwurfs im nächsten Monat beim <a href="https://www.ietf.org/how/meetings/106" target="_blank">IETF-Meeting 106</a> in Singapur vorzulegen.</p>
	<p>Der Entwurf befindet sich noch am Anfang seiner Entwicklung und wir suchen aktiv nach Personen, die diese Protokollspezifikation mitgestalten möchten. Wir sind für jede Hilfe bei diesem Prozess dankbar. Im <a href="https://github.com/alxdavids/draft-privacy-pass" target="_blank">GitHub-Repository</a> finden Sie die aktuelle Version des Dokuments.</p>
	<h1 id="marschrichtungen-f-r-die-zukunft"><strong>Marschrichtungen für die Zukunft</strong></h1>
	<p>Während wir aktiv an einer Reihe verschiedener Wege arbeiten, sind die zukünftigen Richtungen für das Projekt noch offen. Wir glauben, dass es viele Anwendungen gibt, die wir noch nicht in Betracht gezogen haben, und wir sind gespannt, wo das Protokoll in Zukunft verwendet wird. Hier einige weitere Ideen für neuartige Anwendungen und Sicherheitseigenschaften, die wir für die Zukunft für sinnvoll halten.</p>
	<h2 id="-ffentlich-berpr-fbare-token"><strong>Öffentlich überprüfbare Token</strong></h2>
	<p>Eine VOPRF hat den Nachteil, dass Einlösetoken nur vom ursprünglichen Ausgabeserver überprüft werden können. Wenn wir ein Primitiv als Grundlage verwenden würden, mit dem Einlösetoken öffentlich verifiziert werden könnten, konnte jeder überprüfen, ob das jeweilige Token vom ausstellenden Server stammt. Ein solches Protokoll könnte zusätzlich zu sogenannten blinden Signaturschemata wie <a href="https://en.wikipedia.org/wiki/Blind_signature#Blind_RSA_signatures" target="_blank">Blind RSA</a> entwickelt werden. Leider gibt es Leistungs- und Sicherheitsbedenken bei der Verwendung blinder Signaturschemata in einer Browserumgebung. Vorhandene Schemata (insbesondere RSA-basierte Varianten) erfordern kryptografische Berechnungen, die viel schwergewichtiger sind als die Konstruktion in unserem VOPRF-Protokoll.</p>
	<h2 id="post-quanten-alternativen-zu-voprf"><strong>Post-Quanten-Alternativen zu VOPRF</strong></h2>
	<p>Die bisherigen VOPRF-Konstrukte existieren in Prä-Quanten-Umgebungen, in der Regel basierend auf dem Schwierigkeitsgrad bekannter Probleme in Gruppenumgebungen wie der <a href="https://en.wikipedia.org/wiki/Decisional_Diffie%E2%80%93Hellman_assumption" target="_blank">Annahme zum diskreten Logarithmus</a>. Es sind keine VOPRF-Konstrukte bekannt, die Sicherheit gegen Gegner bieten, die <a href="https://blog.cloudflare.com/the-quantum-menace">Algorithmen auf Quantencomputern</a> ausführen können. Dies bedeutet, dass das Privacy-Pass-Protokoll nur gegen Gegner als sicher gelten kann, die klassische Hardware einsetzen.</p>
	<p>Jüngste Entwicklungen deuten darauf hin, dass Quantencomputer <a href="https://www.nature.com/articles/s41586-019-1666-5" target="_blank">früher kommen könnten, als bisher angenommen</a>. Daher glauben wir, dass es für uns und die ganze Community sehr wichtig ist, <a href="https://blog.cloudflare.com/introducing-circl">praktische Post-Quanten-Alternativen</a> für unser aktuelles kryptografisches Toolkit zu entwickeln. In diesem Fall wäre die Entwicklung performanter Post-Quanten-Alternativen für VOPRF-Konstrukte ein wichtiger theoretischer Fortschritt. So bekämen wir ein Privacy-Pass-Protokoll, das auch in einer Post-Quanten-Welt eine die Privatsphäre schützende Autorisierung bieten kann.</p>
	<h2 id="voprf-sicherheit-und-gr-ere-chiffriersuiten"><strong>VOPRF-Sicherheit und größere Chiffriersuiten</strong></h2>
	<p>Wir haben bereits erwähnt, dass VOPRFs (oder einfach OPRFs) anfällig sind, wenn schon geringe Schlüsselanteile durchsickern. Hier beschreiben wir in aller Kürze die tatsächlichen Angriffe und unsere Pläne zur Implementierung von Chiffriersuiten mit höherer Sicherheit und weniger Lecks.</p>
	<p>Insbesondere können böswillige Clients durch Interaktion mit einer VOPRF eine sogenannte <a href="https://eprint.iacr.org/2010/215.pdf" target="_blank">Diffie-Hellman-Stichprobe der Stärke q</a> (q-sDH) erzeugen. Solche Stichproben werden in mathematischen Gruppen erstellt (normalerweise in der elliptischen Kurvenumgebung). Für jede Gruppe gibt es ein öffentliches Element g, das für alle Operationen des <a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange" target="_blank">Diffie-Hellman</a>-Typs von zentraler Bedeutung ist, außerdem den Serverschlüssel K, der normalerweise nur als zufällig generierte Zahl aus dieser Gruppe interpretiert wird. Eine q-sDH-Stichprobe hat folgende Form:</p>
	<p>( g, g^K, g^(K^2), … , g^(K^q) )<br></p>
	<p>und verlangt vom böswilligen Gegner, ein Elementepaar zu erstellen, das (g^(1/(s+K)),s) entspricht. Ein Client könnte im VOPRF-Protokoll dadurch eine q-SDH-Stichprobe erstellen, dass er das Ergebnis der vorherigen VOPRF-Berechnung einfach an den Server zurücksendet.</p>
	<p>Dieses Problem gilt zwar als schwer zu knacken, aber aus mehreren vergangenen Arbeiten geht hervor, dass das Problem etwas einfacher lösbar ist, als man aufgrund der Größe der Gruppe annehmen würde (siehe z. B. <a href="https://eprint.iacr.org/2004/306" target="_blank">hier</a> und <a href="https://www.iacr.org/archive/eurocrypt2006/40040001/40040001.pdf" target="_blank">hier</a>). Konkret ausgedrückt kann die von der Gruppe implizierte Bitsicherheit um bis zu 2(q) Bit reduziert werden. Das ist zwar nicht sofort fatal, auch nicht für Gruppen mit 128 Bit Sicherheit, aber es kann zu einem Verlust an Sicherheit führen. Dieses Verfahren ist also nicht mehr zukunftssicher. Bei Gruppen, die VOPRF-Funktionalität bereitstellen und mithilfe einer elliptischen Kurve wie P-256 oder Curve25519 instanziiert werden, fällt die Sicherheit also geringer aus als eigentlich garantiert.</p>
	<p>Vor diesem Hintergrund haben wir jüngst beschlossen, standardmäßig nur noch Chiffriersuiten mit mehr als 128 Bit Sicherheit für die OPRF-Nutzung zu empfehlen. Curve448 bietet beispielsweise 192 Bit Sicherheit. Für einen Angriff, der die Sicherheit auf weniger als 128 Bit reduziert, müssten vom Client 2^(68) OPRF-Abfragen ausgeführt werden. Das ist eine erhebliche Zugangsbarriere für jeden Angreifer, deshalb betrachten wir diese Chiffriersuiten für die Instanziierung der OPRF-Funktionalität als sicher.</p>
	<p>In naher Zukunft müssen die in unserer Unterstützung der Privacy-Pass-Browsererweiterung verwendeten Chiffriersuiten auf den Stand der Empfehlungen des aktuellen VOPRF-Entwurfs gebracht werden. Wir hoffen, dass die Privacy-Pass-Implementierung durch einen stärker iterativen Freigabeprozess besser mit dem aktuellen Standardentwurf und seiner Weiterentwicklung während des Standardisierungsprozesses mithalten kann.</p>
	<h2 id="ausprobieren-"><strong>Ausprobieren!</strong></h2>
	<p>Sie können Version 2.0 der Privacy-Pass-Erweiterung jetzt in <a href="https://chrome.google.com/webstore/detail/privacy-pass/ajhmfdgkijocedmfjonnpjfojldioehi?hl=en" target="_blank">Chrome</a> oder <a href="https://addons.mozilla.org/en-US/firefox/addon/privacy-pass" target="_blank">Firefox</a> installieren.</p>
	<p>Wenn Sie zur Entwicklung dieser Erweiterung beitragen möchten, können Sie dies auf <a href="https://github.com/privacypass/challenge-bypass-extension" target="_blank">GitHub</a> tun. Sind Sie selbst Dienstanbieter und möchten serverseitige Unterstützung für die Erweiterung integrieren? Dann wären wir sehr daran interessiert, von Ihnen zu hören!</p>
	<p>Wir werden bei der Standardisierung des Protokolls weiter mit der Community zusammenarbeiten. Die schon entwickelten und verfügbaren Anwendungen sind uns Motivation genug. Wir sind immer auf der Suche nach neuen Anwendungen, mit denen das Privacy-Pass-Ökosystem über seine aktuellen Grenzen hinaus ausgeweitet werden kann.</p>
	<figure class="kg-card kg-image-card"><img src="https://blog.cloudflare.com/content/images/2019/10/tales-from-the-crypto-team@2x--1-.png" class="kg-image" alt="" loading="lazy"></figure>
	<h1 id="anhang"><strong>Anhang</strong></h1>
	<p>Hier einige zusätzliche Details zu den oben behandelten Themen.</p>
	<h2 id="a-commitment-format-f-r-schl-sselrotationen"><strong>A. Commitment-Format für Schlüsselrotationen</strong></h2>
	<p>Schlüssel-Commitments sind notwendig, damit der Server im Rahmen des Privacy-Pass-Protokolls beweisen kann, dass er ehrlich handelt. Die von Privacy Pass in der Version 2.0 verwendeten Commitments haben ein etwas anderes Format als in der vorherigen Version.</p><!--kg-card-begin: markdown-->
	<pre><code class="language-json">"2.00": {
  "H": "BPivZ+bqrAZzBHZtROY72/E4UGVKAanNoHL1Oteg25oTPRUkrYeVcYGfkOr425NzWOTLRfmB8cgnlUfAeN2Ikmg=",
  "expiry": "2020-01-11T10:29:10.658286752Z",
  "sig": "MEUCIQDu9xeF1q89bQuIMtGm0g8KS2srOPv+4hHjMWNVzJ92kAIgYrDKNkg3GRs9Jq5bkE/4mM7/QZInAVvwmIyg6lQZGE0="
}
</code></pre>
	<!--kg-card-end: markdown-->
	<p>Die Version des Serverschlüssels ist zunächst 2.00. Der Server muss den Client darüber informieren, welche Version er in der Antwort auf einen Client verwenden möchte, die ausgestellte Token enthält. Dies wird deshalb so gemacht, damit der Client zur Prüfung des Zero-Knowledge-Beweises vom Server immer die richtigen Commitments verwenden kann.</p>
	<p>Der Wert des Attributs H ist das öffentliche Schlüssel-Commitment für den vom Server verwendeten geheimen Schlüssel. Dies ist, codiert in base64, ein elliptischer Kurvenpunkt der Form H=kG, wobei G der feste Generator der Kurve und k der geheime Schlüssel des Servers ist. Da man annimmt, dass das diskrete Logarithmusproblem schwer zu lösen ist, gilt es als schwierig, k von H abzuleiten. Der Wert des Attributs expiry ist ein Ablaufdatum für das verwendete Commitment. Der Wert des Attributs sig ist eine ECDSA-Signatur. Sie wird mit einem Langzeitsignaturschlüssel, der mit dem Server verknüpft ist, und über die Werte von H und expiry berechnet.</p>
	<p>Wenn ein Client das Commitment abruft, überprüft er, ob es nicht abgelaufen ist und ob die Signatur mithilfe des entsprechenden Überprüfungsschlüssels bestätigt werden kann, der in die Konfiguration der Erweiterung eingebettet ist. Wenn diese Prüfungen erfolgreich sind, ruft er H ab und überprüft die vom Server gesendete Antwort mit der Ausstellung. Frühere Versionen dieser Commitments enthielten keine Signaturen, aber ab Version 2.0 werden diese Signaturen validiert.</p>
	<p>Wenn ein Server den Schlüssel rotieren möchte, generiert er einfach einen neuen Schlüssel k2 und fügt ein neues Commitment für k2 mit einem neuen Bezeichner wie 2.01 an. Er kann k2 dann als geheimen Schlüssel für die VOPRF-Operationen verwenden, die er berechnen muss.</p>
	<h2 id="b-beispiel-f-r-eine-anfrage-an-die-einl-se-api"><strong>B. Beispiel für eine Anfrage an die Einlöse-API</strong></h2>
	<p>Die Einlöse-API ist über HTTPS verfügbar. Man sendet dazu POST-Anfragen an <a href="https://privacypass.cloudflare.com/api/redeem" target="_blank">https://privacypass.cloudflare.com/api/redeem</a>. Bei Anfragen an diesen Endpunkt müssen die Privacy-Pass-Daten mithilfe der JSON-RPC-2.0-Syntax im Hauptteil angegeben werden. Beispiel für eine solche Anfrage:</p><!--kg-card-begin: markdown-->
	<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "method": "redeem",
  "params": {
    "data": [
      "lB2ZEtHOK/2auhOySKoxqiHWXYaFlAIbuoHQnlFz57A=",
      "EoSetsN0eVt6ztbLcqp4Gt634aV73SDPzezpku6ky5w=",
      "eyJjdXJ2ZSI6InAyNTYiLCJoYXNoIjoic2hhMjU2IiwibWV0aG9kIjoic3d1In0="
    ],
    "bindings": [
      "string1",
      "string2"
    ],
    "compressed":"false"
  },
  "id": 1
}
</code></pre>
	<!--kg-card-end: markdown-->
	<p>Erläuterung: params.data[0] sind die Client-Eingabedaten, die in der Ausstellungsphase zum Generieren eines Tokens verwendet werden; params.data[1] ist das HMAC-Tag, mit dem der Server eine Einlösung überprüft; params.data[2] ist ein JSON-Objekt, als Zeichenfolge codiert im base64-Format, das die vom Client verwendeten Hash-to-Curve-Parameter angibt. Das letzte Element des Arrays entspricht beispielsweise folgendem Objekt:</p><!--kg-card-begin: markdown-->
	<pre><code class="language-json">{
    curve: "p256",
    hash: "sha256",
    method: "swu",
}
</code></pre>
	<!--kg-card-end: markdown-->
	<p>Dieses Objekt gibt an, dass der Client die Kurve P-256 mit der Hashfunktion SHA-256 und die SSWU-Methode zum Hashing auf der Kurve verwendet hat. Dadurch kann der Server die Transaktion mit der richtigen Chiffriersuite überprüfen. Der Client muss die Einlöseanfrage an einige feste Informationen binden, die als mehrere Zeichenfolgen im Array params.bindings gespeichert werden. Beispielsweise könnte der Host-Header der HTTP-Anfrage und der verwendete HTTP-Pfad gesendet werden (dies wird in der Browsererweiterung für den Privacy Pass verwendet). params.compressed schließlich ist ein optionaler boolescher Wert (Standardeinstellung „false“), der angibt, ob das HMAC-Tag über komprimierte oder unkomprimierte Punktcodierungen berechnet wurde.</p>
	<p>Die einzigen unterstützten Chiffriersuiten sind derzeit das obige Beispiel sowie das gleiche mit „method“ gleich „increment“ für die Hash-and-Increment-Methode des Hashings auf einer Kurve. Dies ist die ursprüngliche Methode, die in Version 1.0 des Privacy Pass verwendet wird; sie wird nur zur Abwärtskompatibilität unterstützt. Weitere Informationen finden Sie in der <a href="https://privacypass.github.io/api-redeem" target="_blank">bereitgestellten Dokumentation</a>.</p>
	<h3 id="beispielantwort"><strong>Beispielantwort</strong></h3>
	<p>Wenn eine Anfrage an die Einlöse-API gesendet und erfolgreich überprüft wurde, wird folgende Antwort zurückgegeben.</p><!--kg-card-begin: markdown-->
	<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "result": "success",
  "id": 1
}
</code></pre>
	<!--kg-card-end: markdown-->
	<p>Wenn ein Fehler auftritt, sieht die Rückgabe ungefähr so aus:</p><!--kg-card-begin: markdown-->
	<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "error": {
    "message": &lt;error-message&gt;,
    "code": &lt;error-code&gt;,
  },
  "id": 1
}
</code></pre>
	<!--kg-card-end: markdown-->
	<p>Die von uns bereitgestellten Fehlercodes werden als JSON-RPC-2.0-Codes angegeben. Die Fehlertypen, die wir verwenden, sind in der <a href="https://privacypass.github.io/api-redeem" target="_blank">API-Dokumentation</a> dokumentiert.</p>
</div>