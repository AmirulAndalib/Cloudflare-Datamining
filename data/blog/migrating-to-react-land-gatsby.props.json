{
	"locale": "en-us",
	"post": {
		"access": true,
		"authors": [
			{
				"id": "5d1644b141acde0011a94fc8",
				"name": "Victoria Bernard",
				"slug": "victoria",
				"profile_image": "http://blog.cloudflare.com/content/images/2018/04/UOeuJDMRxejfddFMXFvl_1204a20b3d1d96bba523a6a2a5fa3cd73bd4fe59240a27ad6eb8c064c6792446.jpg",
				"cover_image": "http://blog.cloudflare.com/content/images/2018/08/general@2x-130.png",
				"bio": null,
				"website": null,
				"location": null,
				"facebook": null,
				"twitter": null,
				"meta_title": null,
				"meta_description": null,
				"url": "http://blog.cloudflare.com/author/victoria/"
			}
		],
		"canonical_url": null,
		"codeinjection_foot": null,
		"codeinjection_head": null,
		"comment_id": "5e7b2ee042df4b01bd4fcf2f",
		"comments": false,
		"created_at": "2020-03-25T10:13:52.000+00:00",
		"custom_excerpt": "As our developer documentation grows so does the need for tooling. Let’s walk through how we migrated our documentation site to Gatsby to take full advantage of static generation and React. ",
		"custom_template": null,
		"email_subject": null,
		"excerpt": "As our developer documentation grows so does the need for tooling. Let’s walk through how we migrated our documentation site to Gatsby to take full advantage of static generation and React. ",
		"feature_image": "http://blog.cloudflare.com/content/images/2020/03/workers-site-migration-@2x.png",
		"feature_image_alt": null,
		"feature_image_caption": null,
		"featured": false,
		"frontmatter": null,
		"html": "<figure class=\"kg-card kg-image-card\"><img src=\"http://blog.cloudflare.com/content/images/2020/03/workers-site-migration-@2x-1.png\" class=\"kg-image\" alt loading=\"lazy\"></figure><p>I am an engineer that loves docs. Well, OK, I don’t love all docs but I believe docs are a crucial, yet often neglected element to a great developer experience. I work on the developer experience team for Cloudflare Workers focusing on several components of Workers, particularly on the docs that we recently migrated to Gatsby.</p><figure class=\"kg-card kg-embed-card\"><blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">? We’ve moved the Cloudflare Workers docs to <a href=\"https://twitter.com/gatsbyjs?ref_src=twsrc%5Etfw\">@gatsbyjs</a><br><br>The new documentation is...<br><br>?‍♀️ faster<br>⭐️ more accessible<br>? a perfect foundation for the redesign later this year<br>?️ open-source<br><br>shout out to <a href=\"https://twitter.com/exvuma?ref_src=twsrc%5Etfw\">@exvuma</a> for this incredible work ??<a href=\"https://t.co/k3huvCvash\">https://t.co/k3huvCvash</a> <a href=\"https://t.co/MBWxVtlrin\">pic.twitter.com/MBWxVtlrin</a></p>&mdash; Cloudflare Developers (@CloudflareDev) <a href=\"https://twitter.com/CloudflareDev/status/1235265069283504128?ref_src=twsrc%5Etfw\">March 4, 2020</a></blockquote>\n<script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n</figure><!--kg-card-begin: markdown--><p>Through porting our documentation site to Gatsby I learned a lot. In this post, I share some of the learnings that could’ve saved my former self from several headaches. This will hopefully help others considering a move to Gatsby or another static site generator.</p>\n<h2 id=\"whygatsby\">Why Gatsby?</h2>\n<p>Prior to our migration to Gatsby, we used Hugo for our <a href=\"https://developers.cloudflare.com/workers\">developer documentation</a>. There are a lot of positives about working with Hugo - fast build times, fast load times - that made building a simple static site a great use case for Hugo. Things started to turn sour when we started making our docs more interactive and expanding the content being generated.</p>\n<p>Going from writing JSX with TypeScript back to string-based templating languages is difficult. Trying to perform complicated tasks, like generating a sidebar, cost me  - a developer who knows nothing about liquid code or Go templating (though with Golang experience) - several tears not even to implement but to just understand what was happening.</p>\n<p>Here is the code to template an item in the sidebar in Hugo:</p>\n<pre><code class=\"language-html\">&lt;!-- templates --&gt;\n{{ define &quot;section-tree-nav&quot; }}\n{{ $currentNode := .currentnode }}\n{{ with .sect }}\n {{ if not .Params.Hidden }}\n  {{ if .IsSection }}\n    {{safeHTML .Params.head}}\n    &lt;li data-nav-id=&quot;{{.URL}}&quot; class=&quot;dd-item\n        {{ if .IsAncestor $currentNode }}parent{{ end }}\n        {{ if eq .UniqueID $currentNode.UniqueID}}active{{ end }}\n        {{ if .Params.alwaysopen}}parent{{ end }}\n        {{ if .Params.alwaysopen}}always-open{{ end }}\n        &quot;&gt;\n      &lt;a href=&quot;{{ .RelPermalink}}&quot;&gt;\n        &lt;span&gt;{{safeHTML .Params.Pre}}{{.Title}}{{safeHTML .Params.Post}}&lt;/span&gt;\n \n        {{ if .Params.new }}\n          &lt;span class=&quot;new-badge&quot;&gt;NEW&lt;/span&gt;\n        {{ end }}\n \n        {{ $numberOfPages := (add (len .Pages) (len .Sections)) }}\n        {{ if ne $numberOfPages 0 }}\n \n          {{ if or (.IsAncestor $currentNode) (.Params.alwaysopen)  }}\n            &lt;i class=&quot;triangle-up&quot;&gt;&lt;/i&gt;\n          {{ else }}\n            &lt;i class=&quot;triangle-down&quot;&gt;&lt;/i&gt;\n          {{ end }}\n \n        {{ end }}\n      &lt;/a&gt;\n      {{ if ne $numberOfPages 0 }}\n        &lt;ul&gt;\n          {{ .Scratch.Set &quot;pages&quot; .Pages }}\n          {{ if .Sections}}\n          {{ .Scratch.Set &quot;pages&quot; (.Pages | union .Sections) }}\n          {{ end }}\n          {{ $pages := (.Scratch.Get &quot;pages&quot;) }}\n \n        {{ if eq .Site.Params.ordersectionsby &quot;title&quot; }}\n          {{ range $pages.ByTitle }}\n            {{ if and .Params.hidden (not $.showhidden) }}\n            {{ else }}\n            {{ template &quot;section-tree-nav&quot; dict &quot;sect&quot; . &quot;currentnode&quot; $currentNode }}\n            {{ end }}\n          {{ end }}\n        {{ else }}\n          {{ range $pages.ByWeight }}\n            {{ if and .Params.hidden (not $.showhidden) }}\n            {{ else }}\n            {{ template &quot;section-tree-nav&quot; dict &quot;sect&quot; . &quot;currentnode&quot; $currentNode }}\n            {{ end }}\n          {{ end }}\n        {{ end }}\n        &lt;/ul&gt;\n      {{ end }}\n    &lt;/li&gt;\n  {{ else }}\n    {{ if not .Params.Hidden }}\n      &lt;li data-nav-id=&quot;{{.URL}}&quot; class=&quot;dd-item\n     {{ if eq .UniqueID $currentNode.UniqueID}}active{{ end }}\n      &quot;&gt;\n        &lt;a href=&quot;{{.RelPermalink}}&quot;&gt;\n        &lt;span&gt;{{safeHTML .Params.Pre}}{{.Title}}{{safeHTML .Params.Post}}&lt;/span&gt;\n        {{ if .Params.new }}\n          &lt;span class=&quot;new-badge&quot;&gt;NEW&lt;/span&gt;\n        {{ end }}\n \n        &lt;/a&gt;&lt;/li&gt;\n     {{ end }}\n  {{ end }}\n {{ end }}\n{{ end }}\n{{ end }}\n</code></pre>\n<p>Whoa. I may be exceptionally oblivious, but I had to squint at the snippet above for an hour before I realized this was the code for a sidebar item (the <code>li</code> element was the eventual giveaway, but took some parsing to discover where the logic actually started).</p>\n<p>(Disclaimer: I am in no way a pro at Hugo and in any situation there are always several ways to code a solution; thus I am in no way claiming this was the only way to write the template nor am I chastising the author of the code. I am just displaying the differences in pieces of code I came across)</p>\n<p>Now, here is what the TSX (I will get into the JS later in the article) for the Gatsby project using the exact same styling would look like:</p>\n<pre><code class=\"language-jsx\"> &lt;li data-nav-id={pathToServe} className={'dd-item ' + ddClass}&gt;\n   &lt;Link className=&quot;&quot; to={pathToServe} title=&quot;Docs Home&quot; activeClassName=&quot;active&quot;&gt;\n     {title || 'No title'}\n     {numberOfPages ? &lt;Triangle isAncestor={isAncestor} alwaysopen={showChildren} /&gt; : ''}\n     {showNew ? &lt;span className=&quot;new-badge&quot;&gt;NEW&lt;/span&gt; : ''}\n   &lt;/Link&gt;\n   {showChildren ? (\n     &lt;ul&gt;\n       {' '}\n       {myChildren.map((child: mdx) =&gt; {\n         return (\n           &lt;SidebarLi\n             frontmatter={child.frontmatter}\n             fields={child.fields}\n             depth={++depth}\n             key={child.frontmatter.title}\n           /&gt;\n         )\n       })}\n     &lt;/ul&gt;\n   ) : (\n     ''\n   )}\n &lt;/li&gt;\n</code></pre>\n<p>This code is clean and compact because Gatsby is a static content generation tool based on React. It’s loved for a myriad of reasons, but my honest main reason to migrate to it was to make the Hugo code above much less ugly.</p>\n<p>For our purposes, less ugly was important because we had dreams of redesigning our docs to be interactive with support for multiple coding languages and other features.</p>\n<p>For example, the <a href=\"https://developers.cloudflare.com/workers/templates\">template gallery</a> would be a place to go to for how-to recipes and examples. The templates themselves would live in a template registry service and turn into static pages via an API.</p>\n<p>We wanted the docs to not be constrained by Go templating. The <a href=\"https://gohugo.io/templates/introduction/\">Hugo docs</a> admit their templates aren’t the best for complicated logic:</p>\n<blockquote>\n<p>Go Templates provide an extremely simple template language that adheres to the belief that only the most basic of logic belongs in the template or view layer.</p>\n</blockquote>\n<p>Gatsby and React enable the more complex logic we were looking for. After our team built <a href=\"https://workers.cloudflare.com/\">workers.cloudflare.com</a> and <a href=\"https://workers.cloudflare.com/built-with\">Built with Workers </a> on Gatsby, I figured this was my shot to really give Gatsby a try on our Workers developer docs.</p>\n<h3 id=\"decisiontomigrateoverstartingfromscratch\">Decision to Migrate over Starting from Scratch</h3>\n<p>I’m normally not a fan of fixing things that aren’t broken. Though I didn’t like working with Hugo, did love working in React, and had all the reasons to. I was timid about being the one in charge of switching from Hugo. I was scared. I hated looking at the liquid code of Go templates. I didn’t want to have to port all the existing templates to React without truly understanding what I might be missing.</p>\n<p>There comes a point with tech debt though where you have to tackle the tech debt you are most scared of.</p>\n<p>The easiest solution would be of course to throw the Hugo code away. Start from scratch. A clean slate. But this means taking something that was not broken and breaking it. The styling, SEO, tagging, and analytics of the site took small iterations over the course of a few years to get right and I didn’t want to be the one to break them. Instead of throwing all the styling and logic tied in for search, SEO, etc..., our plan was to maintain as much of the current design and logic as possible while converting it to React piece-by-piece, component-by-component.</p>\n<p>Also there were existing developer docs still using Hugo on Cloudflare by other teams (e.g. Access, Argo Tunnel, etc...). I wanted a team at Cloudflare to be able to import their existing markdown files with frontmatter into the Gatsby repo and preserve the existing design.</p>\n<p>I wanted to migrate instead of teleport to Gatsby.</p>\n<h2 id=\"howtohugotogatsby\">How-to: Hugo to Gatsby</h2>\n<p>In this blog post, I go through some but not all of the steps of how I ported to Gatsby from Hugo for our complex doc site. The few examples here help to convey the issues that caused the most pain.</p>\n<p>Let’s start with getting the markdown files to turn into HTML pages.</p>\n<h3 id=\"markdown\">Markdown</h3>\n<p>One goal was to keep all the existing markdown and frontmatter we had set up in Hugo as similar as possible. The reasoning for this was to not break existing content and also maintain the version history of each doc.</p>\n<p>Gatsby is built on top of GraphQL. All the data and most all content for Gatsby is put into GraphQL during startup likely via a plugin, then Gatsby will query for this data upon actual page creation. This is quite different from Hugo’s much more abstract model of putting all your content in a folder named <code>content</code> and then Hugo figures out which template to apply based on the logic in the template.</p>\n<p>MDX is a sophisticated tool that parses markdown into Gatsby so it can later be represented as HTML (it actually can do much more than that but, I won’t get into it here). I started with Gatsby’s MDX plugin to create nodes from my markdown files. Here is the code to set up the plugin to get all the markdown files (files ending in .md and .mdx)  I had in the <code>src/content</code> folder into GraphQL:</p>\n<p><code>gatsby-config.js</code></p>\n<pre><code class=\"language-js\">const path = require('path')\n \nmodule.exports = {\n plugins: [\n   {\n     resolve: `gatsby-source-filesystem`,\n     options: {\n       name: `mdx-pages`,\n       path: `${__dirname}/src/content`,\n       ignore: [`**/CONTRIBUTING*`, '/styles/**'],\n     },\n   },\n   {\n     resolve: `gatsby-plugin-mdx`,\n     options: {\n       extensions: [`.mdx`, `.md`],\n     },\n   }, \n]}\n</code></pre>\n<p>Now that Gatsby knows about these files as nodes, we can create pages for them. In <code>gatsby-node.js</code>, I tell Gatsby to grab these MDX pages and use a template <code>markdownTemplate.tsx</code> to create pages for them:</p>\n<pre><code class=\"language-js\">const path = require(`path`)\nconst { createFilePath } = require(`gatsby-source-filesystem`)\nexports.createPages = async ({ actions, GraphQL, reporter }) =&gt; {\n const { createPage } = actions\n \n const markdownTemplate = path.resolve(`src/templates/markdownTemplate.tsx`)\n \n result = await GraphQL(`\n   {\n     allMdx(limit: 1000) {\n       edges {\n         node {\n           fields {\n             pathToServe\n           }\n           frontmatter {\n             alwaysopen\n             weight\n           }\n           fileAbsolutePath\n         }\n       }\n     }\n   }\n `)\n // Handle errors\n if (result.errors) {\n   reporter.panicOnBuild(`Error while running GraphQL query.`)\n   return\n }\n result.data.allMdx.edges.forEach(({ node }) =&gt; {\n   return createPage({\n     path: node.fields.pathToServe,\n     component: markdownTemplate,\n     context: {\n       parent: node.fields.parent,\n       weight: node.frontmatter.weight,\n     }, // additional data can be passed via context, can use as variable on query\n   })\n })\n}\nexports.onCreateNode = ({ node, getNode, actions }) =&gt; {\n const { createNodeField } = actions\n // Ensures we are processing only markdown files\n if (node.internal.type === 'Mdx') {\n   // Use `createFilePath` to turn markdown files in our `content` directory into `/workers/`pathToServe\n   const originalPath = node.fileAbsolutePath.replace(\n     node.fileAbsolutePath.match(/.*content/)[0],\n     ''\n   )\n   let pathToServe = createFilePath({\n     node,\n     getNode,\n     basePath: 'content/',\n   })\n   let parentDir = path.dirname(pathToServe)\n   if (pathToServe.includes('index')) {\n     pathToServe = parentDir\n     parentDir = path.dirname(parentDir) // &quot;/&quot; dirname will = &quot;/&quot;\n   }\n   pathToServe = pathToServe.replace(/\\/+$/, '/') // always end the path with a slash\n   // Creates new query'able field with name of 'pathToServe', 'parent'..\n   // for allMdx edge nodes\n   createNodeField({\n     node,\n     name: 'pathToServe',\n     value: `/workers${pathToServe}`,\n   })\n   createNodeField({\n     node,\n     name: 'parent',\n     value: parentDir,\n   })\n   createNodeField({\n     node,\n     name: 'filePath',\n     value: originalPath,\n   })\n }\n}\n</code></pre>\n<p>Now every time Gatsby runs, it starts running through each node on <code>onCreateNode</code>. If the node is MDX, it passes the node’s content (the markdown, <code>fileAbsolutePath</code>, etc.) and all the node fields (<code>filePath</code>, <code>parent</code> and <code>pathToServe</code>) to the <code>markdownTemplate.tsx</code> component so that the component can render the appropriate information for that markdown file.</p>\n<p>The barebone component for a page that renders a React component from the MDX node looks like this:</p>\n<p><code>markdownTemplate.tsx</code></p>\n<pre><code class=\"language-js\">import React from &quot;react&quot;\nimport { graphql } from &quot;gatsby&quot;\nimport { MDXRenderer } from &quot;gatsby-plugin-mdx&quot;\n \nexport default function PageTemplate({ data: { mdx } }) {\n return (\n   &lt;div&gt;\n     &lt;h1&gt;{mdx.frontmatter.title}&lt;/h1&gt;\n     &lt;MDXRenderer&gt;{mdx.body}&lt;/MDXRenderer&gt;\n   &lt;/div&gt;\n )\n}\n \nexport const pageQuery = graphql`\n query BlogPostQuery($id: String) {\n   mdx(id: { eq: $id }) {\n     id\n     body\n     frontmatter {\n       title\n     }\n   }\n }\n`\n</code></pre>\n<h3 id=\"acomplexcomponentsidebar\">A Complex Component: Sidebar</h3>\n<p>Now let’s get into where I wasted the most time, but learned hard lessons upfront: turning the Hugo template into a React component. At the beginning of this article, I showed that scary sidebar.</p>\n<p>To set up the <code>li</code> element we had the Hugo logic looks like:</p>\n<pre><code class=\"language-html\">{{ define &quot;section-tree-nav&quot; }}\n{{ $currentNode := .currentnode }}\n{{ with .sect }}\n {{ if not .Params.Hidden }}\n  {{ if .IsSection }}\n    {{safeHTML .Params.head}}\n    &lt;li data-nav-id=&quot;{{.URL}}&quot; class=&quot;dd-item\n        {{ if .IsAncestor $currentNode }}parent{{ end }}\n        {{ if eq .UniqueID $currentNode.UniqueID}}active{{ end }}\n        {{ if .Params.alwaysopen}}parent{{ end }}\n        {{ if .Params.alwaysopen}}always-open{{ end }}\n        &quot;&gt;\n</code></pre>\n<p>I see that the code is defining some <code>section-tree-nav</code> component-like thing and taking in some <code>currentNode</code>. To be honest, I still don’t know exactly what the variables <code>.sect</code>, <code>IsSection</code>, <code>Params.head</code>, <code>Params.Hidden</code> mean. Although I can take a wild guess, they're not that important for understanding what the logic is doing. The logic is setting the classes on the <code>li</code> element which is all I really care about: parent, always-open and active.</p>\n<p>When focusing on those three classes, we can port them to React in a much more readable way by defining a variable string <code>ddClass</code>:</p>\n<pre><code class=\"language-js\"> let ddClass = ''\n let isAncestor = numberOfPages &gt; 0\n if (isAncestor) {\n   ddClass += ' parent'\n }\n if (frontmatter.alwaysopen) {\n   ddClass += ' parent alwaysOpen'\n }\n return (\n   &lt;Location&gt;\n     {({ location }) =&gt; {\n       const currentPathActive = location.pathname === pathToServe\n       if (currentPathActive) {\n         ddClass += ' active'\n       }\n       return (\n         &lt;li data-nav-id={pathToServe} className={'dd-item ' + ddClass}&gt;\n</code></pre>\n<p>There are actually a few nice things about the Hugo code, I admit. Using the Location component in React was probably less intuitive than Hugo’s ability to access <code>currentNode</code> to get the active page. Also <code>isAncestor</code> is predefined in Hugo as <code>Whether the current page is an ancestor of the given page.</code> For me though, having to track down the definitions of the predefined variables was frustrating and I appreciate the local explicitness of the definition, but I admit I’m a bit jaded.</p>\n<h4 id=\"children\">Children</h4>\n<p>The most complex part of the sidebar is getting the children. Now this is a story that really gets me starting to appreciate GraphQL.</p>\n<p>Here’s getting the children for the sidebar in Hugo:</p>\n<pre><code class=\"language-html\">    {{ $numberOfPages := (add (len .Pages) (len .Sections)) }}\n        {{ if ne $numberOfPages 0 }}\n \n          {{ if or (.IsAncestor $currentNode) (.Params.alwaysopen)  }}\n            &lt;i class=&quot;triangle-up&quot;&gt;&lt;/i&gt;\n          {{ else }}\n            &lt;i class=&quot;triangle-down&quot;&gt;&lt;/i&gt;\n          {{ end }}\n \n        {{ end }}\n      &lt;/a&gt;\n      {{ if ne $numberOfPages 0 }}\n        &lt;ul&gt;\n          {{ .Scratch.Set &quot;pages&quot; .Pages }}\n          {{ if .Sections}}\n          {{ .Scratch.Set &quot;pages&quot; (.Pages | union .Sections) }}\n          {{ end }}\n          {{ $pages := (.Scratch.Get &quot;pages&quot;) }}\n \n        {{ if eq .Site.Params.ordersectionsby &quot;title&quot; }}\n          {{ range $pages.ByTitle }}\n            {{ if and .Params.hidden (not $.showhidden) }}\n            {{ else }}\n            {{ template &quot;section-tree-nav&quot; dict &quot;sect&quot; . &quot;currentnode&quot; $currentNode }}\n            {{ end }}\n          {{ end }}\n        {{ else }}\n          {{ range $pages.ByWeight }}\n            {{ if and .Params.hidden (not $.showhidden) }}\n            {{ else }}\n            {{ template &quot;section-tree-nav&quot; dict &quot;sect&quot; . &quot;currentnode&quot; $currentNode }}\n            {{ end }}\n          {{ end }}\n        {{ end }}\n        &lt;/ul&gt;\n      {{ end }}\n    &lt;/li&gt;\n  {{ else }}\n    {{ if not .Params.Hidden }}\n      &lt;li data-nav-id=&quot;{{.URL}}&quot; class=&quot;dd-item\n     {{ if eq .UniqueID $currentNode.UniqueID}}active{{ end }}\n      &quot;&gt;\n        &lt;a href=&quot;{{.RelPermalink}}&quot;&gt;\n        &lt;span&gt;{{safeHTML .Params.Pre}}{{.Title}}{{safeHTML .Params.Post}}&lt;/span&gt;\n        {{ if .Params.new }}\n          &lt;span class=&quot;new-badge&quot;&gt;NEW&lt;/span&gt;\n        {{ end }}\n \n        &lt;/a&gt;&lt;/li&gt;\n     {{ end }}\n  {{ end }}\n {{ end }}\n{{ end }}\n{{ end }}\n</code></pre>\n<p>This is just the first layer of children. No grandbabies, sorry. And I won’t even get into all that is going on there exactly. When I started porting this over, I realized a lot of that logic was not even being used.</p>\n<p>In React, we grab all the markdown pages and see which have parents that match the current page:</p>\n<pre><code class=\"language-js\"> const topLevelMarkdown: markdownRemarkEdge[] = useStaticQuery(\n   GraphQL`\n     {\n       allMdx(limit: 1000) {\n         edges {\n           node {\n             frontmatter {\n               title\n               alwaysopen\n               hidden\n               showNew\n               weight\n             }\n             fileAbsolutePath\n             fields {\n               pathToServe\n               parent\n               filePath\n             }\n           }\n         }\n       }\n     }\n   `\n ).allMdx.edges\n const myChildren: mdx[] = topLevelMarkdown\n   .filter(\n     edge =&gt;\n       fields.pathToServe === '/workers' + edge.node.fields.parent &amp;&amp;\n       fields.pathToServe !== edge.node.fields.pathToServe\n   )\n   .map(child =&gt; child.node)\n   .filter(child =&gt; !child.frontmatter.hidden)\n   .sort(sortByWeight)\n const numberOfPages = myChildren.length\n\n</code></pre>\n<p>And then we render the children, so the full JSX becomes:</p>\n<pre><code class=\"language-jsx\">&lt;li data-nav-id={pathToServe} className={'dd-item ' + ddClass}&gt;\n   &lt;Link\n     to={pathToServe}\n     title=&quot;Docs Home&quot;\n     activeClassName=&quot;active&quot;\n   &gt;\n     {title || 'No title'}\n     {numberOfPages ? (\n       &lt;Triangle isAncestor={isAncestor} alwaysopen={showChildren} /&gt;\n     ) : (\n       ''\n     )}\n     {showNew ? &lt;span className=&quot;new-badge&quot;&gt;NEW&lt;/span&gt; : ''}\n   &lt;/Link&gt;\n   {showChildren ? (\n     &lt;ul&gt;\n       {' '}\n       {myChildren.map((child: mdx) =&gt; {\n         return (\n           &lt;SidebarLi\n             frontmatter={child.frontmatter}\n             fields={child.fields}\n             depth={++depth}\n             key={child.frontmatter.title}\n           /&gt;\n         )\n       })}\n     &lt;/ul&gt;\n   ) : (\n     ''\n   )}\n &lt;/li&gt;\n</code></pre>\n<p>Ok now that we have a component, and we have Gatsby creating the pages off the markdown, I can go back to my <code>PageTemplate</code> component and render the sidebar:</p>\n<pre><code class=\"language-jsx\">import Sidebar from './Sidebar'\nexport default function PageTemplate({ data: { mdx } }) {\n return (\n   &lt;div&gt;\n     &lt;Sidebar /&gt;\n     &lt;h1&gt;{mdx.frontmatter.title}&lt;/h1&gt;\n     &lt;MDXRenderer&gt;{mdx.body}&lt;/MDXRenderer&gt;\n   &lt;/div&gt;\n )\n}\n</code></pre>\n<p>I don’t have to pass any props to <code>Sidebar</code> because the GraphQL static query in <code>Sidebar.tsx</code> gets all the data about all the pages that I need. I don’t even maintain state because <code>Location</code> is used to determine which path is active. Gatsby generates pages using the above component for each page that’s a markdown MDX node.</p>\n<h2 id=\"wrappingup\">Wrapping up</h2>\n<p>This was just the beginning of the full migration to Gatsby. I repeated the process above for turning templates, partials, and other HTML component-like parts in Hugo into React, which was actually pretty fun, though turning vanilla JS that once manipulated the DOM into React would probably be a nightmare if I wasn’t somewhat comfortable working in React.</p>\n<p>Main lessons learned:</p>\n<ul>\n<li>Being careful about breaking things and being scared to break things are two very different things. Being careful is good; being scared is bad. If I were to complete this migration again, I would’ve used the Hugo templates as a reference but not as a source of truth. Staging environments are what testing is for. Don’t sacrifice writing things the right way to comply with the old way.</li>\n<li>When doing a migration like this on a static site, get just a few pages working before moving the content over to avoid intermediate PRs from breaking. It seems obvious but, with the large amounts of content we had, a lot of things broke when porting over content. Get everything polished with each type of page before moving all your content over.</li>\n<li>When doing a migration like this, it’s OK to compromise some features of the old design until you determine whether to add them back in, just make sure to test this with real users first. For example, I made the mistake of assuming others wouldn’t mind being without anchor tags. (Note Hugo templates create anchor tags for headers automatically as in Gatsby you have to use MDX to customize markdown components). Test this on a single, popular page with real users first to see if it matters before giving it up.</li>\n<li>Even for those with React background, the ramp up with GraphQL and setting up Gatsby isn’t as simple as it seems at first. But once you’re set up it’s pretty dang nice.</li>\n</ul>\n<p>Overall the process of moving to Gatsby was well worth the effort. As we implement a redesign in React it’s much easier to apply the designs in this cleaner code base. Also though Hugo was already very performant with a nice SEO score, in Gatsby we are able to increase the performance and SEO thanks to the framework’s flexibility.</p>\n<p>Lastly, working with the Gatsby team was awesome and they even give free T-shirts for your first PR!</p>\n<!--kg-card-end: markdown-->",
		"id": "5e7b2ee042df4b01bd4fcf2f",
		"meta_description": "As our developer documentation grows so does the need for tooling. Let’s walk through how we migrated our documentation site to Gatsby to take full advantage of static generation and React. ",
		"meta_title": null,
		"og_description": null,
		"og_image": null,
		"og_title": null,
		"primary_author": {
			"id": "5d1644b141acde0011a94fc8",
			"name": "Victoria Bernard",
			"slug": "victoria",
			"profile_image": "http://blog.cloudflare.com/content/images/2018/04/UOeuJDMRxejfddFMXFvl_1204a20b3d1d96bba523a6a2a5fa3cd73bd4fe59240a27ad6eb8c064c6792446.jpg",
			"cover_image": "http://blog.cloudflare.com/content/images/2018/08/general@2x-130.png",
			"bio": null,
			"website": null,
			"location": null,
			"facebook": null,
			"twitter": null,
			"meta_title": null,
			"meta_description": null,
			"url": "http://blog.cloudflare.com/author/victoria/"
		},
		"primary_tag": {
			"id": "5d16450341acde0011a95204",
			"name": "Developers",
			"slug": "developers",
			"description": null,
			"feature_image": "http://blog.cloudflare.com/content/images/2020/10/Developers-1.png",
			"visibility": "public",
			"meta_title": "Cloudflare Blog: Developers",
			"meta_description": "Collection of Cloudflare blog posts tagged 'Developers'.",
			"og_image": null,
			"og_title": null,
			"og_description": null,
			"twitter_image": null,
			"twitter_title": null,
			"twitter_description": null,
			"codeinjection_head": null,
			"codeinjection_foot": null,
			"canonical_url": null,
			"accent_color": null,
			"url": "http://blog.cloudflare.com/tag/developers/"
		},
		"published_at": "2020-03-26T12:00:00.000+00:00",
		"reading_time": 12,
		"slug": "migrating-to-react-land-gatsby",
		"tags": [
			{
				"id": "5d16450341acde0011a95204",
				"name": "Developers",
				"slug": "developers",
				"description": null,
				"feature_image": "http://blog.cloudflare.com/content/images/2020/10/Developers-1.png",
				"visibility": "public",
				"meta_title": "Cloudflare Blog: Developers",
				"meta_description": "Collection of Cloudflare blog posts tagged 'Developers'.",
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/developers/"
			}
		],
		"title": "Migrating to React land: Gatsby",
		"twitter_description": null,
		"twitter_image": null,
		"twitter_title": null,
		"updated_at": "2020-03-26T12:00:01.000+00:00",
		"url": "http://blog.cloudflare.com/migrating-to-react-land-gatsby/",
		"uuid": "64be31b8-114c-4971-b8a6-bbdcc183b74c",
		"visibility": "public"
	}
}