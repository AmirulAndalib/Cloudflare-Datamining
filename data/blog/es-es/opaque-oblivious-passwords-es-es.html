<div class="post-content lh-copy gray1">
	<figure class="kg-card kg-image-card"><img src="https://blog.cloudflare.com/content/images/2020/12/Opaque-Header-9.png" class="kg-image"></figure>
	<p>Las contraseñas son un problema por razones que ignoran la mayoría de las personas que las usan. Si pierdes el control de tu contraseña, la seguridad quedará expuesta con total seguridad, sin importar su complejidad o lo difícil que sea de adivinar.</p>
	<p>La mayoría de los lectores admitirán de inmediato las dificultades para recordar y administrar contraseñas, sobre todo porque los requisitos de estas son cada vez más complejos. Afortunadamente, existen grandes paquetes de <em>software</em> y complementos para el navegador que ayudan a administrarlas. Sin embargo, muchos os sorprenderéis al saber que los problemas, que son consecuencia de la falta de seguridad inherente de las contraseñas, son mucho más graves de lo que generalmente se cree.</p>
	<p>Podrías decirnos: "¡Pero las contraseñas siempre se almacenan en formato encriptado!" y no te equivocas, pero es una afirmación incompleta. La verdad es que incluso una contraseña encriptada puede descifrarse, aunque (por suerte) no sin dificultades cuando se cifran correctamente. Un problema cada vez más acuciante radica en la naturaleza de las propias contraseñas: para utilizar una contraseña, directamente, esta debe administrarse sin cifrar.</p>
	<p>"¡Pero mi contraseña se transmite de forma segura mediante HTTPS!". Es cierto.</p>
	<p>"¡Sé que el servidor almacena mi contraseña en forma encriptada, segura, para que nadie pueda acceder a ella!", podrías asegurar. Bueno, en este caso estás depositando mucha confianza en el servidor. Aun así, digamos que sí, es verdad.</p>
	<p>Sin embargo, queda una limitación: la brecha en el uso de las contraseñas de extremo a extremo. Ten en cuenta que una vez que un servidor recibe una contraseña, esta tiene que leerse y procesarse mientras se transmite y procesa de forma segura. Sí, ¡como texto sin formato!</p>
	<p>Y lo que es peor, muchos están acostumbrados a pensar en <em>software</em>, lo que hace que sea más fácil olvidarse de la vulnerabilidad del <em>hardware</em>. Esto significa que, aunque el software sea de alguna manera de confianza, la contraseña debe en algún momento residir en la memoria. La contraseña se debe transmitir en algún momento a la CPU a través de un bus de datos compartido. Este proceso proporciona vectores de ataque a los observadores de muchas formas. No hay duda de que estos vectores de ataque son menos probables que los que presentan la transmisión y el almacenamiento permanente, pero no son menos graves (vulnerabilidades recientes de la CPU como Spectre y Meltdown deberían servir como un claro recordatorio).</p>
	<p>La única forma de solucionar este problema es eliminar las contraseñas por completo. ¡Hay esperanza! Las comunidades de investigación y del sector privado están trabajando duro para lograrlo. Están surgiendo nuevos estándares que están avanzando. Lamentablemente, las contraseñas son tan ubicuas que va a llevar mucho tiempo alcanzar un acuerdo y sustituirlas por nuevos estándares y tecnología.</p>
	<p>En Cloudflare, nos hemos preguntado si hay algo que podamos hacer ahora, de forma inminente. El análisis exhaustivo sobre OPAQUE que abordamos hoy es una posible respuesta. OPAQUE es uno de los muchos ejemplos de sistemas que permiten que una contraseña sea útil sin que pierdas el poder sobre ella. A nadie le gustan las contraseñas, pero mientras se usen al menos podemos asegurarnos de que nunca se revelen.</p>
	<p>Soy la primera en admitir que las contraseñas son molestas: son difíciles de recordar, tediosas de escribir y bastante poco seguras. Las iniciativas para reducir o reemplazar las contraseñas son prometedoras. Por ejemplo, <a href="https://blog.cloudflare.com/cloudflare-now-supports-security-keys-with-web-authentication-webauthn/">WebAuthn</a> es un estándar de autenticación web basado principalmente en criptografía de clave pública que utiliza tokens de <em>hardware</em> <a href="https://github.com/github/SoftU2F" target="_blank">(o de<em> software</em>)</a>. Aun así, y por muy frustrante que sea, las contraseñas siguen siendo el mecanismo de autenticación por excelencia. El hecho de que no podamos librarnos de ellas puede obedecer a su facilidad de implementación, a la confianza que ofrecen a los usuarios o su ubicuidad. Sea cual sea el motivo, nuestra meta es que la autenticación por contraseñas sea lo más segura posible mientras se siga empleando este método.</p>
	<p>Mi trabajo como becaria en Cloudflare se centró en OPAQUE, un protocolo criptográfico que resuelve uno de los problemas de seguridad más evidentes de la autenticación por contraseña en la web: aunque están protegidas en tránsito por el protocolo HTTPS, <strong>los servidores las gestionan en texto sin formato </strong>para verificar su exactitud. La utilización de contraseñas de texto sin formato es peligrosa, ya que registrarlas accidentalmente o almacenarlas en caché podría provocar un fallo de seguridad catastrófico. El objetivo del proyecto, más que abogar por la adopción de un protocolo en particular, es demostrar que OPAQUE es una opción viable entre muchas otras para la autenticación. Debido a que el entorno web me es más familiar, y probablemente lo sea para muchos lectores, usaré la web como ejemplo principal. </p>
	<h3 id="autenticaci-n-web-101-contrase-a-mediante-protocolo-tls">Autenticación web 101: Contraseña mediante protocolo TLS</h3>
	<p>¿Qué ocurre cuando escribes una contraseña en la web? El sitio web tiene que verificar que la contraseña que escribiste sea la misma que la que utilizaste originalmente en el sitio. Pero, ¿cómo funciona esta comprobación?</p>
	<p>Por lo general, tu nombre de usuario y contraseña se envían a un servidor. El servidor comprueba a continuación si la contraseña que tiene registrada para tu nombre de usuario coincide con la contraseña que facilitaste. No cabe duda de que para evitar que un atacante intercepte tu contraseña mientras navegas por Internet, tu conexión al servidor debe estar encriptada a través de HTTPS (HTTP mediante TLS).</p>
	<p>A pesar del uso del protocolo HTTPS, sigue habiendo un problema evidente en esta dinámica: el servidor debe almacenar una representación de su contraseña en algún lugar. Los servidores son difíciles de proteger y los fallos de seguridad son demasiado habituales. La filtración de esta representación puede causar graves problemas de seguridad. (Puedes consultar los últimos fallos de seguridad en el siguiente enlace:<a href="https://haveibeenpwned.com/" target="_blank"> https://haveibeenpwned.com/</a>).</p>
	<p>Para que estas filtraciones sean menos devastadoras, los servidores suelen aplicar una <em>función hash</em> a las contraseñas de los usuarios. Una función hash asigna cada contraseña a un valor de aspecto aleatorio único. Es fácil aplicar el hash a una contraseña, pero es casi imposible revertir la función y recuperar la contraseña. (Dicho esto, cualquiera puede adivinar una contraseña, aplicar la función hash y comprobar si el resultado es el mismo).</p>
	<p>Con el hash aplicado a contraseñas, las contraseñas de texto sin formato ya no se almacenan en los servidores. &nbsp;Un atacante que roba una base de datos de contraseñas ya no tiene acceso instantáneo a las mismas. En cambio, el atacante necesita aplicar el hash a muchas contraseñas posibles y comparar los resultados con los hashes robados.</p>
	<p>Por desgracia, si solo aplicamos el hash a las contraseñas, los atacantes pueden descargar <em>tablas rainbow, o tablas arco iris precalculadas, </em>que contienen hash de billones de posibles contraseñas y recuperar casi instantáneamente las contraseñas de texto sin formato. (Consulta <a href="https://project-rainbowcrack.com/table.htm" target="_blank">https://project-rainbowcrack.com/table.htm</a> para obtener una lista de algunas tablas rainbow).</p>
	<p>Teniendo esto en cuenta, una buena y exhaustiva estrategia de defensa es añadir un <em>salt</em> al hash, donde el salt es un valor aleatorio que se añade a la contraseña, siendo el servidor quien encripta la contraseña y el <em>salt</em>. El servidor también guarda el salt al lado del nombre de usuario, por lo que el usuario ni lo ve ni necesita enviarlo. Cuando el usuario envía una contraseña, el servidor vuelve a calcular esta función hash utilizando el salt. Por tanto, un atacante que roba datos de contraseñas, es decir, las representaciones de contraseñas y los valores salt, tiene que descifrar una por una las contraseñas comunes y aplicar la función a cada una de ellas. Las tablas rainbow existentes no le servirán de ayuda porque no tienen en cuenta los valores salt, por lo que el atacante debe crear una nueva tabla rainbow ¡para cada usuario!</p>
	<p>Esto (con suerte) ralentiza el ataque lo suficiente como para que el servicio informe a los usuarios del fallo de seguridad, de modo que puedan cambiar sus contraseñas. Además, la efectividad de los hashes con salt se puede <em>reforzar</em> aplicando un hash muchas veces para ralentizar los ataques. (Consulta <a href="https://blog.cloudflare.com/keeping-passwords-safe-by-staying-up-to-date/">https://blog.cloudflare.com/keeping-passwords-safe-by-staying-up-to-date/</a> para obtener más información).</p>
	<p>Estas dos estrategias de mitigación, el cifrado de la contraseña en tránsito y el almacenamiento de hashes reforzados con salt, son las mejores prácticas de hoy en día.</p>
	<p>Un gran brecha de seguridad sigue abierta. <em>Una contraseña mediante protocolo TLS</em> (como lo llamaremos) requiere que <strong>envíes tu contraseña de texto sin formato al servidor cada vez que inicias sesión</strong> porque el servidor debe ver tu contraseña para verificarla con las contraseñas registradas. Incluso un servidor bien intencionado podría almacenar accidentalmente la información en caché o registrar tu intento o intentos de acceso con la contraseña, o dañarse en el curso de la verificación de esta. (Por ejemplo, Facebook se dio cuenta en 2019 de que había <a href="https://about.fb.com/news/2019/03/keeping-passwords-secure/" target="_blank">estado almacenando sin querer millones de contraseñas de texto sin formato de sus usuarios</a>). En teoría, los servidores nunca deberían ver una contraseña de texto sin formato.</p>
	<p>Pero esto es como una encrucijada: ¿cómo puedes verificar una contraseña si no la ves? Con OPAQUE, un protocolo de intercambio de claves autenticadas por contraseña (PAKE) que acredita conocer una contraseña y deriva una clave secreta simultáneamente. Antes de describir OPAQUE en detalle, primero resumiremos las funcionalidades de PAKE en general.</p>
	<h3 id="pruebas-de-contrase-a-con-intercambio-de-claves-autenticadas-con-contrase-a">Pruebas de contraseña con intercambio de claves autenticadas con contraseña</h3>
	<!--kg-card-begin: markdown-->
	<p>El intercambio de claves autenticadas por contraseña (PAKE) fue propuesto por Bellovin y Merrit<sup>[1]</sup> en 1992, con el objetivo inicial de permitir la autenticación de contraseñas sin la posibilidad de ataques de diccionario basados en datos transmitidos a través de un canal inseguro.</p>
	<!--kg-card-end: markdown-->
	<p>Básicamente, el PAKE, plano o <em>simétrico</em>, es un protocolo criptográfico que permite a dos partes que comparten solo una contraseña establecer una clave secreta compartida y segura. Los objetivos del PAKE son:</p>
	<p>1) Las claves secretas coincidirán si las contraseñas coinciden y, en caso contrario, serán aleatorias.<br>2) Los participantes no necesitan confiar en terceros (particularmente, en ninguna infraestructura de clave pública).<br>3) La clave secreta resultante no la conoce nadie ajeno al protocolo, ni siquiera aquellos que conocen la contraseña.<br>4) El protocolo no revela la contraseña de ninguna de las partes al otro (a menos que las contraseñas coincidan) ni tampoco a los intrusos.</p>
	<p>En resumen, la única forma de atacar con éxito el protocolo es adivinar la contraseña correctamente mientras se participa en el protocolo. (Afortunadamente, estos ataques se pueden neutralizar en su mayoría mediante <em>rate-limiting</em>, es decir, impidiendo que un usuario inicie sesión después de un cierto número de intentos de contraseña incorrectos).</p>
	<p>A partir de estos requisitos, se entiende que la contraseña mediante protocolo TLS claramente <em>no</em> es un PAKE, porque:</p>
	<ul>
		<li>Depende de WebPKI, que confía en terceras partes denominadas Autoridades de certificación (consulta <a href="https://blog.cloudflare.com/introducing-certificate-transparency-and-nimbus/">https://blog.cloudflare.com/introducing-certificate-transparency-and-nimbus/</a> para saber más sobre WebPKI y algunas de sus limitaciones).</li>
		<li>La contraseña del usuario se revela al servidor.</li>
		<li>La contraseña mediante el protocolo TLS no proporciona al usuario ninguna garantía de que el servidor conozca su contraseña o un derivado de ella: un servidor podría aceptar cualquier dato del usuario sin ningún tipo de verificación.</li>
	</ul>
	<p>Dicho esto, las prestaciones de seguridad del PAKE plano son inferiores a las de la contraseña mediante protocolo TLS, simplemente porque requiere que el servidor <em>almacene </em>contraseñas en texto sin formato. Necesitamos un PAKE que permita al servidor almacenar hashes con salt si queremos superar la práctica actual.</p>
	<p>La mejora con respecto al PAKE plano es lo que se conoce como PAKE<em> asimétrico</em> (aPAKE) porque solo el cliente conoce la contraseña y el servidor conoce un <em>hash</em> de contraseña. Un aPAKE tiene además de las cuatro propiedades de un PAKE, una más:</p>
	<p>5) Un atacante que roba datos de contraseña almacenados en el servidor debe realizar un ataque de diccionario para recuperar la contraseña.</p>
	<p>Sin embargo, el problema con la mayoría de los protocolos aPAKE existentes es que no permiten un hash con <em>salt</em> (o si lo hacen, requieren que el salt se transmita al usuario, lo que significa que el atacante tiene acceso al salt de antemano y puede comenzar calcular una tabla rainbow para el usuario antes de robar cualquier dato). Por lo tanto, nos gustaría actualizar la propiedad de seguridad de la siguiente manera:</p>
	<p>5*) Un atacante que roba datos de contraseña almacenados en el servidor debe realizar un ataque de diccionario <em>por usuario</em> para recuperar la contraseña <em>después de que los datos se vean comprometidos</em>.</p>
	<p>OPAQUE es el primer protocolo aPAKE con prueba formal de seguridad que tiene esta propiedad: permite un salt completamente secreto.</p>
	<h3 id="opaque-los-servidores-protegen-las-contrase-as-sin-conocerlas-">OPAQUE - Los servidores protegen las contraseñas ¡sin conocerlas!</h3>
	<figure class="kg-card kg-image-card"><img src="https://blog.cloudflare.com/content/images/2020/12/opaque-wordmark-4.png" class="kg-image"></figure>
	<p><a href="https://eprint.iacr.org/2018/163.pdf" target="_blank">OPAQUE</a> es lo que se conoce como un <em> aPAKE sólido</em>, que significa simplemente que resiste estos ataques precalculados usando un hash con salt secreto en el servidor. Stanislaw Jarecki, Hugo Krawcyzk y Jiayu Xu propusieron y analizaron oficialmente OPAQUE en 2018 (dato revelador: Stanislaw Jarecki es mi mentor académico). El nombre OPAQUE es una combinación de los nombres de dos protocolos criptográficos: OPRF y PAKE. Ya conocemos PAKE, pero ¿qué es OPRF? OPRF son las siglas de Oblivious Pseudo-Random Function, en español, función pseudoaletoria ajena, que es un protocolo mediante el cual dos partes calculan una función <em>F (clave, x)</em> que es determinista, pero que genera valores de apariencia aleatoria. Una parte introduce el valor <em>x</em> y la otra introduce la clave: la parte que inserta <em>x</em> descubre el resultado <em>F (clave, x)</em>, pero no la clave, y la parte que proporciona la clave no descubre nada. (Para obtener más información sobre el funcionamiento matemático de OPRF visita: <a href="https://blog.cloudflare.com/privacy-pass-the-math/">https://blog.cloudflare.com/privacy-pass-the-math/</a>).</p>
	<p>En esencia, OPAQUE es un método de almacenaje de información confidencial de un usuario en un servidor, sin que este tenga acceso a dicha información. En lugar de almacenar un hash de contraseña tradicional con salt, el servidor almacena un sobre secreto para ti que está "bloqueado" por dos datos: tu contraseña, que solo conoces tú, y una clave secreta aleatoria (como un salt), que solo conoce el servidor. Para iniciar sesión, el cliente inicia un intercambio criptográfico que revela la clave del sobre al cliente, pero, lo más importante es que no la releva al servidor.</p>
	<p>Posteriormente, el servidor envía el sobre al usuario, quien ahora puede recuperar las claves cifradas. (Las claves incluidas en el sobre son un par de claves pública y privada para el usuario y una clave pública para el servidor). Estas claves, una vez desbloqueadas, serán las entradas a un protocolo de intercambio de claves autenticadas (AKE), que permiten al usuario y al servidor establecer una clave secreta que se puede utilizar para cifrar su comunicación futura.</p>
	<p>OPAQUE consta de dos fases: registro de credenciales e inicio de sesión a través de intercambio de claves.</p>
	<h3 id="opaque-fase-de-registro">OPAQUE - Fase de registro</h3>
	<p>Antes del registro, el usuario se registra por primera vez en un servicio y elige un nombre de usuario y una contraseña. El registro comienza con el flujo OPRF que acabamos de describir: Alice (el usuario) y Bob (el servidor) hacen un intercambio OPRF. El resultado es que Alice tiene una contraseña aleatoria <em><strong>rwd</strong></em>, derivada de la salida OPRF <em>F (clave, pwd), donde clave </em>es una clave OPRF propiedad del servidor específica para Alice y <em>pwd</em> es la contraseña de Alice.</p>
	<p>Dentro de su mensaje OPRF, Bob envía la clave pública de su identidad OPAQUE. Posteriormente, Alice genera un nuevo par de claves pública/privada, que serán su identidad OPAQUE permanente para el servicio de Bob, y encripta <em>su</em> clave secreta junto con la clave pública de <em>Bob </em>con la <strong>rwd</strong> (llamaremos al resultado un <em>sobre cifrado</em>). Alice envía este sobre cifrado junto con su clave pública (sin cifrar) a Bob, quien almacena los datos que ella le proporcionó, junto con su OPRF secreto, en una base de datos indexada por su nombre de usuario.</p>
	<figure class="kg-card kg-image-card"><img src="https://blog.cloudflare.com/content/images/2020/12/OPAQUE-diagram-1@3x-5.png" class="kg-image"></figure>
	<h3 id="opaque-fase-de-inicio-de-sesi-n">OPAQUE - Fase de inicio de sesión</h3>
	<p>La fase de inicio de sesión es muy similar. Comienza de la misma forma que el registro, con un flujo OPRF. Sin embargo, en la parte del servidor, Bob no genera una nueva clave OPRF, sino que busca la que creó en el registro de Alice. Para ello, busca el nombre de usuario de Alice (el que ella le proporcionó en el primer mensaje) y recupera el registro que generó de ella. Este registro contiene su clave pública, su sobre cifrado y la clave OPRF de Bob específicas para Alice.</p>
	<p>También envía el sobre cifrado que Alice puede descifrar con la salida del flujo OPRF. (Si el descifrado falla, Alice interrumpe el protocolo; esto probablemente indica que escribió su contraseña de manera incorrecta o que Bob no es quien dice ser). Si logra el descifrado, ahora tiene su propia clave secreta y la clave pública de Bob. Alice las introduce en un protocolo AKE con Bob, quien también introduce su clave privada y su clave pública, lo que les da a ambos una clave secreta nueva.</p>
	<figure class="kg-card kg-image-card"><img src="https://blog.cloudflare.com/content/images/2020/12/OPAQUE-diagram-2@3x-8.png" class="kg-image"></figure>
	<h3 id="integraci-n-de-opaque-con-un-protocolo-ake">Integración de OPAQUE con un protocolo AKE</h3>
	<p>Una pregunta importante que hay que hacerse es: ¿qué protocolo AKE es adecuado para OPAQUE? La <a href="https://tools.ietf.org/html/draft-irtf-cfrg-opaque-01" target="_blank">nueva especificación del CFRG </a>esboza varias opciones, incluidos los protocolos 3DH y SIGMA-I. Sin embargo, en la web, ya tenemos un AKE a nuestra disposición: ¡TLS!</p>
	<p>Recordemos que TLS es un AKE porque provee autenticación unilateral (y mutua) con derivación de clave compartida. En el centro de la cuestión de TLS radica un intercambio de claves Diffie-Hellman, que en sí mismo <em>no está autenticado</em>, lo que significa que las partes que lo ejecutan no tienen forma de verificar con quién lo están ejecutando. (Esto es un problema porque cuando inicias sesión en tu banco, o en cualquier otro sitio web que almacena tus datos privados, quieres estar seguro de que la entidad con la que te comunicas es quien dice ser). La autenticación utiliza principalmente certificados, que son emitidos por entidades de confianza a través de un sistema denominado <a href="https://blog.cloudflare.com/how-to-build-your-own-public-key-infrastructure/">infraestructura de clave pública (PKI)</a>. Cada certificado está asociado con una clave secreta. Para probar su identidad, el servidor presenta su certificado al cliente y firma el protocolo de enlace TLS con su clave secreta.</p>
	<p>La modificación de esta autenticación por certificados en la web tal vez no sea el mejor punto de partida. En cambio, una mejora sería autenticar el secreto compartido del TLS, <em>a través de</em> OPAQUE, una vez se complete el protocolo de enlace TLS. En otras palabras, una vez que un servidor se autentica con su certificado típico WebPKI, los clientes podrían autenticarse posteriormente en el servidor. Esta autenticación podría tener lugar "después del protocolo de enlace" en la conexión TLS con OPAQUE.</p>
	<p><a href="https://datatracker.ietf.org/doc/draft-ietf-tls-exported-authenticator/" target="_blank">Los autenticadores exportados</a> son un mecanismo de autenticación "tras el protocolo de enlace" en TLS. Permiten que un servidor o cliente presente una prueba de una nueva identidad sin configurar una nueva conexión TLS. Recordemos que en el caso de una web estándar, el servidor establece su identidad con un certificado (acreditando, por ejemplo, que es “cloudflare.com”). Pero, si el mismo servidor también tiene identidades alternativas, deben ejecutar el protocolo TLS nuevamente para demostrar quiénes son.</p>
	<p>El funcionamiento del flujo básico del autenticador exportado es similar a un protocolo clásico de desafío-respuesta, y es el siguiente: (Consideraremos el caso de autenticación del servidor, ya que el caso del cliente es simétrico)</p>
	<figure class="kg-card kg-image-card"><img src="https://blog.cloudflare.com/content/images/2020/12/OPAQUE-diagram-3@3x-4.png" class="kg-image"></figure>
	<p>En cualquier momento después de que se establece una conexión TLS, Alice (el cliente) envía una <em>solicitud de autenticación</em> para indicar que le gustaría que Bob (el servidor) demuestre una identidad adicional. Esta solicitud incluye un contexto (una cadena impredecible; piensa en esto como un desafío) y extensiones que incluyen información sobre la identidad que el cliente desea que se le proporcione. Por ejemplo, el cliente podría incluir la extensión SNI para solicitar al servidor un certificado asociado con un determinado nombre de dominio que no sea el que se usó inicialmente en la conexión TLS.</p>
	<p>Al recibir el mensaje del cliente, si el servidor tiene un certificado válido correspondiente a la solicitud, envía un <em>autenticador exportado</em> que prueba que tiene la clave secreta para el certificado. (Este mensaje tiene el mismo formato que un mensaje de autenticación del cliente en el protocolo de enlace TLS 1.3 y contiene los siguientes mensajes: Certificate, CertificateVerify y Finished). Si el servidor no puede o no desea autenticarse con el certificado solicitado, responde con un autenticador vacío que contiene solo el mensaje Finished bien formado.</p>
	<p>Acto seguido, el cliente verifica que el autenticador exportado que recibe esté bien formado y después verifica que el certificado presentado sea válido y, de ser así, acepta la nueva identidad.</p>
	<p>Recapitulemos. Los autenticadores exportados son una forma de realizar la autenticación en una capa superior (como la capa de aplicación) de manera segura al aprovechar la criptografía y los formatos de los mensajes aprobados de TLS. Además, están vinculados a la sesión TLS para que los mensajes de autenticación no se puedan copiar y pegar de una conexión TLS a otra. En otras palabras, los autenticadores exportados facilitan exactamente los instrumentos correctos necesarios para agregar la autenticación basada en OPAQUE en TLS.</p>
	<h3 id="opaque-con-autenticadores-exportados-opaque-ea-">OPAQUE con autenticadores exportados (OPAQUE-EA)</h3>
	<figure class="kg-card kg-image-card"><img src="https://blog.cloudflare.com/content/images/2020/12/OPAQUE-diagram-2@3x-9.png" class="kg-image"></figure>
	<p><a href="https://datatracker.ietf.org/doc/html/draft-sullivan-tls-opaque-00" target="_blank">OPAQUE-EA</a> permite que OPAQUE se ejecute en cualquier punto después de que ya se haya configurado una conexión TLS. Recuerda que Bob (el servidor) almacenará su identidad OPAQUE, en este caso una clave de firma y una clave de verificación, y Alice almacenará su identidad, cifrada, en el servidor de Bob. (El flujo de registro donde Alice almacena sus claves encriptadas es el mismo que hemos visto en OPAQUE, excepto que Alice almacena una clave de firma, así que saltaremos directamente al inicio de sesión). Alice y Bob ejecutan dos flujos EA de solicitud de autenticación, uno para cada parte, y los mensajes del protocolo OPAQUE van en la sección de extensiones de los EA. Profundicemos en su funcionamiento.</p>
	<p>En primer lugar, Alice genera su mensaje OPRF en función de su contraseña. Crea una solicitud de autenticador solicitando la identidad OPAQUE de Bob, e incluye (en el campo de extensiones), su nombre de usuario y su mensaje OPRF, que envía a Bob a través de su conexión TLS establecida.</p>
	<p>Bob recibe el mensaje y busca el nombre de usuario de Alice en su base de datos. Acto seguido, recupera el registro OPAQUE de Alice que contiene su clave de verificación y sobre cifrado, así como su clave OPRF. Bob utiliza la clave OPRF en el mensaje OPRF y crea un autenticador exportado que demuestra la propiedad de su clave de firma OPAQUE, con una extensión que contiene su mensaje OPRF y el sobre cifrado. Además, envía una nueva solicitud de autenticador pidiéndole a Alice que demuestre la propiedad de su clave de firma OPAQUE.</p>
	<p>Alice analiza el mensaje y completa la evaluación del OPRF usando el mensaje de Bob para obtener la salida <em>rwd</em>, y usa la clave <em>rwd</em> para descifrar el sobre. Así revela su clave de firma y la clave pública de Bob. Alice usa la clave pública de Bob para verificar su prueba de respuesta del autenticador y, si es correcta, crea y envía un autenticador exportado que prueba que tiene la clave de firma recién descifrada. Bob comprueba la validez de su autenticador exportado y, si todo está correcto, acepta el inicio de sesión de Alice.</p>
	<h3 id="mi-proyecto-opaque-ea-mediante-https">Mi proyecto: OPAQUE-EA mediante HTTPS</h3>
	<p>Todo lo descrito anteriormente encuentra su fundamento en abundante teoría que aún no se ha reflejado en la práctica. Mi proyecto consistía en convertir la teoría en realidad. Comencé con descripciones escritas de <a href="https://tools.ietf.org/html/draft-ietf-tls-exported-authenticator-13" target="_blank">autenticadores exportados</a>, <a href="https://tools.ietf.org/html/draft-irtf-cfrg-opaque-01" target="_blank">OPAQUE</a> y un borrador preliminar de <a href="https://tools.ietf.org/html/draft-sullivan-tls-opaque-00" target="_blank">OPAQUE-in-TLS</a>. A partir de ese punto, mi objetivo era crear un prototipo funcional.</p>
	<p>Mi demo muestra la viabilidad de implementar OPAQUE-EA en la web, eliminando completamente tanto las contraseñas de texto sin formato de Internet, como las encriptadas. Esto proporciona una posible alternativa al flujo actual de contraseña mediante protocolo TLS con mejores propiedades de seguridad, pero sin cambios visibles para el usuario.</p>
	<p>Vale la pena conocer algunos de los detalles de la implementación. En ciencias de la computación, la abstracción es una herramienta poderosa. Significa que a menudo podemos confiar en las herramientas existentes y en las API para evitar duplicar esfuerzos. En mi proyecto confié en gran medida en <a href="https://github.com/bifurcation/mint" target="_blank">mint</a>, una aplicación de código abierto de TLS 1.3 en Go que es excelente para la creación de prototipos. También recurrí a la biblioteca <a href="https://github.com/cloudflare/circl/tree/master/oprf" target="_blank">CIRCL</a> para OPRF. Creé bibliotecas para autenticadores exportados, fundamento esencial de OPAQUE y OPAQUE-EA (que une a los dos).</p>
	<p>Elaboré la web demo envolviendo la funcionalidad OPAQUE-EA en un servidor HTTP simple y un cliente que se pasan mensajes entre sí a través de HTTPS. Como un navegador no puede ejecutar Go, utilicé un compilador de Go a WebAssembly (WASM) para obtener la funcionalidad Go en el navegador y escribí un script simple en JavaScript para solicitar las funciones WASM que necesitaba.</p>
	<p>Dado que los navegadores actuales no dan acceso a la conexión TLS subyacente en el lado del cliente, implementé un comando para permitir que el cliente acceda a las claves del exportador, es decir, que el servidor simplemente calcula las claves y las envía al cliente a través de HTTPS. Esta solución reduce la seguridad de la demo resultante, lo que significa que confía en el servidor para proporcionar las claves correctas. Aun así, incluso si un servidor malicioso proporcionó claves incorrectas, la contraseña del usuario sigue siendo segura, simplemente no tiene la seguridad de que se haya registrado previamente en el servidor. Sin embargo, en el futuro, los navegadores podrían incluir un mecanismo para admitir claves exportadas y permitir que OPAQUE-EA se ejecute con todas sus propiedades de seguridad.</p>
	<p>Puedes explorar mi aplicación <a href="https://github.com/cloudflare/opaque-ea" target="_blank">en Github</a> e incluso seguir las instrucciones para poner en marcha tu propio cliente y servidor de prueba OPAQUE-EA. Sin embargo, me gustaría hacer hincapié en que la aplicación está pensada solo como una prueba de concepto y no debe usarse para sistemas de producción sin una revisión adicional significativa.</p>
	<h3 id="limitaciones-de-opaque-ea">Limitaciones de OPAQUE-EA</h3>
	<p>A pesar de sus excelentes propiedades, definitivamente habrá algunos obstáculos para hacer que OPAQUE-EA pase de ser una prueba de concepto a un mecanismo de autenticación totalmente desarrollado.</p>
	<p><strong>Compatibilidad del navegador para claves de exportador TLS.</strong> Como ya se ha mencionado brevemente, para ejecutar OPAQUE-EA en un navegador, tienes que acceder a los secretos de la conexión TLS denominados <em>claves de exportador</em>. No hay forma de hacer esto en los navegadores más populares actuales, por lo que será necesario trabajar en la compatibilidad para utilizar esta función.</p>
	<p><strong>Renovación de las bases de datos de contraseñas. </strong>Para adoptar OPAQUE-EA, los servidores no solo necesitan actualizar su lógica de verificación de contraseñas, sino también renovar completamente sus bases de datos de contraseñas. Debido a que OPAQUE se basa en representaciones de contraseñas especiales que solo se pueden generar de forma interactiva, las contraseñas hash con salt existentes no se pueden actualizar automáticamente a registros OPAQUE. Es probable que los servidores necesiten ejecutar un flujo de registro OPAQUE especial para cada usuario. Debido a que OPAQUE depende de la aceptación tanto del cliente como del servidor, es posible que los servidores deban mantener el método anterior durante un tiempo antes de que todos los clientes se pongan al día.</p>
	<p><strong>Confianza en nuevos estándares. </strong>OPAQUE-EA se basa en el protocolo OPRF, que está en proceso de estandarización, y en autenticadores exportados, que es un estándar propuesto. Esto significa que la compatibilidad con estas dependencias aún no está disponible en la mayoría de las bibliotecas criptográficas existentes, por lo que es posible que los primeros usuarios necesiten implementar estas herramientas ellos mismos.</p>
	<h2 id="resumen">Resumen</h2>
	<p>Siempre que las personas sigan usando contraseñas, nos gustaría que el proceso fuera lo más seguro posible. Los métodos actuales se basan en la práctica arriesgada de administrar contraseñas de texto sin formato en el servidor mientras se verifica su exactitud. Los PAKE y (específicamente los aPAKE) permiten el inicio de sesión seguro con contraseña impidiendo que el servidor vea las contraseñas. OPAQUE es uno de los mejores aPAKE que existen y se puede integrar completamente en TLS. Puedes consultar el código <a href="https://github.com/cloudflare/opaque-ea" target="_blank">aqui</a>.</p>
	<p>[1] Bellovin, S. M., and Merritt, M. “Encrypted key exchange: Password-based protocols secure against dictionary attacks.” Proc. IEEE Computer Society Symposium on Research in Security and Privacy (Oakland, May 1992), 72–84.</p>
</div>