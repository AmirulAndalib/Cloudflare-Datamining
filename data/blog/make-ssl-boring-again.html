<div class="mb2 gray5">6 min read</div>
<div class="post-content lh-copy gray1"><!--kg-card-begin: markdown-->
	<p>It may (or may not!) come as surprise, but a few months ago we migrated Cloudflareâ€™s edge SSL connection termination stack to use <a href="https://boringssl.googlesource.com/boringssl">BoringSSL</a>: Google's crypto and SSL implementation that started as a fork of OpenSSL.</p>
	<p><img src="https://blog.cloudflare.com/content/images/2017/12/2017-12-05-160528_621x216_scrot-1.png" alt="CTO tweet" loading="lazy"></p>
	<p>We dedicated several months of work to make this happen without negative impact on customer traffic. We had a few bumps along the way, and had to overcome some challenges, but we ended up in a better place than we were in a few months ago.</p>
	<h3 id="tls13">TLS 1.3</h3>
	<p>We have <a href="https://blog.cloudflare.com/introducing-tls-1-3">already</a> <a href="https://blog.cloudflare.com/tls-1-3-overview-and-q-and-a">blogged</a> <a href="https://blog.cloudflare.com/tls-1-3-explained-by-the-cloudflare-crypto-team-at-33c3">extensively</a> about TLS 1.3. Our original TLS 1.3 stack required our main SSL termination software (which was based on OpenSSL) to hand off TCP connections to a separate system based on <a href="https://github.com/cloudflare/tls-tris">our fork of Go's crypto/tls standard library</a>, which was specifically developed to only handle TLS 1.3 connections. This proved handy as an experiment that we could roll out to our client base in relative safety.</p>
	<p>However, over time, this separate system started to make our lives more complicated: most of our SSL-related business logic needed to be duplicated in the new system, which caused a few subtle bugs to pop up, and made it harder to roll-out new features such as <a href="https://blog.cloudflare.com/introducing-tls-client-auth">Client Auth</a> to all our clients.</p>
	<p>As it happens, BoringSSL has supported TLS 1.3 for quite a long time (it was one the first open source SSL implementations to work on this feature), so now all of our edge SSL traffic (including TLS 1.3 connections) is handled by the same system, with no duplication, no added complexity, and no increased latency. Yay!</p>
	<h3 id="fancynewcryptopart1x25519fortls12andearlier">Fancy new crypto, part 1: X25519 for TLS 1.2 (and earlier)</h3>
	<p>When establishing an SSL connection, client and server will negotiate connection-specific secret keys that will then be used to encrypt the application traffic. There are a few different methods for doing this, the most popular one being ECDH (Elliptic Curve Diffieâ€“Hellman). Long story short this depends on an <a href="https://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography">elliptic curve</a> being negotiated between client and server.</p>
	<p>For the longest time the only widely supported curves available were the ones defined by NIST, until Daniel J. Bernstein proposed Curve25519 (X25519 is the mechanism used for ECDH based on Curve25519), which has quickly gained popularity and is now the default choice of many popular browsers (including Chrome).</p>
	<p>This was already supported for TLS 1.3 connections, and with BoringSSL we are now able to support key negotiation based on X25519 at our edge for TLS 1.2 (and earlier) connections as well.</p>
	<p>X25519 is now the second most popular elliptic curve algorithm that is being used on our network:</p>
	<p><img src="https://blog.cloudflare.com/content/images/2017/12/curves-metrics-with-logo-1.png" alt="Elliptic curves usage" loading="lazy"></p>
	<h3 id="fancynewcryptopart2rsapssfortls12">Fancy new crypto, part 2: RSA-PSS for TLS 1.2</h3>
	<p>Another one of the changes introduced by TLS 1.3 is the adoption of the PSS padding scheme for RSA signatures (RSASSA-PSS). This replaces the more fragile, and historically prone to security vulnerabilities, RSASSA-PKCS1-v1.5, for all TLS 1.3 connections.</p>
	<p>RSA PKCS#v1.5 has been known to be vulnerable to known ciphertext attacks since <a href="http://archiv.infsec.ethz.ch/education/fs08/secsem/bleichenbacher98.pdf">Bleichenbacherâ€™s CRYPTO 98 paper</a> which showed SSL/TLS to be vulnerable to this kind of attacks as well.</p>
	<p>The attacker exploits an â€œoracleâ€, in this case a TLS server that allows them to determine whether a given ciphertext has been correctly padded under the rules of PKCS1-v1.5 or not. For example, if the server returns a different error for correct padding vs. incorrect padding, that information can be used as an oracle (this is how Bleichenbacher broke SSLv3 in 1998). If incorrect padding causes the handshake to take a measurably different amount of time compared to correct padding, thatâ€™s called a timing oracle.</p>
	<p>If an attacker has access to an oracle, it can take as little as <a href="http://csf2012.seas.harvard.edu/5min_abstracts/MillionMessageAttack.pdf">15,000</a> messages to gain enough information to perform an RSA secret-key operation without possessing the secret key. This is enough for the attacker to either decrypt a ciphertext encrypted with RSA, or to forge a signature. Forging a signature allows the attacker to <a href="https://www.nds.rub.de/media/nds/veroeffentlichungen/2015/08/21/Tls13QuicAttacks.pdf">hijack TLS connections</a>, and decrypting a ciphertext allows the attacker to decrypt any connection that do not use <a href="https://blog.cloudflare.com/staying-on-top-of-tls-attacks">forward secrecy</a>.</p>
	<p>Since then, SSL/TLS implementations have adopted mitigations to prevent these attacks, but they are tricky to get right, as the recently published <a href="https://support.f5.com/csp/article/K21905460">F5 vulnerability</a> shows.</p>
	<p>With the switch to BoringSSL we made RSA PSS available to TLS 1.2 connections as well. This is already supported "in the wild", and is the preferred scheme by modern browsers like Chrome when dealing with RSA server certificates.</p>
	<h3 id="thedarksideofthemoon">The dark side of the moon</h3>
	<p>Besides all these new exciting features that we are now offering to all our clients, BoringSSL also has a few internal features that end users won't notice, but that made our life so much easier.</p>
	<p>Some of our SSL features required special patches that we maintained in our internal OpenSSL fork, however BoringSSL provides replacements for these features (and more!) out of the box.</p>
	<p>Some examples include its <a href="https://github.com/google/boringssl/blob/b2c312d670b9967cf881419758f0ec286b66a25f/include/openssl/ssl.h#L1123">private key callback</a> support that we now use to implement <a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details">Keyless SSL</a>, its <a href="https://github.com/google/boringssl/blob/b2c312d670b9967cf881419758f0ec286b66a25f/include/openssl/ssl.h#L2004">asynchronous session lookup callback</a> that we use to support <a href="https://blog.cloudflare.com/tls-session-resumption-full-speed-and-secure">distributed session ID caches</a> (for session resumption with clients that, for whatever reason, don't support session tickets), its <a href="https://github.com/google/boringssl/blob/b2c312d670b9967cf881419758f0ec286b66a25f/include/openssl/ssl.h#L1385">equal-preference cipher grouping</a> that allows us to offer <a href="https://blog.cloudflare.com/it-takes-two-to-chacha-poly">ChaCha20-Poly1305 ciphers</a> alongside AES GCM ones and let clients decide which they prefer, or its <a href="https://github.com/google/boringssl/blob/b2c312d670b9967cf881419758f0ec286b66a25f/include/openssl/ssl.h#L3353">"select_certificate" callback</a> that we use for inspecting and logging ClientHellos, and for dynamically enabling features depending on the userâ€™s configuration (we were previously using the â€œcert_cbâ€ callback for the latter, which is also supported by OpenSSL, but we ran into some limitations like the fact that you canâ€™t dynamically change the supported protocol versions with it, or the fact that it is not executed during session resumption).</p>
	<h3 id="thecaseofthemissingocsp">The case of the missing OCSP</h3>
	<p>Apart from adding new features, the BoringSSL developers have also been busy working on <em>removing</em> features that most people don't care about, to make the codebase lighter and easier to maintain. For the most part this worked out very well: a huge amount of code has been removed from BoringSSL without anyone noticing.</p>
	<p>However one of the features that also got the axe was OCSP. We relied heavily on this feature at our edge to offer OCSP stapling to all clients automatically. So in order to avoid losing this functionality we spent a few weeks working on a replacement, and, surprise! we ended up with a far more reliable OCSP pipeline than when we started. You can read more about the work we did in <a href="https://blog.cloudflare.com/high-reliability-ocsp-stapling">this blog post</a>.</p>
	<h3 id="chacha20poly1305draft">ChaCha20-Poly1305 draft</h3>
	<p>Another feature that was removed was support for the <a href="https://blog.cloudflare.com/it-takes-two-to-chacha-poly">legacy ChaCha20-Poly1305 ciphers</a> (not to be confused with the ciphers standardized in <a href="https://tools.ietf.org/html/rfc7905">RFC7905</a>). These ciphers were deployed by some browsers before the standardization process finished and ended up being incompatible with the standard ciphers later ratified.</p>
	<p>We looked at our metrics and realized that a significant percentage of clients still relied on this feature. These would be older mobile clients that don't have AES hardware offloading, and that didn't get software updated to get the newer ChaCha20 ciphers.</p>
	<p><img src="https://blog.cloudflare.com/content/images/2017/12/chacha-metrics-with-logo.png" alt="ChaCha20 Poly1305 ciphers usage" loading="lazy"></p>
	<p>We decided to add support for these ciphers back to our own internal BoringSSL fork so that those older clients could still take advantage of them. We will keep monitoring our metrics and decide whether to remove them once the usage drops significantly.</p>
	<h3 id="slowbase64venividivici">Slow Base64: veni, vidi, vici</h3>
	<p>One somewhat annoying problem we noticed during a test deployment, was an increase in the startup time of our NGINX instances. Armed with perf and flamegraphs we looked into what was going on and realized the CPU was spending a ridiculous amount of time in BoringSSLâ€™s base64 decoder.</p>
	<p>It turns out that we were loading CA trusted certificates from disk (in PEM format, which uses base64) over and over and over in different parts of our NGINX configuration, and because of a <a href="https://github.com/google/boringssl/commit/536036abf46a13e52a43a92f6e44a87404e8755f#diff-c7192c0c5ad80a961243b0ad5c434176">change</a> in BoringSSL that was intended to make the base64 decoder constant-time, but also made it <a href="https://boringssl-review.googlesource.com/c/boringssl/+/16384#message-06ca2814d05ae91a486a2126e017cc38f2e514b3">several times slower</a> than the decoder in OpenSSL, our startup times also suffered.</p>
	<p>Of course the astute reader might ask, why were you loading those certificates from disk multiple times in the first place? And indeed there was no particular reason, other than the fact that the problem went unnoticed until it actually became a problem. So we fixed our configuration to only load the certificates from disk in the configuration sections where they are actually needed, and lived happily ever after.</p>
	<h3 id="conclusion">Conclusion</h3>
	<p>Despite a few hiccups, this whole process turned out to be fairly smooth, also thanks to the rock-solid stability of the BoringSSL codebase, not to mention its extensive documentation. Not only we ended up with a much better and more easily maintainable system than we had before, but we also managed to <a href="https://github.com/google/boringssl/commits?author=vkrasnov">contribute</a> a <a href="https://github.com/google/boringssl/commits?author=ghedo">little</a> back to the open-source community.</p>
	<p>As a final note weâ€™d like to thank the BoringSSL developers for the great work they poured into the project and for the help they provided us along the way.</p>
	<!--kg-card-end: markdown-->
</div>