{
	"locale": "en-us",
	"post": {
		"access": true,
		"authors": [
			{
				"id": "5f3d38793b24c601ba77172c",
				"name": "Tatiana Bradley",
				"slug": "tatiana",
				"profile_image": "http://blog.cloudflare.com/content/images/2020/12/00100sPORTRAIT_00100_BURST20190127231051593_COVER-1.jpg",
				"cover_image": "https://blog-cloudflare-com-assets.storage.googleapis.com/2020/09/general@2x-2.png",
				"bio": null,
				"website": "http://www.tatianabradley.com",
				"location": "New York, New York",
				"facebook": null,
				"twitter": null,
				"meta_title": null,
				"meta_description": null,
				"url": "http://blog.cloudflare.com/author/tatiana/"
			}
		],
		"canonical_url": null,
		"codeinjection_foot": null,
		"codeinjection_head": null,
		"comment_id": "5fce59ca95ca4301baec17b5",
		"comments": false,
		"created_at": "2020-12-07T16:35:22.000+00:00",
		"custom_excerpt": "Imagine passwords for online services that never leave your device, encrypted or otherwise. OPAQUE is a new cryptographic protocol that makes this idea possible, giving you and only you full control of your password.",
		"custom_template": null,
		"email_subject": null,
		"excerpt": "Imagine passwords for online services that never leave your device, encrypted or otherwise. OPAQUE is a new cryptographic protocol that makes this idea possible, giving you and only you full control of your password.",
		"feature_image": "http://blog.cloudflare.com/content/images/2020/12/Opaque-Header.png",
		"feature_image_alt": null,
		"feature_image_caption": null,
		"featured": false,
		"frontmatter": null,
		"html": "<figure class=\"kg-card kg-image-card\"><img src=\"http://blog.cloudflare.com/content/images/2020/12/Opaque-Header-1.png\" class=\"kg-image\" alt loading=\"lazy\"></figure><p><em>Update: On January 19, 2022, we added <a href=\"https://opaque-full.research.cloudflare.com/\">a new demo for the OPAQUE protocol</a>.</em></p><p>Passwords are a problem. They are a problem for reasons that are familiar to most readers. For us at Cloudflare, the problem lies much deeper and broader. Most readers will immediately acknowledge that passwords are hard to remember and manage, especially as password requirements grow increasingly complex. Luckily there are great software packages and browser add-ons to help manage passwords. Unfortunately, the greater underlying problem is beyond the reaches of software to solve.</p><p>The fundamental password problem is simple to explain, but hard to solve: A password that leaves your possession is guaranteed to sacrifice security, no matter its complexity or how hard it may be to guess. Passwords are insecure by their very existence.</p><p>You might say, “but passwords are always stored in encrypted format!” That would be great. More accurately, they are likely stored as a salted hash, as explained below. Even worse is that there is no way to verify the way that passwords are stored, and so we can assume that on some servers passwords are stored in cleartext. The truth is that even responsibly stored passwords can be leaked and broken, albeit (and thankfully) with enormous effort. An increasingly pressing problem stems from the nature of passwords themselves: any direct use of a password, today, means that the password must be handled in the clear.</p><p>You say, “but my password is transmitted securely over HTTPS!” This is true.</p><p>You say, “but I know the server stores my password in hashed form, secure so no one can access it!” Well, this puts a lot of faith in the server. Even so, let’s just say that yes, this may be true, too.</p><p>There remains, however, an important caveat — a gap in the end-to-end use of passwords. Consider that once a server receives a password, between being securely transmitted and securely stored, the password has to be read and processed. Yes, as cleartext!</p><p>And it gets worse — because so many are used to thinking in software, it’s easy to forget about the vulnerability of hardware. This means that even if the software is somehow trusted, the password must at some point reside in memory. The password must at some point be transmitted over a shared bus to the CPU. These provide vectors of attack to on-lookers in many forms. Of course, these attack vectors are far less likely than those presented by transmission and permanent storage, but they are no less severe (recent CPU vulnerabilities such as Spectre and Meltdown should serve as a stark reminder.)</p><p>The only way to fix this problem is to get rid of passwords altogether. There is hope! Research and private sector communities are working hard to do just that. New standards are emerging and growing mature. Unfortunately, passwords are so ubiquitous that it will take a long time to agree on and supplant passwords with new standards and technology.</p><p>At Cloudflare, we’ve been asking if there is something that can be done now, imminently. Today’s deep-dive into OPAQUE is one possible answer. OPAQUE is one among many examples of systems that enable a password to be useful without it ever leaving your possession. No one likes passwords, but as long they’re in use, at least we can ensure they are never given away.</p><p>I’ll be the first to admit that password-based authentication is annoying. Passwords are hard to remember, tedious to type, and notoriously insecure. Initiatives to reduce or replace passwords are promising. For example, <a href=\"http://blog.cloudflare.com/cloudflare-now-supports-security-keys-with-web-authentication-webauthn/\">WebAuthn</a> is a standard for web authentication based primarily on public key cryptography using hardware <a href=\"https://github.com/github/SoftU2F\">(or software)</a> tokens. Even so, passwords are frustratingly persistent as an authentication mechanism. Whether their persistence is due to their ease of implementation, familiarity to users, or simple ubiquity on the web and elsewhere, we’d like to make password-based authentication as secure as possible while they persist.</p><p>My internship at Cloudflare focused on OPAQUE, a cryptographic protocol that solves one of the most glaring security issues with password-based authentication on the web: though passwords are typically protected in transit by HTTPS, <strong>servers</strong> <strong>handle them in plaintext </strong>to check their correctness. Handling plaintext passwords is dangerous, as accidentally logging or caching them could lead to a catastrophic breach. The goal of the project, rather than to advocate for adoption of any particular protocol, is to show that OPAQUE is a viable option among many for authentication. Because the web case is most familiar to me, and likely many readers, I will use the web as my main example.</p><h3 id=\"web-authentication-101-password-over-tls\">Web Authentication 101: Password-over-TLS</h3><p>When you type in a password on the web, what happens? The website must check that the password you typed is the same as the one you originally registered with the site. But how does this check work?</p><p>Usually, your username and password are sent to a server. The server then checks if the registered password associated with your username matches the password you provided. Of course, to prevent an attacker eavesdropping on your Internet traffic from stealing your password, your connection to the server should be encrypted via HTTPS (HTTP-over-TLS).</p><p>Despite use of HTTPS, there still remains a glaring problem in this flow: the server must store a representation of your password somewhere. Servers are hard to secure, and breaches are all too common. Leaking this representation can cause catastrophic security problems. (For records of the latest breaches, check out <a href=\"https://haveibeenpwned.com/\">https://haveibeenpwned.com/</a>).</p><p>To make these leaks less devastating, servers often apply a <em>hash function</em> to user passwords. A hash function maps each password to a unique, random-looking value. It’s easy to apply the hash to a password, but almost impossible to reverse the function and retrieve the password. (That said, anyone can guess a password, apply the hash function, and check if the result is the same.)</p><p>With password hashing, plaintext passwords are no longer stored on servers.  An attacker who steals a password database no longer has direct access to passwords. Instead, the attacker must apply the hash to many possible passwords and compare the results with the leaked hashes.</p><p>Unfortunately, if a server hashes only the passwords, attackers can download precomputed <em>rainbow tables </em>containing hashes of trillions of possible passwords and almost instantly retrieve the plaintext passwords. (See <a href=\"https://project-rainbowcrack.com/table.htm\">https://project-rainbowcrack.com/table.htm</a> for a list of some rainbow tables).</p><p>With this in mind, a good defense-in-depth strategy is to use <em>salted </em>hashing, where the server hashes your password appended to a random, per-user value called a <em>salt</em>. The server also saves the salt alongside the username, so the user never sees or needs to submit it. When the user submits a password, the server re-computes this hash function using the salt. An attacker who steals password data, i.e., the password representations and salt values, must then guess common passwords one by one and apply the (salted) hash function to each guessed password. Existing rainbow tables won’t help because they don’t take the salts into account, so the attacker needs to make a new rainbow table for each user!</p><p>This (hopefully) slows down the attack enough for the service to inform users of a breach, so they can change their passwords. In addition, the salted hashes should be <em>hardened</em> by applying a hash many times to further slow attacks. (See <a href=\"http://blog.cloudflare.com/keeping-passwords-safe-by-staying-up-to-date/\">https://blog.cloudflare.com/keeping-passwords-safe-by-staying-up-to-date/</a> for a more detailed discussion).</p><p>These two mitigation strategies — encrypting the password in transit and storing salted, hardened hashes — are the current best practices.</p><p>A large security hole remains open. <em>Password-over-TLS </em>(as we will call it) requires users to <strong>send plaintext passwords to servers during login</strong>, because servers must see these passwords to match against registered passwords on file. Even a well-meaning server could accidentally cache or log your password attempt(s), or become corrupted in the course of checking passwords. (For example, Facebook detected in 2019 that it had <a href=\"https://about.fb.com/news/2019/03/keeping-passwords-secure/\">accidentally been storing hundreds of millions of plaintext user passwords</a>). Ideally, servers should never see a plaintext password at all.</p><p>But that’s quite a conundrum: how can you check a password if you never see the password? Enter OPAQUE: a Password-Authenticated Key Exchange (PAKE) protocol that simultaneously proves knowledge of a password and derives a secret key. Before describing OPAQUE in detail, we’ll first summarize PAKE functionalities in general.</p><h3 id=\"password-proofs-with-password-authenticated-key-exchange\">Password Proofs with Password-Authenticated Key Exchange</h3><!--kg-card-begin: markdown--><p>Password-Authenticated Key Exchange (PAKE) was proposed by Bellovin and Merrit<sup>[1]</sup> in 1992, with an initial motivation of allowing password-authentication without the possibility of dictionary attacks based on data transmitted over an insecure channel.</p>\n<!--kg-card-end: markdown--><p>Essentially, a plain, or <em>symmetric</em>, PAKE is a cryptographic protocol that allows two parties who share only a password to establish a strong shared secret key. The goals of PAKE are:</p><p>1) The secret keys will match if the passwords match, and appear random otherwise.</p><p>2) Participants do not need to trust third parties (in particular, no Public Key Infrastructure),</p><p>3) The resulting secret key is not learned by anyone not participating in the protocol - including those who know the password.</p><p>4) The protocol does not reveal either parties’ password to each other (unless the passwords match), or to eavesdroppers.</p><p>In sum, the only way to successfully attack the protocol is to guess the password correctly while participating in the protocol. (Luckily, such attacks can be mostly thwarted by rate-limiting, i.e, blocking a user from logging in after a certain number of incorrect password attempts).</p><p>Given these requirements, password-over-TLS is clearly <em>not</em> a PAKE, because:</p><ul><li>It relies on WebPKI, which places trust in third-parties called Certificate Authorities (see <a href=\"http://blog.cloudflare.com/introducing-certificate-transparency-and-nimbus/\">https://blog.cloudflare.com/introducing-certificate-transparency-and-nimbus/</a> for an in-depth explanation of WebPKI and some of its shortcomings).</li><li>The user’s password is revealed to the server.</li><li>Password-over-TLS provides the user no assurance that the server knows their password or a derivative of it — a server could accept any input from the user with no checks whatsoever.</li></ul><p>That said, plain PAKE is still worse than Password-over-TLS, simply because it requires the server to <em>store </em>plaintext passwords. We need a PAKE that lets the server store salted hashes if we want to beat the current practice.</p><p>An improvement over plain PAKE is what’s called an <em>asymmetric</em> PAKE (aPAKE), because only the client knows the password, and the server knows a <em>hashed</em> password. An aPAKE has the four properties of PAKE, plus one more:</p><p>5) An attacker who steals password data stored on the server must perform a dictionary attack to retrieve the password.</p><p>The issue with most existing aPAKE protocols, however, is that they do not allow for a <em>salted</em> hash (or if they do, they require that salt to be transmitted to the user, which means the attacker has access to the salt beforehand and can begin computing a rainbow table for the user before stealing any data). We’d like, therefore, to upgrade the security property as follows:</p><p>5*) An attacker who steals password data stored on the server must perform a <em>per-user </em>dictionary attack to retrieve the password <em>after the data is compromised</em>.</p><p>OPAQUE is the first aPAKE protocol with a formal security proof that has this property: it allows for a completely secret salt.</p><h3 id=\"opaque-servers-safeguard-secrets-without-knowing-them-\">OPAQUE - Servers safeguard secrets without knowing them!</h3><figure class=\"kg-card kg-image-card\"><img src=\"http://blog.cloudflare.com/content/images/2020/12/opaque-wordmark.png\" class=\"kg-image\" alt loading=\"lazy\"></figure><p><a href=\"https://eprint.iacr.org/2018/163.pdf\">OPAQUE</a> is what’s referred to as a <em>strong aPAKE</em>, which simply means that it resists these pre-computation attacks by using a secretly salted hash on the server. OPAQUE was proposed and formally analyzed by Stanislaw Jarecki, Hugo Krawcyzk and Jiayu Xu in 2018 (full disclosure: Stanislaw Jarecki is my academic advisor). The name OPAQUE is a combination of the names of two cryptographic protocols: OPRF and PAKE. We already know PAKE, but what is an OPRF? OPRF stands for Oblivious Pseudo-Random Function, which is a protocol by which two parties compute a function <em>F(key, x)</em> that is deterministic but outputs random-looking values. One party inputs the value <em>x</em>, and another party inputs the key - the party who inputs <em>x</em> learns the result <em>F(key, x)</em> but not the key, and the party providing the key learns nothing.  (You can dive into the math of OPRFs here: <a href=\"http://blog.cloudflare.com/privacy-pass-the-math/\">https://blog.cloudflare.com/privacy-pass-the-math/</a>).</p><p>The core of OPAQUE is a method to store user secrets for safekeeping on a server, without giving the server access to those secrets. Instead of storing a traditional salted password hash, the server stores a secret envelope for you that is “locked” by two pieces of information: your password known only by you, and a random secret key (like a salt) known only by the server. To log in, the client initiates a cryptographic exchange that reveals the envelope key to the client, but, importantly, not to the server.</p><p>The server then sends the envelope to the user, who now can retrieve the encrypted keys. (The keys included in the envelope are a private-public key pair for the user, and a public key for the server.) These keys, once unlocked, will be the inputs to an Authenticated Key Exchange (AKE) protocol, which allows the user and server to establish a secret key which can be used to encrypt their future communication.</p><p>OPAQUE consists of two phases, being credential registration and login via key exchange.</p><h3 id=\"opaque-registration-phase\">OPAQUE: Registration Phase</h3><p>Before registration, the user first signs up for a service and picks a username and password. Registration begins with the OPRF flow we just described: Alice (the user) and Bob (the server) do an OPRF exchange. The result is that Alice has a random key <em><strong>rwd</strong></em>,<strong> </strong>derived from the OPRF output <em>F(key, pwd), where key</em> is a server-owned OPRF key specific to Alice and <em>pwd</em> is Alice’s password.</p><p>Within his OPRF message, Bob sends the public key for his OPAQUE identity. Alice then generates a new private/public key pair, which will be her persistent OPAQUE identity for Bob’s service, and encrypts <em>her</em> private key along with <em>Bob’s</em> public key with the <strong>rwd</strong> (we will call the result an <em>encrypted envelope</em>). She sends this encrypted envelope along with her public key (unencrypted) to Bob, who stores the data she provided, along with Alice’s specific OPRF keysecret, in a database indexed by her username.</p><figure class=\"kg-card kg-image-card\"><img src=\"http://blog.cloudflare.com/content/images/2020/12/OPAQUE-diagram-1@3x.png\" class=\"kg-image\" alt loading=\"lazy\"></figure><h3 id=\"opaque-login-phase\">OPAQUE: Login Phase</h3><p>The login phase is very similar. It starts the same way as registration — with an OPRF flow. However, on the server side, instead of generating a new OPRF key, Bob instead looks up the one he created during Alice’s registration. He does this by looking up Alice’s username (which she provides in the first message), and retrieving his record of her. This record contains her public key, her encrypted envelope, and Bob’s OPRF key for Alice.</p><p>He also sends over the encrypted envelope which Alice can decrypt with the output of the OPRF flow. (If decryption fails, she aborts the protocol — this likely indicates that she typed her password incorrectly, or Bob isn’t who he says he is). If decryption succeeds, she now has her own secret key and Bob’s public key. She inputs these into an AKE protocol with Bob, who, in turn, inputs his private key and her public key, which gives them both a fresh shared secret key.</p><figure class=\"kg-card kg-image-card\"><img src=\"http://blog.cloudflare.com/content/images/2020/12/OPAQUE-diagram-2@3x.png\" class=\"kg-image\" alt loading=\"lazy\"></figure><h3 id=\"integrating-opaque-with-an-ake\">Integrating OPAQUE with an AKE</h3><p>An important question to ask here is: what AKE is suitable for OPAQUE? The <a href=\"https://tools.ietf.org/html/draft-irtf-cfrg-opaque-01\">emerging CFRG specification</a> outlines several options, including 3DH and SIGMA-I. However, on the web, we already have an AKE at our disposal: TLS!</p><p>Recall that TLS is an AKE because it provides unilateral (and mutual) authentication with shared secret derivation. The core of TLS is a Diffie-Hellman key exchange, which by itself is <em>unauthenticated</em>, meaning that the parties running it have no way to verify who they are running it with. (This is a problem because when you log into your bank, or any other website that stores your private data, you want to be sure that they are who they say they are). Authentication primarily uses certificates, which are issued by trusted entities through a system called <a href=\"http://blog.cloudflare.com/how-to-build-your-own-public-key-infrastructure/\">Public Key Infrastructure (PKI)</a>. Each certificate is associated with a secret key. To prove its identity, the server presents its certificate to the client, and signs the TLS handshake with its secret key.</p><p>Modifying this ubiquitous certificate-based authentication on the web is perhaps not the best place to start. Instead, an improvement would be to authenticate the TLS shared secret, <em>using</em> OPAQUE, after the TLS handshake completes. In other words, once a server is authenticated with its typical WebPKI certificate, clients could subsequently authenticate to the server. This authentication could take place “post handshake” in the TLS connection using OPAQUE.</p><p><a href=\"https://datatracker.ietf.org/doc/draft-ietf-tls-exported-authenticator/\">Exported Authenticators</a> are one mechanism for “post-handshake” authentication in TLS. They allow a server or client to provide proof of an identity without setting up a new TLS connection. Recall that in the standard web case, the server establishes their identity with a certificate (proving, for example, that they are “cloudflare.com”). But if the same server also holds alternate identities, they must run TLS again to prove who they are.</p><p>The basic Exported Authenticator flow works resembles a classical challenge-response protocol, and works as follows. (We’ll consider the server authentication case only, as the client case is symmetric).</p><figure class=\"kg-card kg-image-card\"><img src=\"http://blog.cloudflare.com/content/images/2020/12/OPAQUE-diagram-3@3x.png\" class=\"kg-image\" alt loading=\"lazy\"></figure><p>At any point after a TLS connection is established, Alice (the client) sends an <em>authenticator request</em> to indicate that she would like Bob (the server) to prove an additional identity. This request includes a context (an unpredictable string — think of this as a challenge), and extensions which include information about what identity the client wants to be provided. For example, the client could include the SNI extension to ask the server for a certificate associated with a certain domain name other than the one initially used in the TLS connection.</p><p>On receipt of the client message, if the server has a valid certificate corresponding to the request, it sends back an <em>exported authenticator</em> which proves that it has the secret key for the certificate. (This message has the same format as an Auth message from the client in TLS 1.3 handshake - it contains a Certificate, a CertificateVerify and a Finished message). If the server cannot or does not wish to authenticate with the requested certificate, it replies with an empty authenticator which contains only a well formed Finished message.</p><p>The client then checks that the Exported Authenticator it receives is well-formed, and then verifies that the certificate presented is valid, and if so, accepts the new identity.</p><p>In sum, Exported Authenticators provide authentication in a higher layer (such as the application layer) safely by leveraging the well-vetted cryptography and message formats of TLS. Furthermore, it is tied to the TLS session so that authentication messages can't be copied and pasted from one TLS connection into another. In other words, Exported Authenticators provide exactly the right hooks needed to add OPAQUE-based authentication into TLS.</p><h3 id=\"opaque-with-exported-authenticators-opaque-ea-\">OPAQUE with Exported Authenticators (OPAQUE-EA)</h3><figure class=\"kg-card kg-image-card\"><img src=\"http://blog.cloudflare.com/content/images/2020/12/OPAQUE-diagram-2@3x-1.png\" class=\"kg-image\" alt loading=\"lazy\"></figure><p><a href=\"https://datatracker.ietf.org/doc/html/draft-sullivan-tls-opaque-00\">OPAQUE-EA</a> allows OPAQUE to run at any point after a TLS connection has already been set up. Recall that Bob (the server) will store his OPAQUE identity, in this case a signing key and verification key, and Alice will store her identity — encrypted — on Bob’s server. (The registration flow where Alice stores her encrypted keys is the same as in regular OPAQUE, except she stores a signing key, so we will skip straight to the login flow). Alice and Bob run two request-authenticate EA flows, one for each party, and OPAQUE protocol messages ride along in the extensions section of the EAs. Let’s look in detail how this works.</p><p>First, Alice generates her OPRF message based on her password. She creates an Authenticator Request asking for Bob’s OPAQUE identity, and includes (in the extensions field) her username and her OPRF message, and sends this to Bob over their established TLS connection.</p><p>Bob receives the message and looks up Alice’s username in his database. He retrieves her OPAQUE record containing her verification key and encrypted envelope, and his OPRF key. He uses the OPRF key on the OPRF message, and creates an Exported Authenticator proving ownership of his OPAQUE signing key, with an extension containing his OPRF message and the encrypted envelope. Additionally, he sends a new Authenticator Request asking Alice to prove ownership of her OPAQUE signing key.</p><p>Alice parses the message and completes the OPRF evaluation using Bob’s message to get output <em>rwd</em>, and uses <em>rwd</em> to decrypt the envelope. This reveals her signing key and Bob’s public key. She uses Bob’s public key to validate his Authenticator Response proof, and, if it checks out, she creates and sends an Exported Authenticator proving that she holds the newly decrypted signing key. Bob checks the validity of her Exported Authenticator, and if it checks out, he accepts her login.</p><h3 id=\"my-project-opaque-ea-over-https\">My project: OPAQUE-EA over HTTPS</h3><p>Everything described above is supported by lots and lots of theory that has yet to find its way into practice. My project was to turn the theory into reality. I started with written descriptions of <a href=\"https://tools.ietf.org/html/draft-ietf-tls-exported-authenticator-13\">Exported Authenticators</a>, <a href=\"https://tools.ietf.org/html/draft-irtf-cfrg-opaque-01\">OPAQUE</a>, and a preliminary draft of <a href=\"https://tools.ietf.org/html/draft-sullivan-tls-opaque-00\">OPAQUE-in-TLS</a>. My goal was to get from those to a working prototype.</p><p>My demo shows the feasibility of implementing OPAQUE-EA on the web, completely removing plaintext passwords from the wire, even encrypted. This provides a possible alternative to the current password-over-TLS flow with better security properties, but no visible change to the user.</p><p>A few of the implementation details are worth knowing. In computer science, abstraction is a powerful tool. It means that we can often rely on existing tools and APIs to avoid duplication of effort. In my project I relied heavily on <a href=\"https://github.com/bifurcation/mint\">mint</a>, an open-source implementation of TLS 1.3 in Go that is great for prototyping. I also used <a href=\"https://github.com/cloudflare/circl/tree/master/oprf\">CIRCL’s OPRF API</a>. I built libraries for Exported Authenticators, the core of OPAQUE, and OPAQUE-EA (which ties together the two).</p><p>I made the web demo by wrapping the OPAQUE-EA functionality in a simple HTTP server and client that pass messages to each other over HTTPS. Since a browser can’t run Go, I compiled from Go to WebAssembly (WASM) to get the Go functionality in the browser, and wrote a simple script in JavaScript to call the WASM functions needed.</p><p>Since current browsers do not give access to the underlying TLS connection on the client side, I had to implement a work-around to allow the client to access the exporter keys, namely, that the server simply computes the keys and sends them to the client over HTTPS. This workaround reduces the security of the resulting demo — it means that trust is placed in the server to provide the right keys. Even so, the user’s password is still safe, even if a malicious server provided bad keys— they just don’t have assurance that they actually previously registered with that server. However, in the future, browsers could include a mechanism to support exported keys and allow OPAQUE-EA to run with its full security properties.</p><p>You can explore my implementation <a href=\"https://github.com/cloudflare/opaque-ea\">on Github</a>, and even follow the instructions to spin up your own OPAQUE-EA test server and client. I’d like to stress, however, that the implementation is meant as a proof-of-concept only, and must not be used for production systems without significant further review.</p><h3 id=\"opaque-ea-limitations\">OPAQUE-EA Limitations</h3><p>Despite its great properties, there will definitely be some hurdles in bringing OPAQUE-EA from a proof-of-concept to a fully fledged authentication mechanism.</p><p><strong>Browser support for TLS exporter keys.</strong> As mentioned briefly before, to run OPAQUE-EA in a browser, you need to access secrets from the TLS connection called <em>exporter keys</em>. There is no way to do this in the current most popular browsers, so support for this functionality will need to be added.</p><p><strong>Overhauling password databases. </strong>To adopt OPAQUE-EA, servers need not only to update their password-checking logic, but also completely overhaul their password databases. Because OPAQUE relies on special password representations that can only be generated interactively, existing salted hashed passwords cannot be automatically updated to OPAQUE records. Servers will likely need to run a special OPAQUE registration flow on a user-by-user basis. Because OPAQUE relies on buy-in from both the client and the server, servers may need to support the old method for a while before all clients catch up.</p><p><strong>Reliance on emerging standards. </strong>OPAQUE-EA relies on OPRFs, which is in the process of standardization, and Exported Authenticators, a proposed standard. This means that support for these dependencies is not yet available in most existing cryptographic libraries, so early adopters may need to implement these tools themselves.</p><h3 id=\"summary\">Summary</h3><p>As long as people still use passwords, we’d like to make the process as secure as possible. Current methods rely on the risky practice of handling plaintext passwords on the server side while checking their correctness. PAKEs, and (specifically aPAKEs) allow secure password login without ever letting the server see the passwords.</p><p>OPAQUE is also being explored within other companies. According to Kevin Lewi, a research scientist from the Novi Research team at Facebook, they are “excited by the strong cryptographic guarantees provided by OPAQUE and are actively exploring OPAQUE as a method for further safeguarding credential-protected fields that are stored server-side.”</p><p>OPAQUE is one of the best aPAKEs out there, and can be fully integrated into TLS. You can check out the core OPAQUE implementation <a href=\"https://github.com/cloudflare/opaque-core\">here</a> and the demo TLS integration <a href=\"https://github.com/cloudflare/opaque-ea\">here</a>. A running version of the demo is also available <a href=\"https://opaque.research.cloudflare.com/\">here</a>. A Typescript client implementation of OPAQUE is coming soon. If you're interested in implementing the protocol, or encounter any bugs with the current implementation, please drop us a line at ask-research@cloudflare.com! Consider also subscribing to the <a href=\"https://irtf.org/cfrg\">IRTF CFRG mailing list</a> to track discussion about the OPAQUE specification and its standardization.</p><p>[1] Bellovin, S. M., and Merritt, M. “Encrypted key exchange: Password-based protocols secure against dictionary attacks.” In Proc. IEEE Computer Society Symposium on Research in Security and Privacy (Oakland, May 1992), pp. 72–84.</p>",
		"id": "5fce59ca95ca4301baec17b5",
		"meta_description": "Imagine passwords for online services that never leave your device, encrypted or otherwise. OPAQUE is a new cryptographic protocol that makes this idea possible, giving you and only you full control of your password.",
		"meta_title": null,
		"og_description": null,
		"og_image": "http://blog.cloudflare.com/content/images/2020/12/Copy-of-Open-Graph-Images-Template--1200x627----Q42020-5.png",
		"og_title": null,
		"primary_author": {
			"id": "5f3d38793b24c601ba77172c",
			"name": "Tatiana Bradley",
			"slug": "tatiana",
			"profile_image": "http://blog.cloudflare.com/content/images/2020/12/00100sPORTRAIT_00100_BURST20190127231051593_COVER-1.jpg",
			"cover_image": "https://blog-cloudflare-com-assets.storage.googleapis.com/2020/09/general@2x-2.png",
			"bio": null,
			"website": "http://www.tatianabradley.com",
			"location": "New York, New York",
			"facebook": null,
			"twitter": null,
			"meta_title": null,
			"meta_description": null,
			"url": "http://blog.cloudflare.com/author/tatiana/"
		},
		"primary_tag": {
			"id": "5fbd15e544c1c901bc48b3f5",
			"name": "Privacy Week",
			"slug": "privacy-week",
			"description": "Collection of Cloudflare blog posts tagged 'Privacy Week'.",
			"feature_image": null,
			"visibility": "public",
			"meta_title": null,
			"meta_description": "Collection of Cloudflare blog posts tagged 'Privacy Week'.",
			"og_image": null,
			"og_title": null,
			"og_description": null,
			"twitter_image": null,
			"twitter_title": null,
			"twitter_description": null,
			"codeinjection_head": null,
			"codeinjection_foot": null,
			"canonical_url": null,
			"accent_color": null,
			"url": "http://blog.cloudflare.com/tag/privacy-week/"
		},
		"published_at": "2020-12-08T12:00:00.000+00:00",
		"reading_time": 17,
		"slug": "opaque-oblivious-passwords",
		"tags": [
			{
				"id": "5fbd15e544c1c901bc48b3f5",
				"name": "Privacy Week",
				"slug": "privacy-week",
				"description": "Collection of Cloudflare blog posts tagged 'Privacy Week'.",
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": "Collection of Cloudflare blog posts tagged 'Privacy Week'.",
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/privacy-week/"
			},
			{
				"id": "5fce48a395ca4301baec175e",
				"name": "Research",
				"slug": "research",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/research/"
			},
			{
				"id": "5d16450341acde0011a9523f",
				"name": "Passwords",
				"slug": "passwords",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/passwords/"
			},
			{
				"id": "5fce48a395ca4301baec175f",
				"name": "Protocols",
				"slug": "protocols",
				"description": "Protocols (EN)",
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/protocols/"
			},
			{
				"id": "5d16450341acde0011a95265",
				"name": "Security",
				"slug": "security",
				"description": null,
				"feature_image": "http://blog.cloudflare.com/content/images/2020/10/Security.png",
				"visibility": "public",
				"meta_title": "Cloudflare Blog: Security",
				"meta_description": "Collection of Cloudflare blog posts tagged 'Security'.",
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/security/"
			},
			{
				"id": "6542e06bb368ff000a1322e8",
				"name": "Salt",
				"slug": "salt",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/salt/"
			}
		],
		"title": "OPAQUE: The Best Passwords Never Leave your Device",
		"twitter_description": null,
		"twitter_image": "http://blog.cloudflare.com/content/images/2020/12/Copy-of-Open-Graph-Images-Template--1200x627----Q42020-4.png",
		"twitter_title": null,
		"updated_at": "2023-11-01T23:35:43.000+00:00",
		"url": "http://blog.cloudflare.com/opaque-oblivious-passwords/",
		"uuid": "7a141b48-2e30-41ac-af6b-101fb41d2fe7",
		"visibility": "public"
	}
}