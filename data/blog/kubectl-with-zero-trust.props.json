{
	"locale": "en-us",
	"post": {
		"id": "62b4a3229dd27c000b7204c6",
		"uuid": "38df216f-a3f8-48d3-a5ce-e30031fabd8c",
		"title": "Kubectl with Cloudflare Zero Trust",
		"slug": "kubectl-with-zero-trust",
		"html": "<!--kg-card-begin: markdown--><p><em><small>This post is also available in <a href=\"http://blog.cloudflare.com/es-es/kubectl-with-zero-trust-es-es/\">Español</a>, <a href=\"http://blog.cloudflare.com/zh-cn/kubectl-with-zero-trust-zh-cn/\">简体中文</a>, <a href=\"http://blog.cloudflare.com/ja-jp/kubectl-with-zero-trust-ja-jp/\">日本語</a> and <a href=\"http://blog.cloudflare.com/ko-kr/kubectl-with-zero-trust-ko-kr/\">한국어</a>.</small></em></p>\n<!--kg-card-end: markdown--><figure class=\"kg-card kg-image-card\"><img src=\"http://blog.cloudflare.com/content/images/2022/06/Proxyless-KubeCTL-Support.png\" class=\"kg-image\" alt=\"Kubectl with Cloudflare Zero Trust\" loading=\"lazy\"></figure><p>Cloudflare is a heavy user of Kubernetes for engineering workloads: it's used to power the backend of our APIs, to handle batch-processing such as analytics aggregation and bot detection, and engineering tools such as our CI/CD pipelines. But between load balancers, API servers, etcd, ingresses, and pods, the surface area exposed by Kubernetes can be rather large.</p><p>In this post, we share a little bit about how our engineering team dogfoods Cloudflare Zero Trust to secure Kubernetes — and enables kubectl without proxies.</p><h2 id=\"our-general-approach-to-kubernetes-security\">Our General Approach to Kubernetes Security</h2><p>As part of our security measures, we heavily limit what can access our clusters over the network. Where a network service is exposed, we add additional protections, such as requiring Cloudflare Access authentication or Mutual TLS (or both) to access ingress resources.</p><p>These network restrictions include access to the cluster's API server. Without access to this, engineers at Cloudflare would not be able to use tools like kubectl to introspect their team's resources. While we believe Continuous Deployments and GitOps are best practices, allowing developers to use the Kubernetes API aids in troubleshooting and increasing developer velocity. Not having access would have been a deal breaker.</p><p>To satisfy our security requirements, we're using Cloudflare Zero Trust, and we wanted to share how we're using it, and the process that brought us here.</p><h3 id=\"before-zero-trust\">Before Zero Trust</h3><p>In the world before <a href=\"https://www.cloudflare.com/learning/security/glossary/what-is-zero-trust/\">Zero Trust</a>, engineers could access the Kubernetes API by connecting to a VPN appliance. While this is common across the industry, and it does allow access to the API, it also dropped engineers as clients into the internal network: they had much more network access than necessary.</p><p>We weren't happy with this situation, but it was the status quo for several years. At the beginning of 2020, we retired our VPN and thus the Kubernetes team needed to find another solution.</p><h3 id=\"kubernetes-with-cloudflare-tunnels\">Kubernetes with Cloudflare Tunnels</h3><p>At the time we worked closely with the team developing Cloudflare Tunnels to add support for handling <a href=\"http://blog.cloudflare.com/releasing-kubectl-support-in-access/\">kubectl connections using Access</a> and cloudflared tunnels.</p><p>While this worked for our engineering users, it was a significant hurdle to on-boarding new employees. Each Kubernetes cluster required its own tunnel connection from the engineer's device, which made shuffling between clusters annoying. While kubectl supported connecting through SOCKS proxies, this support was not universal to all tools in the Kubernetes ecosystem.</p><p>We continued using this solution internally while we worked towards a better solution.</p><h2 id=\"kubernetes-with-zero-trust\">Kubernetes with Zero Trust</h2><p>Since the launch of Cloudflare One, we've been dogfooding the Zero Trust agent in various configurations. At first we'd been using it to implement secure <a href=\"https://www.cloudflare.com/learning/dns/what-is-dns/\">DNS</a> with 1.1.1.1. As time went on, we began to use it to dogfood additional Zero Trust features.</p><p>We're now leveraging the private network routing in Cloudflare Zero Trust to allow engineers to access the Kubernetes APIs without needing to setup cloudflared tunnels or configure kubectl and other Kubernetes ecosystem tools to use tunnels. This isn't something specific to Cloudflare, you can do this for your team today!</p><figure class=\"kg-card kg-image-card\"><img src=\"http://blog.cloudflare.com/content/images/2022/06/Kubectl-WIth-Warp-Diagram--2-.png\" class=\"kg-image\" alt loading=\"lazy\"></figure><h3 id=\"configuring-zero-trust\">Configuring Zero Trust</h3><p>We use a <a href=\"https://github.com/cloudflare/terraform-provider-cloudflare\">configuration management tool</a> for our Zero Trust configuration to enable infrastructure-as-code, which we've adapted below. However, the same configuration can be achieved using the Cloudflare Zero Trust dashboard.</p><p>The first thing we need to do is create a new tunnel. This tunnel will be used to connect the Cloudflare edge network to the Kubernetes API. We run the tunnel endpoints within Kubernetes, using configuration shown later in this post.</p><pre><code>resource \"cloudflare_argo_tunnel\" \"k8s_zero_trust_tunnel\" {\n  account_id = var.account_id\n  name       = \"k8s_zero_trust_tunnel\"\n  secret     = var.tunnel_secret\n}\n</code></pre><p>The \"tunnel_secret\" secret should be a 32-byte random number, which you should temporarily save as we'll reuse it later for the Kubernetes setup later.</p><p>After we've created the tunnel, we need to create the routes so the Cloudflare network knows what traffic to send through the tunnel.</p><pre><code>resource \"cloudflare_tunnel_route\" \"k8s_zero_trust_tunnel_ipv4\" {\n  account_id = var.account_id\n  tunnel_id  = cloudflare_argo_tunnel.k8s_zero_trust_tunnel.id\n  network    = \"198.51.100.101/32\"\n  comment    = \"Kubernetes API Server (IPv4)\"\n}\n \nresource \"cloudflare_tunnel_route\" \"k8s_zero_trust_tunnel_ipv6\" {\n  account_id = var.account_id\n  tunnel_id  = cloudflare_argo_tunnel.k8s_zero_trust_tunnel.id\n  network    = \"2001:DB8::101/128\"\n  comment    = \"Kubernetes API Server (IPv6)\"\n}\n</code></pre><p>We support accessing the Kubernetes API via both IPv4 and IPv6 addresses, so we configure routes for both. If you're connecting to your API server via a hostname, these IP addresses should match what is returned via a DNS lookup.</p><p>Next we'll configure settings for Cloudflare Gateway so that it's compatible with the API servers and clients.</p><pre><code>resource \"cloudflare_teams_list\" \"k8s_apiserver_ips\" {\n  account_id = var.account_id\n  name       = \"Kubernetes API IPs\"\n  type       = \"IP\"\n  items      = [\"198.51.100.101/32\", \"2001:DB8::101/128\"]\n}\n \nresource \"cloudflare_teams_rule\" \"k8s_apiserver_zero_trust_http\" {\n  account_id  = var.account_id\n  name        = \"Don't inspect Kubernetes API\"\n  description = \"Allow connections from kubectl to API\"\n  precedence  = 10000\n  action      = \"off\"\n  enabled     = true\n  filters     = [\"http\"]\n  traffic     = format(\"any(http.conn.dst_ip[*] in $%s)\", replace(cloudflare_teams_list.k8s_apiserver_ips.id, \"-\", \"\"))\n}\n</code></pre><p>As we use mutual TLS between clients and the API server, and not all the traffic between kubectl and the API servers are HTTP, we've disabled HTTP inspection for these connections.</p><p>You can pair these rules with additional Zero Trust rules, such as <a href=\"https://developers.cloudflare.com/cloudflare-one/identity/devices/\">device attestation</a>, <a href=\"https://developers.cloudflare.com/cloudflare-one/policies/filtering/enforce-sessions/\">session lifetimes</a>, and <a href=\"https://developers.cloudflare.com/cloudflare-one/policies/filtering/identity-selectors/\">user and group</a> access policies to further customize your security.</p><h3 id=\"deploying-tunnels\">Deploying Tunnels</h3><p>Once you have your tunnels created and configured, you can deploy their endpoints into your network. We've chosen to deploy the tunnels as pods, as this allows us to use Kubernetes's deployment strategies for rolling out upgrades and handling node failures.</p><pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: tunnel-zt\n  namespace: example\n  labels:\n    tunnel: api-zt\ndata:\n  config.yaml: |\n    tunnel: 8e343b13-a087-48ea-825f-9783931ff2a5\n    credentials-file: /opt/zt/creds/creds.json\n    metrics: 0.0.0.0:8081\n    warp-routing:\n        enabled: true\n</code></pre><p>This creates a Kubernetes ConfigMap with a basic configuration that enables WARP routing for the tunnel ID specified. You can get this tunnel ID from your configuration management system, the Cloudflare Zero Trust dashboard, or by running the following command from another device logged into the same account.</p><p><code>cloudflared tunnel list</code></p><p>Next, we'll need to create a secret for our tunnel credentials. While you should use a secret management system, for simplicity we'll create one directly here.</p><pre><code>jq -cn --arg accountTag $CF_ACCOUNT_TAG \\\n       --arg tunnelID $CF_TUNNEL_ID \\\n       --arg tunnelName $CF_TUNNEL_NAME \\\n       --arg tunnelSecret $CF_TUNNEL_SECRET \\\n   '{AccountTag: $accountTag, TunnelID: $tunnelID, TunnelName: $tunnelName, TunnelSecret: $tunnelSecret}' | \\\nkubectl create secret generic -n example tunnel-creds --from-file=creds.json=/dev/stdin\n</code></pre><p>This creates a new secret \"tunnel-creds\" in the \"example\" namespace with the credentials file the tunnel expects.</p><p>Now we can deploy the tunnels themselves. We deploy multiple replicas to ensure some are always available, even while nodes are being drained.</p><pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  labels:\n    tunnel: api-zt\n  name: tunnel-api-zt\n  namespace: example\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      tunnel: api-zt\n  strategy:\n    rollingUpdate:\n      maxSurge: 0\n      maxUnavailable: 1\n  template:\n    metadata:\n      labels:\n        tunnel: api-zt\n    spec:\n      containers:\n        - args:\n            - tunnel\n            - --config\n            - /opt/zt/config/config.yaml\n            - run\n          env:\n            - name: GOMAXPROCS\n              value: \"2\"\n            - name: TZ\n              value: UTC\n          image: cloudflare/cloudflared:2022.5.3\n          livenessProbe:\n            failureThreshold: 1\n            httpGet:\n              path: /ready\n              port: 8081\n            initialDelaySeconds: 10\n            periodSeconds: 10\n          name: tunnel\n          ports:\n            - containerPort: 8081\n              name: http-metrics\n          resources:\n            limits:\n              cpu: \"1\"\n              memory: 100Mi\n          volumeMounts:\n            - mountPath: /opt/zt/config\n              name: config\n              readOnly: true\n            - mountPath: /opt/zt/creds\n              name: creds\n              readOnly: true\n      volumes:\n        - secret:\n            name: tunnel-creds\n          name: creds\n        - configMap:\n            name: tunnel-api-zt\n          name: config</code></pre><h2 id=\"using-kubectl-with-cloudflare-zero-trust\"> Using Kubectl with Cloudflare Zero Trust</h2><figure class=\"kg-card kg-image-card\"><img src=\"http://blog.cloudflare.com/content/images/2022/06/Screen-Shot-2022-06-23-at-3.43.37-PM.png\" class=\"kg-image\" alt=\"Screenshot of the Cloudflare WARP app showing it connected to Teams\" loading=\"lazy\"></figure><p>After deploying the Cloudflare Zero Trust agent, members of your team can now access the Kubernetes API without needing to set up any special SOCKS tunnels!</p><pre><code>kubectl version --short\nClient Version: v1.24.1\nServer Version: v1.24.1\n</code></pre><h2 id=\"what-s-next\">What's next?</h2><p>If you try this out, send us your feedback! We're continuing to improve Zero Trust for non-HTTP workflows.<br></p>",
		"comment_id": "62b4a3229dd27c000b7204c6",
		"feature_image": "http://blog.cloudflare.com/content/images/2022/06/Proxyless-KubeCTL-Support-1.png",
		"featured": false,
		"visibility": "public",
		"created_at": "2022-06-23T18:30:10.000+01:00",
		"updated_at": "2023-09-19T20:53:45.000+01:00",
		"published_at": "2022-06-24T15:08:51.000+01:00",
		"custom_excerpt": "Using Cloudflare Zero Trust with Kubernetes to enable kubectl without SOCKS proxies",
		"codeinjection_head": null,
		"codeinjection_foot": null,
		"custom_template": null,
		"canonical_url": null,
		"authors": [
			{
				"id": "5d1644b141acde0011a94f67",
				"name": "Terin Stock",
				"slug": "terin-stock",
				"profile_image": "http://blog.cloudflare.com/content/images/2022/08/terin-stock.png",
				"cover_image": "http://blog.cloudflare.com/content/images/2018/08/general@2x-141.png",
				"bio": null,
				"website": null,
				"location": null,
				"facebook": null,
				"twitter": "@terinjokes",
				"meta_title": null,
				"meta_description": null,
				"url": "http://blog.cloudflare.com/author/terin-stock/"
			}
		],
		"tags": [
			{
				"id": "62a09b1540b2cc000a678440",
				"name": "#BLOG-1190",
				"slug": "hash-blog-1190",
				"description": null,
				"feature_image": null,
				"visibility": "internal",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/404/"
			},
			{
				"id": "62a37ad540b2cc000a678853",
				"name": "Cloudflare One Week",
				"slug": "cloudflare-one-week",
				"description": null,
				"feature_image": "http://blog.cloudflare.com/content/images/2022/06/Cloudflare-One-Week-OG-theme.png",
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/cloudflare-one-week/"
			},
			{
				"id": "5d16450341acde0011a95265",
				"name": "Security",
				"slug": "security",
				"description": null,
				"feature_image": "http://blog.cloudflare.com/content/images/2020/10/Security.png",
				"visibility": "public",
				"meta_title": "Cloudflare Blog: Security",
				"meta_description": "Collection of Cloudflare blog posts tagged 'Security'.",
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/security/"
			},
			{
				"id": "5eafe962ad4c4401bca11b64",
				"name": "Zero Trust",
				"slug": "zero-trust",
				"description": null,
				"feature_image": "http://blog.cloudflare.com/content/images/2020/10/Zero-Trust.png",
				"visibility": "public",
				"meta_title": "Cloudflare Blog: Zero Trust",
				"meta_description": "Collection of Cloudflare blog posts tagged 'Zero Trust'.",
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/zero-trust/"
			},
			{
				"id": "5d16450341acde0011a9522b",
				"name": "Kubernetes",
				"slug": "kubernetes",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/kubernetes/"
			}
		],
		"primary_author": {
			"id": "5d1644b141acde0011a94f67",
			"name": "Terin Stock",
			"slug": "terin-stock",
			"profile_image": "http://blog.cloudflare.com/content/images/2022/08/terin-stock.png",
			"cover_image": "http://blog.cloudflare.com/content/images/2018/08/general@2x-141.png",
			"bio": null,
			"website": null,
			"location": null,
			"facebook": null,
			"twitter": "@terinjokes",
			"meta_title": null,
			"meta_description": null,
			"url": "http://blog.cloudflare.com/author/terin-stock/"
		},
		"primary_tag": null,
		"url": "http://blog.cloudflare.com/kubectl-with-zero-trust/",
		"excerpt": "Using Cloudflare Zero Trust with Kubernetes to enable kubectl without SOCKS proxies",
		"reading_time": 6,
		"access": true,
		"comments": false,
		"og_image": "http://blog.cloudflare.com/content/images/2022/06/Kubectl-with-Cloudflare-Zero-Trust-OG-1.png",
		"og_title": null,
		"og_description": null,
		"twitter_image": "http://blog.cloudflare.com/content/images/2022/06/Kubectl-with-Cloudflare-Zero-Trust-OG.png",
		"twitter_title": null,
		"twitter_description": null,
		"meta_title": null,
		"meta_description": "Using Cloudflare Zero Trust with Kubernetes to enable kubectl without SOCKS proxies",
		"email_subject": null,
		"frontmatter": null,
		"feature_image_alt": null,
		"feature_image_caption": null
	}
}