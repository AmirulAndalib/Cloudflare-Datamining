{
	"locale": "en-us",
	"post": {
		"access": true,
		"authors": [
			{
				"id": "62bb0e83b1b8d6000ba7d4e8",
				"name": "Frederick Lawler",
				"slug": "frederick",
				"profile_image": "http://blog.cloudflare.com/content/images/2023/01/profile-pic.jpg",
				"cover_image": null,
				"bio": null,
				"website": null,
				"location": null,
				"facebook": null,
				"twitter": null,
				"meta_title": null,
				"meta_description": null,
				"url": "http://blog.cloudflare.com/author/frederick/"
			}
		],
		"canonical_url": null,
		"codeinjection_foot": null,
		"codeinjection_head": null,
		"comment_id": "62bb02b4b1b8d6000ba7d47d",
		"comments": false,
		"created_at": "2022-06-28T14:31:32.000+01:00",
		"custom_excerpt": "Learn how to patch Linux security vulnerabilities without rebooting the hardware and how to tighten the security of your Linux operating system with eBPF Linux Security Module",
		"custom_template": null,
		"email_subject": null,
		"excerpt": "Learn how to patch Linux security vulnerabilities without rebooting the hardware and how to tighten the security of your Linux operating system with eBPF Linux Security Module",
		"feature_image": "http://blog.cloudflare.com/content/images/2022/06/Linux---Warp.png",
		"feature_image_alt": null,
		"feature_image_caption": null,
		"featured": false,
		"frontmatter": null,
		"html": "<!--kg-card-begin: markdown--><p><em><small>This post is also available in <a href=\"http://blog.cloudflare.com/zh-cn/live-patch-security-vulnerabilities-with-ebpf-lsm-zh-cn/\">简体中文</a> and <a href=\"http://blog.cloudflare.com/zh-tw/live-patch-security-vulnerabilities-with-ebpf-lsm-zh-tw/\">繁體中文</a>.</small></em></p>\n<!--kg-card-end: markdown--><figure class=\"kg-card kg-image-card\"><img src=\"http://blog.cloudflare.com/content/images/2022/06/image1-57.png\" class=\"kg-image\" alt=\"Live-patching security vulnerabilities inside the Linux kernel with eBPF Linux Security Module\" loading=\"lazy\"></figure><p><a href=\"https://www.kernel.org/doc/html/latest/admin-guide/LSM/index.html\">Linux Security Modules</a> (LSM) is a hook-based framework for implementing security policies and Mandatory Access Control in the Linux kernel. Until recently users looking to implement a security policy had just two options. Configure an existing LSM module such as AppArmor or SELinux, or write a custom kernel module.</p><p><a href=\"https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.7\">Linux 5.7</a> introduced a third way: <a href=\"https://docs.kernel.org/bpf/prog_lsm.html\">LSM extended Berkeley Packet Filters (eBPF)</a> (LSM BPF for short). LSM BPF allows developers to write granular policies without configuration or loading a kernel module. LSM BPF programs are verified on load, and then executed when an LSM hook is reached in a call path.</p><h2 id=\"let-s-solve-a-real-world-problem\">Let’s solve a real-world problem</h2><p>Modern operating systems provide facilities allowing \"partitioning\" of kernel resources. For example FreeBSD has \"jails\", Solaris has \"zones\". Linux is different - it provides a set of seemingly independent facilities each allowing isolation of a specific resource. These are called \"namespaces\" and have been growing in the kernel for years. They are the base of popular tools like Docker, lxc or firejail. Many of the namespaces are uncontroversial, like the UTS namespace which allows the host system to hide its hostname and time. Others are complex but straightforward - NET and NS (mount) namespaces are known to be hard to wrap your head around. Finally, there is this very special very curious USER namespace.</p><p>USER namespace is special, since it allows the owner to operate as \"root\" inside it. How it works is beyond the scope of this blog post, however, suffice to say it's a foundation to having tools like Docker to not operate as true root, and things like rootless containers.</p><p>Due to its nature, allowing unpriviledged users access to USER namespace always carried a great security risk.  One such risk is privilege escalation.</p><p>Privilege escalation is a common attack surface for operating systems. One way users may gain privilege is by mapping their namespace to the root namespace via the unshare <a href=\"https://en.wikipedia.org/wiki/System_call\">syscall</a> and specifying the <em>CLONE_NEWUSER</em> flag. This tells unshare to create a new user namespace with full permissions, and maps the new user and group ID to the previous namespace. You can use the <a href=\"https://man7.org/linux/man-pages/man1/unshare.1.html\">unshare(1)</a> program to map root to our original namespace:</p><!--kg-card-begin: markdown--><pre><code class=\"language-sh\">$ id\nuid=1000(fred) gid=1000(fred) groups=1000(fred) …\n$ unshare -rU\n# id\nuid=0(root) gid=0(root) groups=0(root),65534(nogroup)\n# cat /proc/self/uid_map\n         0       1000          1\n</code></pre>\n<!--kg-card-end: markdown--><p>In most cases using unshare is harmless, and is intended to run with lower privileges. However, this syscall has been known to be used to <a href=\"https://nvd.nist.gov/vuln/detail/CVE-2022-0492\">escalate privileges</a>.</p><p>Syscalls<em> clone</em> and <em>clone3</em> are worth looking into as they also have the ability to <em>CLONE_NEWUSER</em>. However, for this post we’re going to focus on unshare.</p><p>Debian solved this problem with this <a href=\"https://sources.debian.org/patches/linux/3.16.56-1+deb8u1/debian/add-sysctl-to-disallow-unprivileged-CLONE_NEWUSER-by-default.patch/\"> \"add sysctl to disallow unprivileged CLONE_NEWUSER by default\"</a> patch, but it was not mainlined. Another similar patch <a href=\"https://lore.kernel.org/all/1453502345-30416-3-git-send-email-keescook@chromium.org/\">\"sysctl: allow CLONE_NEWUSER to be disabled\"</a> attempted to mainline, and was met with push back. A critique is the <a href=\"https://lore.kernel.org/all/87poq5y0jw.fsf@x220.int.ebiederm.org/\">inability to toggle this feature</a> for specific applications. In the article “<a href=\"https://lwn.net/Articles/673597/\">Controlling access to user namespaces</a>” the author wrote: “... the current patches do not appear to have an easy path into the mainline.” And as we can see, the patches were ultimately not included in the vanilla kernel.</p><h2 id=\"our-solution-lsm-bpf\">Our solution - LSM BPF</h2><p>Since upstreaming code that restricts USER namespace seem to not be an option, we decided to use LSM BPF to circumvent these issues. This requires no modifications to the kernel and allows us to express complex rules guarding the access.</p><h3 id=\"track-down-an-appropriate-hook-candidate\">Track down an appropriate hook candidate</h3><p>First, let us track down the syscall we’re targeting. We can find the prototype in the <a href=\"https://elixir.bootlin.com/linux/v5.18/source/include/linux/syscalls.h#L608\"><em>include/linux/syscalls.h</em></a> file. From there, it’s not as obvious to track down, but the line:</p><!--kg-card-begin: markdown--><pre><code class=\"language-c\">/* kernel/fork.c */\n</code></pre>\n<!--kg-card-end: markdown--><p>Gives us a clue of where to look next in <a href=\"https://elixir.bootlin.com/linux/v5.18/source/kernel/fork.c#L3201\"><em>kernel/fork.c</em></a>. There a call to <a href=\"https://elixir.bootlin.com/linux/v5.18/source/kernel/fork.c#L3082\"><em>ksys_unshare()</em></a> is made. Digging through that function, we find a call to <a href=\"https://elixir.bootlin.com/linux/v5.18/source/kernel/fork.c#L3129\"><em>unshare_userns()</em></a>. This looks promising.</p><p>Up to this point, we’ve identified the syscall implementation, but the next question to ask is what hooks are available for us to use? Because we know from the <a href=\"https://man7.org/linux/man-pages/man2/unshare.2.html\">man-pages</a> that unshare is used to mutate tasks, we look at the task-based hooks in <a href=\"https://elixir.bootlin.com/linux/v5.18/source/include/linux/lsm_hooks.h#L605\"><em>include/linux/lsm_hooks.h</em></a>. Back in the function <a href=\"https://elixir.bootlin.com/linux/v5.18/source/kernel/user_namespace.c#L171\"><em>unshare_userns()</em></a><em> </em>we saw a call to <a href=\"https://elixir.bootlin.com/linux/v5.18/source/kernel/cred.c#L252\"><em>prepare_creds()</em></a>. This looks very familiar to the <a href=\"https://elixir.bootlin.com/linux/v5.18/source/include/linux/lsm_hooks.h#L624\"><em>cred_prepare</em></a> hook. To verify we have our match via <a href=\"https://elixir.bootlin.com/linux/v5.18/source/kernel/cred.c#L291\"><em>prepare_creds()</em></a>, we see a call to the security hook <a href=\"https://elixir.bootlin.com/linux/v5.18/source/security/security.c#L1706\"><em>security_prepare_creds()</em></a><em> </em>which ultimately calls the hook:</p><!--kg-card-begin: markdown--><pre><code class=\"language-c\">…\nrc = call_int_hook(cred_prepare, 0, new, old, gfp);\n…\n</code></pre>\n<!--kg-card-end: markdown--><p>Without going much further down this rabbithole, we know this is a good hook to use because <em>prepare_creds()</em> is called right before <em>create_user_ns()</em> in <a href=\"https://elixir.bootlin.com/linux/v5.18/source/kernel/user_namespace.c#L181\"><em>unshare_userns()</em></a> which is the operation we’re trying to block.</p><h3 id=\"lsm-bpf-solution\">LSM BPF solution</h3><p>We’re going to compile with the <a href=\"https://nakryiko.com/posts/bpf-core-reference-guide/#defining-own-co-re-relocatable-type-definitions\">eBPF compile once-run everywhere (CO-RE)</a> approach. This allows us to compile on one architecture and load on another. But we’re going to target x86_64 specifically. LSM BPF for ARM64 is still in development, and the following code will not run on that architecture. Watch the <a href=\"https://lore.kernel.org/bpf/\">BPF mailing list</a> to follow the progress.</p><p>This solution was tested on kernel versions &gt;= 5.15 configured with the following:</p><!--kg-card-begin: markdown--><pre><code>BPF_EVENTS\nBPF_JIT\nBPF_JIT_ALWAYS_ON\nBPF_LSM\nBPF_SYSCALL\nBPF_UNPRIV_DEFAULT_OFF\nDEBUG_INFO_BTF\nDEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT\nDYNAMIC_FTRACE\nFUNCTION_TRACER\nHAVE_DYNAMIC_FTRACE\n</code></pre>\n<!--kg-card-end: markdown--><p>A boot option <code>lsm=bpf</code> may be necessary if <code>CONFIG_LSM</code> does not contain “bpf” in the list.</p><p>Let’s start with our preamble:</p><p><em>deny_unshare.bpf.c</em>:</p><!--kg-card-begin: markdown--><pre><code class=\"language-c\">#include &lt;linux/bpf.h&gt;\n#include &lt;linux/capability.h&gt;\n#include &lt;linux/errno.h&gt;\n#include &lt;linux/sched.h&gt;\n#include &lt;linux/types.h&gt;\n\n#include &lt;bpf/bpf_tracing.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_core_read.h&gt;\n\n#define X86_64_UNSHARE_SYSCALL 272\n#define UNSHARE_SYSCALL X86_64_UNSHARE_SYSCALL\n</code></pre>\n<!--kg-card-end: markdown--><p>Next we set up our necessary structures for CO-RE relocation in the following way:</p><p><em>deny_unshare.bpf.c</em>:</p><!--kg-card-begin: markdown--><pre><code class=\"language-c\">…\n\ntypedef unsigned int gfp_t;\n\nstruct pt_regs {\n\tlong unsigned int di;\n\tlong unsigned int orig_ax;\n} __attribute__((preserve_access_index));\n\ntypedef struct kernel_cap_struct {\n\t__u32 cap[_LINUX_CAPABILITY_U32S_3];\n} __attribute__((preserve_access_index)) kernel_cap_t;\n\nstruct cred {\n\tkernel_cap_t cap_effective;\n} __attribute__((preserve_access_index));\n\nstruct task_struct {\n    unsigned int flags;\n    const struct cred *cred;\n} __attribute__((preserve_access_index));\n\nchar LICENSE[] SEC(&quot;license&quot;) = &quot;GPL&quot;;\n\n…\n</code></pre>\n<!--kg-card-end: markdown--><p>We don’t need to fully-flesh out the structs; we just need the absolute minimum information a program needs to function. CO-RE will do whatever is necessary to perform the relocations for your kernel. This makes writing the LSM BPF programs easy!</p><p><em>deny_unshare.bpf.c</em>:</p><!--kg-card-begin: markdown--><pre><code class=\"language-c\">SEC(&quot;lsm/cred_prepare&quot;)\nint BPF_PROG(handle_cred_prepare, struct cred *new, const struct cred *old,\n             gfp_t gfp, int ret)\n{\n    struct pt_regs *regs;\n    struct task_struct *task;\n    kernel_cap_t caps;\n    int syscall;\n    unsigned long flags;\n\n    // If previous hooks already denied, go ahead and deny this one\n    if (ret) {\n        return ret;\n    }\n\n    task = bpf_get_current_task_btf();\n    regs = (struct pt_regs *) bpf_task_pt_regs(task);\n    // In x86_64 orig_ax has the syscall interrupt stored here\n    syscall = regs-&gt;orig_ax;\n    caps = task-&gt;cred-&gt;cap_effective;\n\n    // Only process UNSHARE syscall, ignore all others\n    if (syscall != UNSHARE_SYSCALL) {\n        return 0;\n    }\n\n    // PT_REGS_PARM1_CORE pulls the first parameter passed into the unshare syscall\n    flags = PT_REGS_PARM1_CORE(regs);\n\n    // Ignore any unshare that does not have CLONE_NEWUSER\n    if (!(flags &amp; CLONE_NEWUSER)) {\n        return 0;\n    }\n\n    // Allow tasks with CAP_SYS_ADMIN to unshare (already root)\n    if (caps.cap[CAP_TO_INDEX(CAP_SYS_ADMIN)] &amp; CAP_TO_MASK(CAP_SYS_ADMIN)) {\n        return 0;\n    }\n\n    return -EPERM;\n}\n</code></pre>\n<!--kg-card-end: markdown--><p>Creating the program is the first step, the second is loading and attaching the program to our desired hook. There are several ways to do this: <a href=\"https://github.com/cilium/ebpf\">Cilium ebpf</a> project, <a href=\"https://github.com/libbpf/libbpf-rs\">Rust bindings</a>, and several others on the <a href=\"https://ebpf.io/projects/\">ebpf.io</a> project landscape page. We’re going to use native libbpf.</p><p><em>deny_unshare.c</em>:</p><!--kg-card-begin: markdown--><pre><code class=\"language-c\">#include &lt;bpf/libbpf.h&gt;\n#include &lt;unistd.h&gt;\n#include &quot;deny_unshare.skel.h&quot;\n\nstatic int libbpf_print_fn(enum libbpf_print_level level, const char *format, va_list args)\n{\n    return vfprintf(stderr, format, args);\n}\n\nint main(int argc, char *argv[])\n{\n    struct deny_unshare_bpf *skel;\n    int err;\n\n    libbpf_set_strict_mode(LIBBPF_STRICT_ALL);\n    libbpf_set_print(libbpf_print_fn);\n\n    // Loads and verifies the BPF program\n    skel = deny_unshare_bpf__open_and_load();\n    if (!skel) {\n        fprintf(stderr, &quot;failed to load and verify BPF skeleton\\n&quot;);\n        goto cleanup;\n    }\n\n    // Attaches the loaded BPF program to the LSM hook\n    err = deny_unshare_bpf__attach(skel);\n    if (err) {\n        fprintf(stderr, &quot;failed to attach BPF skeleton\\n&quot;);\n        goto cleanup;\n    }\n\n    printf(&quot;LSM loaded! ctrl+c to exit.\\n&quot;);\n\n    // The BPF link is not pinned, therefore exiting will remove program\n    for (;;) {\n        fprintf(stderr, &quot;.&quot;);\n        sleep(1);\n    }\n\ncleanup:\n    deny_unshare_bpf__destroy(skel);\n    return err;\n}\n</code></pre>\n<!--kg-card-end: markdown--><p>Lastly, to compile, we use the following Makefile:</p><p><em>Makefile</em>:</p><!--kg-card-begin: markdown--><pre><code class=\"language-makefile\">CLANG ?= clang-13\nLLVM_STRIP ?= llvm-strip-13\nARCH := x86\nINCLUDES := -I/usr/include -I/usr/include/x86_64-linux-gnu\nLIBS_DIR := -L/usr/lib/lib64 -L/usr/lib/x86_64-linux-gnu\nLIBS := -lbpf -lelf\n\n.PHONY: all clean run\n\nall: deny_unshare.skel.h deny_unshare.bpf.o deny_unshare\n\nrun: all\n\tsudo ./deny_unshare\n\nclean:\n\trm -f *.o\n\trm -f deny_unshare.skel.h\n\n#\n# BPF is kernel code. We need to pass -D__KERNEL__ to refer to fields present\n# in the kernel version of pt_regs struct. uAPI version of pt_regs (from ptrace)\n# has different field naming.\n# See: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=fd56e0058412fb542db0e9556f425747cf3f8366\n#\ndeny_unshare.bpf.o: deny_unshare.bpf.c\n\t$(CLANG) -g -O2 -Wall -target bpf -D__KERNEL__ -D__TARGET_ARCH_$(ARCH) $(INCLUDES) -c $&lt; -o $@\n\t$(LLVM_STRIP) -g $@ # Removes debug information\n\ndeny_unshare.skel.h: deny_unshare.bpf.o\n\tsudo bpftool gen skeleton $&lt; &gt; $@\n\ndeny_unshare: deny_unshare.c deny_unshare.skel.h\n\t$(CC) -g -Wall -c $&lt; -o $@.o\n\t$(CC) -g -o $@ $(LIBS_DIR) $@.o $(LIBS)\n\n.DELETE_ON_ERROR:\n</code></pre>\n<!--kg-card-end: markdown--><h3 id=\"result\">Result</h3><p>In a new terminal window run:</p><!--kg-card-begin: markdown--><pre><code class=\"language-sh\">$ make run\n…\nLSM loaded! ctrl+c to exit.\n</code></pre>\n<!--kg-card-end: markdown--><p>In another terminal window, we’re successfully blocked!</p><!--kg-card-begin: markdown--><pre><code class=\"language-sh\">$ unshare -rU\nunshare: unshare failed: Cannot allocate memory\n$ id\nuid=1000(fred) gid=1000(fred) groups=1000(fred) …\n</code></pre>\n<!--kg-card-end: markdown--><p>The policy has an additional feature to always allow privilege pass through:</p><!--kg-card-begin: markdown--><pre><code class=\"language-sh\">$ sudo unshare -rU\n# id\nuid=0(root) gid=0(root) groups=0(root)\n</code></pre>\n<!--kg-card-end: markdown--><p>In the unprivileged case the syscall early aborts. What is the performance impact in the privileged case?</p><h3 id=\"measure-performance\">Measure performance</h3><p>We’re going to use a one-line unshare that’ll map the user namespace, and execute a command within for the measurements:</p><!--kg-card-begin: markdown--><pre><code class=\"language-sh\">$ unshare -frU --kill-child -- bash -c &quot;exit 0&quot;\n</code></pre>\n<!--kg-card-end: markdown--><p>With a resolution of CPU cycles for syscall unshare enter/exit, we’ll measure the following as root user:</p><ol><li>Command ran without the policy</li><li>Command run with the policy</li></ol><p>We’ll record the measurements with <a href=\"https://docs.kernel.org/trace/ftrace.html\">ftrace</a>:</p><!--kg-card-begin: markdown--><pre><code class=\"language-sh\">$ sudo su\n# cd /sys/kernel/debug/tracing\n# echo 1 &gt; events/syscalls/sys_enter_unshare/enable ; echo 1 &gt; events/syscalls/sys_exit_unshare/enable\n</code></pre>\n<!--kg-card-end: markdown--><p>At this point, we’re enabling tracing for the syscall enter and exit for unshare specifically. Now we set the time-resolution of our enter/exit calls to count CPU cycles:</p><!--kg-card-begin: markdown--><pre><code class=\"language-sh\"># echo 'x86-tsc' &gt; trace_clock \n</code></pre>\n<!--kg-card-end: markdown--><p>Next we begin our measurements:</p><!--kg-card-begin: markdown--><pre><code class=\"language-sh\"># unshare -frU --kill-child -- bash -c &quot;exit 0&quot; &amp;\n[1] 92014\n</code></pre>\n<!--kg-card-end: markdown--><p>Run the policy in a new terminal window, and then run our next syscall:</p><!--kg-card-begin: markdown--><pre><code class=\"language-sh\"># unshare -frU --kill-child -- bash -c &quot;exit 0&quot; &amp;\n[2] 92019\n</code></pre>\n<!--kg-card-end: markdown--><p>Now we have our two calls for comparison:</p><!--kg-card-begin: markdown--><pre><code class=\"language-sh\"># cat trace\n# tracer: nop\n#\n# entries-in-buffer/entries-written: 4/4   #P:8\n#\n#                                _-----=&gt; irqs-off\n#                               / _----=&gt; need-resched\n#                              | / _---=&gt; hardirq/softirq\n#                              || / _--=&gt; preempt-depth\n#                              ||| / _-=&gt; migrate-disable\n#                              |||| /     delay\n#           TASK-PID     CPU#  |||||  TIMESTAMP  FUNCTION\n#              | |         |   |||||     |         |\n         unshare-92014   [002] ..... 762950852559027: sys_unshare(unshare_flags: 10000000)\n         unshare-92014   [002] ..... 762950852622321: sys_unshare -&gt; 0x0\n         unshare-92019   [007] ..... 762975980681895: sys_unshare(unshare_flags: 10000000)\n         unshare-92019   [007] ..... 762975980752033: sys_unshare -&gt; 0x0\n\n</code></pre>\n<!--kg-card-end: markdown--><p>unshare-92014 used 63294 cycles.<br>unshare-92019 used 70138 cycles.</p><p>We have a 6,844 (~10%) cycle penalty between the two measurements. Not bad!</p><p>These numbers are for a single syscall, and add up the more frequently the code is called. Unshare is typically called at task creation, and not repeatedly during normal execution of a program. Careful consideration and measurement is needed for your use case.</p><h2 id=\"outro\">Outro</h2><p>We learned a bit about what LSM BPF is, how unshare is used to map a user to root, and how to solve a real-world problem by implementing a solution in eBPF. Tracking down the appropriate hook is not an easy task, and requires a bit of playing and a lot of kernel code. Fortunately, that’s the hard part. Because a policy is written in C, we can granularly tweak the policy to our problem. This means one may extend this policy with an allow-list to allow certain programs or users to continue to use an unprivileged unshare. Finally, we looked at the performance impact of this program, and saw the overhead is worth blocking the attack vector.</p><p>“Cannot allocate memory” is not a clear error message for denying permissions. We proposed a <a href=\"https://lore.kernel.org/all/20220608150942.776446-1-fred@cloudflare.com/\">patch</a> to propagate error codes from the <em>cred_prepare</em> hook up the call stack. Ultimately we came to the conclusion that a new hook is better suited to this problem. Stay tuned!</p>",
		"id": "62bb02b4b1b8d6000ba7d47d",
		"meta_description": "Learn how to patch Linux security vulnerabilities without rebooting the hardware and how to tighten the security of your Linux operating system with eBPF Linux Security Module.",
		"meta_title": null,
		"og_description": null,
		"og_image": "http://blog.cloudflare.com/content/images/2022/06/Live-patching-security-vulnerabilities-inside-the-Linux-kernel-with-eBPF-Linux-Security-Module-OG-1.png",
		"og_title": null,
		"primary_author": {
			"id": "62bb0e83b1b8d6000ba7d4e8",
			"name": "Frederick Lawler",
			"slug": "frederick",
			"profile_image": "http://blog.cloudflare.com/content/images/2023/01/profile-pic.jpg",
			"cover_image": null,
			"bio": null,
			"website": null,
			"location": null,
			"facebook": null,
			"twitter": null,
			"meta_title": null,
			"meta_description": null,
			"url": "http://blog.cloudflare.com/author/frederick/"
		},
		"primary_tag": null,
		"published_at": "2022-06-29T12:45:00.000+01:00",
		"reading_time": 8,
		"slug": "live-patch-security-vulnerabilities-with-ebpf-lsm",
		"tags": [
			{
				"id": "62bb0d99b1b8d6000ba7d4ce",
				"name": "#BLOG-1200",
				"slug": "hash-blog-1200",
				"description": null,
				"feature_image": null,
				"visibility": "internal",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/404/"
			},
			{
				"id": "5d16450341acde0011a951ff",
				"name": "Linux",
				"slug": "linux",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/linux/"
			},
			{
				"id": "5d16450341acde0011a95265",
				"name": "Security",
				"slug": "security",
				"description": null,
				"feature_image": "http://blog.cloudflare.com/content/images/2020/10/Security.png",
				"visibility": "public",
				"meta_title": "Cloudflare Blog: Security",
				"meta_description": "Collection of Cloudflare blog posts tagged 'Security'.",
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/security/"
			},
			{
				"id": "5d16450341acde0011a9531b",
				"name": "Deep Dive",
				"slug": "deep-dive",
				"description": null,
				"feature_image": "http://blog.cloudflare.com/content/images/2023/08/CloudflareBlog-DeepDive.png",
				"visibility": "public",
				"meta_title": "Cloudflare Blog: Deep Dive",
				"meta_description": "Collection of Cloudflare blog posts tagged 'Deep Dive'.",
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/deep-dive/"
			},
			{
				"id": "5d16450341acde0011a95214",
				"name": "Programming",
				"slug": "programming",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/programming/"
			}
		],
		"title": "Live-patching security vulnerabilities inside the Linux kernel with eBPF Linux Security Module",
		"twitter_description": null,
		"twitter_image": "http://blog.cloudflare.com/content/images/2022/06/Live-patching-security-vulnerabilities-inside-the-Linux-kernel-with-eBPF-Linux-Security-Module-OG.png",
		"twitter_title": null,
		"updated_at": "2022-08-15T11:11:08.000+01:00",
		"url": "http://blog.cloudflare.com/live-patch-security-vulnerabilities-with-ebpf-lsm/",
		"uuid": "b923d94b-b6be-46ca-ae30-0404bf53d86b",
		"visibility": "public"
	}
}