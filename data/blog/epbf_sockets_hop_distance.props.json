{
	"browserLocale": "en-us",
	"locale": "en-us",
	"post": {
		"access": true,
		"authors": [
			{
				"id": "5d1644b141acde0011a94f30",
				"name": "Marek Majkowski",
				"slug": "marek-majkowski",
				"profile_image": "http://blog.cloudflare.com/content/images/2017/03/b5967d6c687939594adb6992723d0529.jpeg",
				"cover_image": "http://blog.cloudflare.com/content/images/2018/08/general@2x-101.png",
				"bio": null,
				"website": null,
				"location": null,
				"facebook": null,
				"twitter": "@majek04",
				"meta_title": null,
				"meta_description": null,
				"url": "http://blog.cloudflare.com/author/marek-majkowski/"
			}
		],
		"canonical_url": null,
		"codeinjection_foot": null,
		"codeinjection_head": null,
		"comment_id": "5abb52529f6c680022cdc571",
		"comments": false,
		"created_at": "2018-03-28T09:29:06.000+01:00",
		"custom_excerpt": "A friend gave me an interesting task: extract IP TTL values from TCP connections established by a userspace program. This seemingly simple task quickly exploded into an epic Linux system programming hack. ",
		"custom_template": null,
		"email_subject": null,
		"excerpt": "A friend gave me an interesting task: extract IP TTL values from TCP connections established by a userspace program. This seemingly simple task quickly exploded into an epic Linux system programming hack. ",
		"feature_image": "http://blog.cloudflare.com/content/images/2018/03/3845353725_7d7c624f34_z-1.jpg",
		"feature_image_alt": null,
		"feature_image_caption": null,
		"featured": false,
		"frontmatter": null,
		"html": "<!--kg-card-begin: markdown--><p>A friend gave me an interesting task: extract IP TTL values from TCP connections established by a userspace program. This seemingly simple task quickly exploded into an epic Linux system programming hack. The result code is grossly over engineered, but boy, did we learn plenty in the process!</p>\n<p><img src=\"http://blog.cloudflare.com/content/images/2018/03/3845353725_7d7c624f34_z.jpg\" alt=\"3845353725_7d7c624f34_z\" loading=\"lazy\"><br>\n<small><a href=\"https://creativecommons.org/licenses/by-sa/2.0/\">CC BY-SA 2.0</a> <a href=\"https://www.flickr.com/photos/paulmiller/3845353725/\">image</a> by <a href=\"https://www.flickr.com/photos/paulmiller\">Paul Miller</a></small></p>\n<h3 id=\"context\">Context</h3>\n<p>You may wonder why she wanted to inspect the TTL packet field (formally known as &quot;IP Time To Live (TTL)&quot; in IPv4, or &quot;Hop Count&quot; in IPv6)? The reason is simple - she wanted to ensure that the connections are routed outside of our datacenter. The &quot;Hop Distance&quot; - the difference between the TTL value set by the originating machine and the TTL value in the packet received at its destination - shows how many routers the packet crossed. If a packet crossed two or more routers, we know it indeed came from outside of our datacenter.</p>\n<p><img src=\"http://blog.cloudflare.com/content/images/2018/03/Screen-Shot-2018-03-29-at-10.52.49-AM-1.png\" alt=\"Screen-Shot-2018-03-29-at-10.52.49-AM-1\" loading=\"lazy\"></p>\n<p>It's uncommon to look at TTL values (except for their intended purpose of mitigating routing loops by checking when the TTL reaches zero). The normal way to deal with the problem we had would be to blocklist IP ranges of our servers. But it’s not that simple in our setup. Our IP numbering configuration is rather baroque, with plenty of Anycast, Unicast and Reserved IP ranges. Some belong to us, some don't. We wanted to avoid having to maintain a hard-coded blocklist of IP ranges.</p>\n<p>The gist of the idea is: we want to note the TTL value from a returned SYN+ACK packet. Having this number we can estimate the Hop Distance - number of routers on the path. If the Hop Distance is:</p>\n<p><img src=\"http://blog.cloudflare.com/content/images/2018/03/Screen-Shot-2018-03-29-at-10.50.38-AM.png\" alt=\"Screen-Shot-2018-03-29-at-10.50.38-AM\" loading=\"lazy\"></p>\n<ul>\n<li><strong>zero</strong>: we know the connection went to localhost or a local network.</li>\n</ul>\n<p><img src=\"http://blog.cloudflare.com/content/images/2018/03/Screen-Shot-2018-03-29-at-10.49.42-AM.png\" alt=\"Screen-Shot-2018-03-29-at-10.49.42-AM\" loading=\"lazy\"></p>\n<ul>\n<li><strong>one</strong>: connection went through our router, and was terminated just behind it.</li>\n</ul>\n<p><img src=\"http://blog.cloudflare.com/content/images/2018/03/Screen-Shot-2018-03-29-at-10.49.48-AM.png\" alt=\"Screen-Shot-2018-03-29-at-10.49.48-AM\" loading=\"lazy\"></p>\n<ul>\n<li><strong>two</strong>: connection went through two routers. Most possibly our router, and one just near to it.</li>\n</ul>\n<p>For our use case, we want to see if the Hop Distance was two or more - this would ensure the connection was routed outside the datacenter.</p>\n<h3 id=\"notsoeasy\">Not so easy</h3>\n<p>It's easy to read TTL values from a userspace application, right? No. It turns out it's almost impossible. Here are the theoretical options we considered early on:</p>\n<p>A) Run a libpcap/tcpdump-like raw socket, and catch the SYN+ACK's manually. We ruled out this design quickly - it requires elevated privileges. Also, raw sockets are pretty fragile: they can suffer packet loss if the userspace application can’t keep up.</p>\n<p>B) Use the IP_RECVTTL socket option. IP_RECVTTL requests a &quot;cmsg&quot; data to be attached to control/ancillary data in a <code>recvmsg()</code> syscall. This is a good choice for UDP connections, but this socket option is not supported by TCP SOCK_STREAM sockets.</p>\n<p>Extracting the TTL is not so easy.</p>\n<h3 id=\"so_attach_filtertoruletheworld\">SO_ATTACH_FILTER to rule the world!</h3>\n<p><img src=\"http://blog.cloudflare.com/content/images/2018/03/315128991_d49c312fbc_z.jpg\" alt=\"315128991_d49c312fbc_z\" loading=\"lazy\"><br>\n<small><a href=\"https://creativecommons.org/licenses/by-sa/2.0/\">CC BY-SA 2.0</a> <a href=\"https://www.flickr.com/photos/leejordan/315128991/\">image</a> by <a href=\"https://www.flickr.com/photos/leejordan/\">Lee Jordan</a></small></p>\n<p>Wait, there is a third way!</p>\n<p>You see, for quite some time it has been possible to attach a BPF filtering program to a socket. See <a href=\"http://man7.org/linux/man-pages/man7/socket.7.html\"><code>socket(7)</code></a></p>\n<pre><code>SO_ATTACH_FILTER (since Linux 2.2), SO_ATTACH_BPF (since Linux 3.19)\n    Attach a classic BPF (SO_ATTACH_FILTER) or an extended BPF\n    (SO_ATTACH_BPF) program to the socket for use as a filter of\n    incoming packets.  A packet will be dropped if the filter pro‐\n    gram returns zero.  If the filter program returns a nonzero\n    value which is less than the packet's data length, the packet\n    will be truncated to the length returned.  If the value\n    returned by the filter is greater than or equal to the\n    packet's data length, the packet is allowed to proceed unmodi‐\n    fied.\n</code></pre>\n<p>You probably take advantage of SO_ATTACH_FILTER already: This is how tcpdump/wireshark does filtering when you're dumping packets off the wire.</p>\n<p>How does it work? Depending on the result of a <a href=\"http://blog.cloudflare.com/bpf-the-forgotten-bytecode/\">BPF program</a>, packets can be filtered, truncated or passed to the socket without modification. Normally SO_ATTACH_FILTER is used for RAW sockets, but surprisingly, BPF filters can also be attached to normal SOCK_STREAM and SOCK_DGRAM sockets!</p>\n<p>We don't want to truncate packets though - we want to extract the TTL. Unfortunately with Classical BPF (cBPF) it's impossible to extract any data from a running BPF filter program.</p>\n<h3 id=\"ebpfandmaps\">eBPF and maps</h3>\n<p>This changed with modern BPF machinery, which includes:</p>\n<ul>\n<li>modernised eBPF bytecode</li>\n<li>eBPF maps</li>\n<li><a href=\"https://man7.org/linux/man-pages/man2/bpf.2.html\"><code>bpf()</code> syscall</a></li>\n<li>SO_ATTACH_BPF socket option</li>\n</ul>\n<p>eBPF bytecode can be thought of as an extension to Classical BPF, but it's the extra features that really let it shine.</p>\n<p>The gem is the &quot;map&quot; abstraction. An eBPF map is a thingy that allows an eBPF program to store data and share it with a userspace code. Think of an eBPF map as a data structure (a hash table most usually) shared between a userspace program and an eBPF program running in kernel space.</p>\n<p><img src=\"http://blog.cloudflare.com/content/images/2018/03/Screen-Shot-2018-03-29-at-10.59.43-AM.png\" alt=\"Screen-Shot-2018-03-29-at-10.59.43-AM\" loading=\"lazy\"></p>\n<p>To solve our TTL problem, we can use eBPF filter program. It will look at the TTL values of passing packets, and save them in an eBPF map. Later, we can inspect the eBPF map and analyze the recorded values from userspace.</p>\n<h3 id=\"so_attach_bpftoruletheworld\">SO_ATTACH_BPF to rule the world!</h3>\n<p>To use eBPF we need a number of things set up. First, we need to create an &quot;eBPF map&quot;. There <a href=\"https://elixir.bootlin.com/linux/v4.15.13/source/include/uapi/linux/bpf.h#L99\">are many specialized map types</a>, but for our purposes let's use the &quot;hash&quot; BPF_MAP_TYPE_HASH type.</p>\n<p>We need to figure out the <em>&quot;bpf(BPF_MAP_CREATE, map type, key size, value size, limit, flags)&quot;</em> parameters. For our small TTL program, let's set 4 bytes for key size, and 8 byte value size. The max element limit is set to 5. It doesn't matter, we expect all the packets in one connection to have just one coherent TTL value anyway.</p>\n<p>This is how it would look in a <a href=\"https://github.com/cloudflare/cloudflare-blog/blob/master/2018-03-ebpf/ebpf.go#L57\">Golang code</a>:</p>\n<pre><code>bpfMapFd, err := ebpf.NewMap(ebpf.Hash, 4, 8, 5, 0)\n</code></pre>\n<p>A word of warning is needed here. BPF maps use the &quot;locked memory&quot; resource. With multiple BPF programs and maps, it's easy to exhaust the default tiny 64 KiB limit. Consider bumping this with <code>ulimit -l</code>, for example:</p>\n<pre><code>ulimit -l 10240\n</code></pre>\n<p>The <code>bpf()</code> syscall returns a file descriptor pointing to the kernel BPF map we just created. With it handy we can operate on a map. The possible operations are:</p>\n<ul>\n<li><code>bpf(BPF_MAP_LOOKUP_ELEM, &lt;key&gt;)</code></li>\n<li><code>bpf(BPF_MAP_UPDATE_ELEM, &lt;key&gt;, &lt;value&gt;, &lt;flags&gt;)</code></li>\n<li><code>bpf(BPF_MAP_DELETE_ELEM, &lt;key&gt;)</code></li>\n<li><code>bpf(BPF_MAP_GET_NEXT_KEY, &lt;key&gt;)</code></li>\n</ul>\n<p>More on this later.</p>\n<p>With the map created, we need to create a BPF program. As opposed to classical BPF - where the bytecode was a parameter to SO_ATTACH_FILTER - the bytecode is now loaded by the <code>bpf()</code> syscall. Specifically: <code>bpf(BPF_PROG_LOAD)</code>.</p>\n<p>In our <a href=\"https://github.com/cloudflare/cloudflare-blog/blob/master/2018-03-ebpf/ebpf.go#L78-L131\">Golang program the eBPF program setup</a> looks like:</p>\n<pre><code>ebpfInss := ebpf.Instructions{\n\tebpf.BPFIDstOffSrc(ebpf.LdXW, ebpf.Reg0, ebpf.Reg1, 16),\n\tebpf.BPFIDstOffImm(ebpf.JEqImm, ebpf.Reg0, 3, int32(htons(ETH_P_IPV6))),\n\tebpf.BPFIDstSrc(ebpf.MovSrc, ebpf.Reg6, ebpf.Reg1),\n\tebpf.BPFIImm(ebpf.LdAbsB, int32(-0x100000+8)),\n...\n\tebpf.BPFIDstImm(ebpf.MovImm, ebpf.Reg0, -1),\n\tebpf.BPFIOp(ebpf.Exit),\n}\n\nbpfProgram, err := ebpf.NewProgram(ebpf.SocketFilter, &amp;ebpfInss, &quot;GPL&quot;, 0)\n</code></pre>\n<p>Writing eBPF by hand is rather controversial. Most people use <code>clang</code> (from version 3.7 onwards) to compile a code written in a C dialect into an eBPF bytecode. The resulting bytecode is saved in an ELF file, which can be loaded by most eBPF libraries. This ELF file also includes description of maps, so you don’t need to set them manually.</p>\n<p>I personally don't see the point in adding an ELF/clang dependency for simple SO_ATTACH_BPF snippets. Don't be afraid of the raw bytecode!</p>\n<h3 id=\"bpfcallingconvention\">BPF calling convention</h3>\n<p>Before we go further we should highlight couple of things about the eBPF environment. The official kernel documentation isn't too friendly:</p>\n<ul>\n<li><a href=\"https://www.kernel.org/doc/Documentation/networking/filter.txt\">Documentation/networking/filter.txt</a></li>\n</ul>\n<p>The first important bit to know, is the calling convention:</p>\n<ul>\n<li>R0 - return value from in-kernel function, and exit value for eBPF program</li>\n<li>R1-R5 - arguments from eBPF program to in-kernel function</li>\n<li>R6-R9 - callee saved registers that in-kernel function will preserve</li>\n<li>R10 - read-only frame pointer to access stack</li>\n</ul>\n<p>When the BPF is started, R1 contains a pointer to <code>ctx</code>. This data structure <a href=\"https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/bpf.h#L799\">is defined as <code>struct __sk_buff</code></a>. For example, to access the <code>protocol</code> field you'd need to run:</p>\n<pre><code>r0 = *(u32 *)(r1 + 16)\n</code></pre>\n<p>Or in other words:</p>\n<pre><code>ebpf.BPFIDstOffSrc(ebpf.LdXW, ebpf.Reg0, ebpf.Reg1, 16),\n</code></pre>\n<p>Which is exactly what we do in first line of our program, since we need to choose between IPv4 or IPv6 code branches.</p>\n<h3 id=\"accessingthebpfpayload\">Accessing the BPF payload</h3>\n<p>Next, there are special instructions for packet payload loading. Most BPF programs (but not all!) run in the context of packet filtering, so it makes sense to accelerate data lookups by having magic opcodes for accessing packet data.</p>\n<p>Instead of dereferencing context, like <code>ctx-&gt;data[x]</code> to load a byte, BPF supports the <code>BPF_LD</code> instruction that can do it in one operation. There are caveats though, the documentation says:</p>\n<pre><code>eBPF has two non-generic instructions: (BPF_ABS | &lt;size&gt; | BPF_LD) and\n(BPF_IND | &lt;size&gt; | BPF_LD) which are used to access packet data.\n\nThey had to be carried over from classic BPF to have strong performance of\nsocket filters running in eBPF interpreter. These instructions can only\nbe used when interpreter context is a pointer to 'struct sk_buff' and\nhave seven implicit operands. Register R6 is an implicit input that must\ncontain pointer to sk_buff. Register R0 is an implicit output which contains\nthe data fetched from the packet. Registers R1-R5 are scratch registers\nand must not be used to store the data across BPF_ABS | BPF_LD or\nBPF_IND | BPF_LD instructions.\n</code></pre>\n<p>In other words: before calling <code>BPF_LD</code> we must move <code>ctx</code> to R6, like this:</p>\n<pre><code>ebpf.BPFIDstSrc(ebpf.MovSrc, ebpf.Reg6, ebpf.Reg1),\n</code></pre>\n<p>Then we can call the load:</p>\n<pre><code>ebpf.BPFIImm(ebpf.LdAbsB, int32(-0x100000+7)),\n</code></pre>\n<p>At this stage the result is in r0, but we must remember the r1-r5 should be considered dirty. For an instruction the <code>BPF_LD</code> looks very much like a function call.</p>\n<h3 id=\"magicallayer3offset\">Magical Layer 3 offset</h3>\n<p>Next note the load offset - we loaded the <code>-0x100000+7</code> byte of the packet. This magic offset is another BPF context curiosity. It turns out that the BPF script loaded under SO_ATTACH_BPF on a SOCK_STREAM (or SOCK_DGRAM) socket, will only see Layer 4 and higher OSI layers by default. To extract the TTL we need access to the layer 3 header (i.e. the IP header). To access L3 in the L4 context, we must offset the data lookups by magical -0x100000.</p>\n<p>This magic constant <a href=\"https://github.com/torvalds/linux/blob/ead751507de86d90fa250431e9990a8b881f713c/include/uapi/linux/filter.h#L84\">is defined in the kernel</a>.</p>\n<p>For completeness, the <code>+7</code> is, of course, the offset of the TTL field in an IPv4 packet. Our small BPF program also supports IPv6 where the TTL/Hop Count is at offset <code>+8</code>.</p>\n<h3 id=\"returnvalue\">Return value</h3>\n<p>Finally, the return value of the BPF program is meaningful. In the context of packet filtering it will be interpreted as a truncated packet length.<br>\nHad we returned 0 - the packet would be dropped and wouldn't be seen by the userspace socket application. It's quite interesting that we can do packet-based data manipulation with eBPF on a stream-based socket. Anyway, our script returns -1, which when cast to unsigned will be interpreted as a very large number:</p>\n<pre><code>ebpf.BPFIDstImm(ebpf.MovImm, ebpf.Reg0, -1),\nebpf.BPFIOp(ebpf.Exit),\n</code></pre>\n<h3 id=\"extractingdatafrommap\">Extracting data from map</h3>\n<p>Our running BPF program will set a key on our map for any matched packet. The key is the recorded TTL value, the value is the packet count. The value counter is somewhat vulnerable to a tiny race condition, but it's ignorable for our purposes. Later on, to extract the data from userspace program we use this Golang loop:</p>\n<pre><code>var (\n\tvalue   MapU64\n\tk1, k2  MapU32\n)\n\nfor {\n\tok, err := bpfMap.Get(k1, &amp;value, 8)\n\tif ok {\n\t\t// k1 is TTL, value is counter\n\t\t...\n\t}\n\n\tok, err = bpfMap.GetNextKey(k1, &amp;k2, 4)\n\tif err != nil || ok == false {\n\t\tbreak\n\t}\n\tk1 = k2\n}\n</code></pre>\n<h3 id=\"puttingitalltogether\">Putting it all together</h3>\n<p>Now with all the pieces ready we can make it a proper runnable program. There is little point in discussing it here, so allow me to refer to the source code. The BPF pieces are here:</p>\n<ul>\n<li><a href=\"https://github.com/cloudflare/cloudflare-blog/blob/master/2018-03-ebpf/ebpf.go\">ebpf.go</a></li>\n</ul>\n<p>We haven't discussed how to catch inbound SYN+ACK in the BPF program. This is a matter of setting up BPF before calling <code>connect()</code>. Sadly, it's impossible to customize <code>net.Dial</code> in Golang. Instead we wrote a surprisingly painful and awful custom Dial implementation. The ugly custom dialer code is here:</p>\n<ul>\n<li><a href=\"https://github.com/cloudflare/cloudflare-blog/blob/master/2018-03-ebpf/magic_conn.go\">magic_conn.go</a></li>\n</ul>\n<p>To run all this you need kernel 4.4+ Kernel with the <code>bpf()</code> syscall compiled in. BPF features of specific kernels are documented in this superb page from BCC:</p>\n<ul>\n<li><a href=\"https://github.com/iovisor/bcc/blob/master/docs/kernel-versions.md\">docs/kernel-versions.md</a></li>\n</ul>\n<p>Run the code to observe the TTL Hop Counts:</p>\n<pre><code>$ ./ttl-ebpf tcp4://google.com:80 tcp6://google.com:80 \\\n             tcp4://cloudflare.com:80 tcp6://cloudflare.com:80\n[+] TTL distance to tcp4://google.com:80 172.217.4.174 is 6\n[+] TTL distance to tcp6://google.com:80 [2607:f8b0:4005:809::200e] is 4\n[+] TTL distance to tcp4://cloudflare.com:80 198.41.215.162 is 3\n[+] TTL distance to tcp6://cloudflare.com:80 [2400:cb00:2048:1::c629:d6a2] is 3\n</code></pre>\n<h3 id=\"takeaways\">Takeaways</h3>\n<p>In this blog post we dived into the new eBPF machinery, including the <code>bpf()</code> syscall, maps and SO_ATTACH_BPF. This work allowed me to realize the potential of running SO_ATTACH_BPF on fully established TCP sockets. Undoubtedly, eBPF still requires plenty of love and documentation, but it seems to be a perfect bridge to expose low level toggles to userspace applications.</p>\n<p>I highly recommend keeping the dependencies small. For small BPF programs, like the one shown, there is little need for complex clang compilation and ELF loading. Don't be afraid of the eBPF bytecode!</p>\n<p>We only touched on SO_ATTACH_BPF, where we analyzed network packets with BPF running on network sockets. There is more! First, you can attach BPFs to a dozen &quot;things&quot;, XDP being the most obvious example. <a href=\"https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/bpf.h#L119\">Full list</a>. Then, it's possible to actually affect kernel packet processing, here is a <a href=\"https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/bpf.h#L318\">full list of helper functions</a>, some of which can modify kernel data structures.</p>\n<p>In February <a href=\"https://lwn.net/Articles/747551/\">LWN jokingly wrote</a>:</p>\n<pre><code>Developers should be careful, though; this could\nprove to be a slippery slope leading toward something \nthat starts to look like a microkernel architecture.\n</code></pre>\n<p>There is a grain of truth here. Maybe the ability to run eBPF on variety of subsystems feels like microkernel coding, but definitely the SO_ATTACH_BPF smells like <a href=\"https://en.wikipedia.org/wiki/STREAMS\">STREAMS</a> programming model <a href=\"https://cseweb.ucsd.edu/classes/fa01/cse221/papers/ritchie-stream-io-belllabs84.pdf\">from 1984</a>.</p>\n<hr>\n<p>Thanks to <a href=\"https://twitter.com/akajibi\">Gilberto Bertin</a> and <a href=\"https://twitter.com/dwragg\">David Wragg</a> for helping out with the eBPF bytecode.</p>\n<hr>\n<p><em>Doing eBPF work sound interesting? Join our <a href=\"https://boards.greenhouse.io/cloudflare/jobs/589572\">world famous team</a> in London, Austin, San Francisco, Champaign and our elite office in Warsaw, Poland</em>.</p>\n<!--kg-card-end: markdown-->",
		"id": "5d16453b41acde0011a956da",
		"meta_description": null,
		"meta_title": null,
		"og_description": null,
		"og_image": null,
		"og_title": null,
		"primary_author": {
			"id": "5d1644b141acde0011a94f30",
			"name": "Marek Majkowski",
			"slug": "marek-majkowski",
			"profile_image": "http://blog.cloudflare.com/content/images/2017/03/b5967d6c687939594adb6992723d0529.jpeg",
			"cover_image": "http://blog.cloudflare.com/content/images/2018/08/general@2x-101.png",
			"bio": null,
			"website": null,
			"location": null,
			"facebook": null,
			"twitter": "@majek04",
			"meta_title": null,
			"meta_description": null,
			"url": "http://blog.cloudflare.com/author/marek-majkowski/"
		},
		"primary_tag": {
			"id": "5d16450341acde0011a9515d",
			"name": "TTL",
			"slug": "ttl",
			"description": null,
			"feature_image": null,
			"visibility": "public",
			"meta_title": null,
			"meta_description": null,
			"og_image": null,
			"og_title": null,
			"og_description": null,
			"twitter_image": null,
			"twitter_title": null,
			"twitter_description": null,
			"codeinjection_head": null,
			"codeinjection_foot": null,
			"canonical_url": null,
			"accent_color": null,
			"url": "http://blog.cloudflare.com/tag/ttl/"
		},
		"published_at": "2018-03-29T11:43:38.000+01:00",
		"reading_time": 10,
		"slug": "epbf_sockets_hop_distance",
		"tags": [
			{
				"id": "5d16450341acde0011a9515d",
				"name": "TTL",
				"slug": "ttl",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/ttl/"
			},
			{
				"id": "5d16450341acde0011a95163",
				"name": "TCP",
				"slug": "tcp",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/tcp/"
			},
			{
				"id": "5d16450341acde0011a95192",
				"name": "IPv4",
				"slug": "ipv4",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/ipv4/"
			},
			{
				"id": "5d16450341acde0011a9514d",
				"name": "IPv6",
				"slug": "ipv6",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/ipv6/"
			},
			{
				"id": "5d16450341acde0011a9524d",
				"name": "eBPF",
				"slug": "ebpf",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/ebpf/"
			}
		],
		"title": "eBPF, Sockets, Hop Distance and manually writing eBPF assembly",
		"twitter_description": null,
		"twitter_image": null,
		"twitter_title": null,
		"updated_at": "2024-05-06T19:21:26.000+01:00",
		"url": "http://blog.cloudflare.com/epbf_sockets_hop_distance/",
		"uuid": "6290adec-7af7-42ed-8d62-a07a44007607",
		"visibility": "public"
	}
}