{
	"locale": "en-us",
	"post": {
		"access": true,
		"authors": [
			{
				"id": "5d1644b141acde0011a94f30",
				"name": "Marek Majkowski",
				"slug": "marek-majkowski",
				"profile_image": "http://blog.cloudflare.com/content/images/2017/03/b5967d6c687939594adb6992723d0529.jpeg",
				"cover_image": "http://blog.cloudflare.com/content/images/2018/08/general@2x-101.png",
				"bio": null,
				"website": null,
				"location": null,
				"facebook": null,
				"twitter": "@majek04",
				"meta_title": null,
				"meta_description": null,
				"url": "http://blog.cloudflare.com/author/marek-majkowski/"
			}
		],
		"canonical_url": null,
		"codeinjection_foot": null,
		"codeinjection_head": null,
		"comment_id": "64ac0a3234124c000b00bc5b",
		"comments": false,
		"created_at": "2023-07-10T14:40:02.000+01:00",
		"custom_excerpt": "Ping developers clearly put some thought into that. I wondered how far they went. Did they handle clock changes in both directions? Are the bad measurements excluded from the final statistics? How do they test the software?",
		"custom_template": null,
		"email_subject": null,
		"excerpt": "Ping developers clearly put some thought into that. I wondered how far they went. Did they handle clock changes in both directions? Are the bad measurements excluded from the final statistics? How do they test the software?",
		"feature_image": "http://blog.cloudflare.com/content/images/2023/07/unnamed.png",
		"feature_image_alt": "The day my ping took countermeasures",
		"feature_image_caption": null,
		"featured": false,
		"frontmatter": null,
		"html": "<figure class=\"kg-card kg-image-card\"><img src=\"http://blog.cloudflare.com/content/images/2023/07/unnamed-1.png\" class=\"kg-image\" alt=\"The day my ping took countermeasures\" loading=\"lazy\" width=\"1600\" height=\"900\"></figure><figure class=\"kg-card kg-image-card\"><img src=\"http://blog.cloudflare.com/content/images/2023/07/Screenshot-2023-07-11-at-13.30.23.png\" class=\"kg-image\" alt loading=\"lazy\" width=\"1620\" height=\"802\"></figure><p>Once my holidays had passed, I found myself reluctantly reemerging into the world of the living. I powered on a corporate laptop, scared to check on my email inbox. However, before turning on the browser, obviously, I had to run a ping. Debugging the network is a mandatory first step after a boot, right? As expected, the network was perfectly healthy but what caught me off guard was this message:</p><figure class=\"kg-card kg-image-card\"><img src=\"http://blog.cloudflare.com/content/images/2023/07/image6.png\" class=\"kg-image\" alt loading=\"lazy\" width=\"1548\" height=\"449\"></figure><p>I was not expecting <strong>ping</strong> to <strong>take countermeasures</strong> that early on in a day. Gosh, I wasn't expecting any countermeasures that Monday!</p><p>Once I got over the initial confusion, I took a deep breath and collected my thoughts. You don't have to be Sherlock Holmes to figure out what has happened. I'm really fast - I started <strong>ping</strong> <em>before</em> the system <strong>NTP</strong> daemon synchronized the time. In my case, the computer clock was rolled backward, confusing ping.</p><p>While this doesn't happen too often, a computer clock can be freely adjusted either forward or backward. However, it's pretty rare for a regular network utility, like ping, to try to manage a situation like this. It's even less common to call it \"taking countermeasures\". I would totally expect ping to just print a nonsensical time value and move on without hesitation.</p><p>Ping developers clearly put some thought into that. I wondered how far they went. Did they handle clock changes in both directions? Are the bad measurements excluded from the final statistics? How do they test the software?</p><p>I can't just walk past ping \"taking countermeasures\" on me. Now I have to understand what ping did and why.</p><h3 id=\"understanding-ping\">Understanding ping</h3><p>An investigation like this starts with a quick glance at the source code:</p><!--kg-card-begin: markdown--><pre><code> *\t\t\tP I N G . C\n *\n * Using the InterNet Control Message Protocol (ICMP) &quot;ECHO&quot; facility,\n * measure round-trip-delays and packet loss across network paths.\n *\n * Author -\n *\tMike Muuss\n *\tU. S. Army Ballistic Research Laboratory\n *\tDecember, 1983\n</code></pre>\n<!--kg-card-end: markdown--><p><strong>Ping</strong> goes back a long way. It was originally written by <a href=\"https://en.wikipedia.org/wiki/Mike_Muuss\">Mike Muuss</a> while at the U. S. Army Ballistic Research Laboratory, in 1983, before I was born. The code we're looking for is under <a href=\"https://github.com/iputils/iputils/blob/ee0a515e74b8d39fbe9b68f3309f0cb2586ccdd4/ping/ping_common.c#L746\">iputils/ping/ping_common.c</a> gather_statistics() function:</p><figure class=\"kg-card kg-image-card\"><img src=\"http://blog.cloudflare.com/content/images/2023/07/image5.png\" class=\"kg-image\" alt loading=\"lazy\" width=\"1175\" height=\"253\"></figure><p>The code is straightforward: the message in question is printed when the measured <a href=\"https://www.cloudflare.com/learning/cdn/glossary/round-trip-time-rtt/\">RTT</a> is negative. In this case ping resets the latency measurement to zero. Here you are: \"taking countermeasures\" is nothing more than just marking an erroneous measurement as if it was 0ms.</p><p>But what precisely does ping measure? Is it the wall clock? The <a href=\"https://man7.org/linux/man-pages/man8/ping.8.html\">man page</a> comes to the rescue. Ping has two modes.</p><p>The \"old\", -U mode, in which it uses the wall clock. This mode is less accurate (has more jitter). It calls <strong>gettimeofday</strong> before sending and after receiving the packet.</p><p>The \"new\", default, mode in which it uses \"network time\". It calls <strong>gettimeofday</strong> before sending, and gets the receive timestamp from a more accurate SO_TIMESTAMP CMSG. More on this later.</p><h3 id=\"tracing-gettimeofday-is-hard\">Tracing gettimeofday is hard</h3><p>Let's start with a good old strace:</p><!--kg-card-begin: markdown--><pre><code>$ strace -e trace=gettimeofday,time,clock_gettime -f ping -n -c1 1.1 &gt;/dev/null\n... nil ...\n</code></pre>\n<!--kg-card-end: markdown--><p>It doesn't show any calls to <strong>gettimeofday</strong>. What is going on?</p><p>On modern Linux some syscalls are not true syscalls. Instead of jumping to the kernel space, which is slow, they remain in userspace and go to a special code page provided by the host kernel. This code page is called <strong>vdso</strong>. It's visible as a <strong>.so</strong> library to the program:</p><!--kg-card-begin: markdown--><pre><code>$ ldd `which ping` | grep vds\n    linux-vdso.so.1 (0x00007ffff47f9000)\n</code></pre>\n<!--kg-card-end: markdown--><p>Calls to the <strong>vdso</strong> region are not syscalls, they remain in userspace and are super fast, but classic strace can't see them. For debugging it would be nice to turn off <strong>vdso </strong>and fall back to classic slow syscalls. It's easier said than done.</p><p>There is no way to prevent loading of the <strong>vdso</strong>. However there are two ways to convince a loaded program not to use it.</p><p>The first technique is about fooling glibc into thinking the <strong>vdso</strong> is not loaded. This case must be handled for compatibility with ancient Linux. When bootstrapping in a freshly run process, glibc inspects the <a href=\"https://www.gnu.org/software/libc/manual/html_node/Auxiliary-Vector.html\">Auxiliary Vector</a> provided by ELF loader. One of the parameters has the location of the <strong>vdso</strong> pointer, <a href=\"https://man7.org/linux/man-pages/man7/vdso.7.html\">the man page</a> gives this example:</p><!--kg-card-begin: markdown--><pre><code>void *vdso = (uintptr_t) getauxval(AT_SYSINFO_EHDR);\n</code></pre>\n<!--kg-card-end: markdown--><p>A technique proposed on <a href=\"https://stackoverflow.com/a/63811017\">Stack Overflow</a> works like that: let's hook on a program before <strong>execve</strong>() exits and overwrite the Auxiliary Vector AT_SYSINFO_EHDR parameter. Here's the <a href=\"https://github.com/danteu/novdso/blob/master/novdso.c\">novdso.c</a> code. However, the linked code doesn't quite work for me (one too many <strong>kill(SIGSTOP)</strong>), and has one bigger, fundamental flaw. To hook on <strong>execve()</strong> it uses <strong>ptrace()</strong> therefore doesn't work under our strace!</p><!--kg-card-begin: markdown--><pre><code>$ strace -f ./novdso ping 1.1 -c1 -n\n...\n[pid 69316] ptrace(PTRACE_TRACEME)  \t= -1 EPERM (Operation not permitted)\n</code></pre>\n<!--kg-card-end: markdown--><p>While this technique of rewriting AT_SYSINFO_EHDR is pretty cool, it won't work for us. (I wonder if there is another way of doing that, but without ptrace. Maybe with some BPF? But that is another story.)</p><p>A second technique is to use <strong>LD_PRELOAD </strong>and preload a trivial library overloading the functions in question, and forcing them to go to slow real syscalls. This works fine:</p><!--kg-card-begin: markdown--><pre><code class=\"language-C++\">$ cat vdso_override.c\n#include &lt;sys/syscall.h&gt;\n#include &lt;sys/time.h&gt;\n#include &lt;time.h&gt;\n#include &lt;unistd.h&gt;\n\nint gettimeofday(struct timeval *restrict tv, void *restrict tz) {\n\treturn syscall(__NR_gettimeofday, (long)tv, (long)tz, 0, 0, 0, 0);\n}\n\ntime_t time(time_t *tloc) {\n\treturn syscall(__NR_time, (long)tloc, 0, 0, 0, 0, 0);\n}\n\nint clock_gettime(clockid_t clockid, struct timespec *tp) {\n    return syscall(__NR_clock_gettime, (long)clockid, (long)tp, 0, 0, 0, 0);\n}\n</code></pre>\n<!--kg-card-end: markdown--><p>To load it:</p><!--kg-card-begin: markdown--><pre><code>$ gcc -Wall -Wextra -fpic -shared -o vdso_override.so vdso_override.c\n\n$ LD_PRELOAD=./vdso_override.so \\\n       strace -e trace=gettimeofday,clock_gettime,time \\\n       date\n\nclock_gettime(CLOCK_REALTIME, {tv_sec=1688656245 ...}) = 0\nThu Jul  6 05:10:45 PM CEST 2023\n+++ exited with 0 +++\n</code></pre>\n<!--kg-card-end: markdown--><p>Hurray! We can see the <strong>clock_gettime</strong> call in <strong>strace</strong> output. Surely we'll also see <strong>gettimeofday</strong> from our <strong>ping</strong>, right?</p><p>Not so fast, it still doesn't quite work:</p><!--kg-card-begin: markdown--><pre><code>$ LD_PRELOAD=./vdso_override.so \\\n     strace -c -e trace=gettimeofday,time,clock_gettime -f \\\n     ping -n -c1 1.1 &gt;/dev/null\n... nil ...\n</code></pre>\n<!--kg-card-end: markdown--><h3 id=\"to-suid-or-not-to-suid\">To suid or not to suid</h3><p>I forgot that <strong>ping</strong> might need special permissions to read and write raw packets. Historically<strong> </strong>it<strong> </strong>had a <strong>suid</strong> bit set, which granted the program elevated user identity. However LD_PRELOAD doesn't work with suid. When a program is being loaded a <a href=\"https://github.com/bminor/musl/blob/718f363bc2067b6487900eddc9180c84e7739f80/ldso/dynlink.c#L1820\">dynamic linker checks if it has <strong>suid</strong> bit</a>, and if so, it ignores LD_PRELOAD and LD_LIBRARY_PATH settings.</p><p>However, does <strong>ping </strong>need suid? Nowadays it's totally possible to send and receive ICMP Echo messages without any extra privileges, like this:</p><!--kg-card-begin: markdown--><pre><code class=\"language-py\">from socket import *\nimport struct\n\nsd = socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP)\nsd.connect(('1.1', 0))\n\nsd.send(struct.pack(&quot;!BBHHH10s&quot;, 8, 0, 0, 0, 1234, b'payload'))\ndata = sd.recv(1024)\nprint('type=%d code=%d csum=0x%x id=%d seq=%d payload=%s' % struct.unpack_from(&quot;!BBHHH10s&quot;, data))\n</code></pre>\n<!--kg-card-end: markdown--><p>Now you know how to write \"ping\" in eight lines of Python. This Linux API is known as <strong>ping socket</strong>. It generally works on modern Linux, however it requires a correct sysctl, which is typically enabled:</p><!--kg-card-begin: markdown--><pre><code>$ sysctl net.ipv4.ping_group_range\nnet.ipv4.ping_group_range = 0    2147483647\n</code></pre>\n<!--kg-card-end: markdown--><p>The <strong>ping socket</strong> is not as mature as UDP or TCP sockets. The \"ICMP ID\" field is used to dispatch an ICMP Echo Response to an appropriate socket, but when using <strong>bind() </strong>this property is settable by the user without any checks. A malicious user can deliberately cause an \"ICMP ID\" conflict.</p><p>But we're not here to discuss Linux networking API's. We're here to discuss the <strong>ping</strong> utility and indeed, it's using the <strong>ping sockets</strong>:</p><!--kg-card-begin: markdown--><pre><code>$ strace -e trace=socket -f ping 1.1 -nUc 1\nsocket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP) = 3\nsocket(AF_INET6, SOCK_DGRAM, IPPROTO_ICMPV6) = 4\n</code></pre>\n<!--kg-card-end: markdown--><p>Ping sockets are rootless, and <strong>ping</strong>, at least on my laptop, is not a suid program:</p><!--kg-card-begin: markdown--><pre><code>$ ls -lah `which ping`\n-rwxr-xr-x 1 root root 75K Feb  5  2022 /usr/bin/ping\n</code></pre>\n<!--kg-card-end: markdown--><p>So why doesn't the LD_PRELOAD? It turns out <strong>ping </strong>binary holds a CAP_NET_RAW capability. Similarly to suid, this is preventing the library preloading machinery from working:</p><!--kg-card-begin: markdown--><pre><code>$ getcap `which ping`\n/usr/bin/ping cap_net_raw=ep\n</code></pre>\n<!--kg-card-end: markdown--><p>I think this capability is enabled only to handle the case of a misconfigured <strong>net.ipv4.ping_group_range</strong> sysctl. For me ping works perfectly fine without this capability.</p><h3 id=\"rootless-is-perfectly-fine\">Rootless is perfectly fine</h3><p>Let's remove the CAP_NET_RAW<strong> </strong>and try out LD_PRELOAD hack again:</p><!--kg-card-begin: markdown--><pre><code>$ cp `which ping` .\n\n$ LD_PRELOAD=./vdso_override.so strace -f ./ping -n -c1 1.1\n...\nsetsockopt(3, SOL_SOCKET, SO_TIMESTAMP_OLD, [1], 4) = 0\ngettimeofday({tv_sec= ... ) = 0\nsendto(3, ...)\nsetitimer(ITIMER_REAL, {it_value={tv_sec=10}}, NULL) = 0\nrecvmsg(3, { ... cmsg_level=SOL_SOCKET, \n                 cmsg_type=SO_TIMESTAMP_OLD, \n                 cmsg_data={tv_sec=...}}, )\n</code></pre>\n<!--kg-card-end: markdown--><p>We finally made it! Without -U, in the \"network timestamp\" mode, <strong>ping</strong>:</p><ul><li>Sets SO_TIMESTAMP flag on a socket.</li><li>Calls <strong>gettimeofday</strong> before sending the packet.</li><li>When fetching a packet, gets the timestamp from the <strong>CMSG</strong>.</li></ul><h3 id=\"fault-injectionfooling-ping\">Fault injection - fooling ping</h3><p>With <strong>strace</strong> up and running we can finally do something interesting. You see, <strong>strace </strong>has a little known fault injection feature, named <a href=\"https://man7.org/linux/man-pages/man1/strace.1.html\">\"tampering\" in the manual</a>:</p><figure class=\"kg-card kg-image-card\"><img src=\"http://blog.cloudflare.com/content/images/2023/07/image3.png\" class=\"kg-image\" alt loading=\"lazy\" width=\"1305\" height=\"391\"></figure><p>With a couple of command line parameters we can overwrite the result of the<strong> gettimeofday </strong>call. I want to set it forward to confuse ping into thinking the SO_TIMESTAMP time is in the past:</p><!--kg-card-begin: markdown--><pre><code>LD_PRELOAD=./vdso_override.so \\\n    strace -o /dev/null -e trace=gettimeofday \\\n            -e inject=gettimeofday:poke_exit=@arg1=ff:when=1 -f \\\n    ./ping -c 1 -n 1.1.1.1\n\nPING 1.1.1.1 (1.1.1.1) 56(84) bytes of data.\n./ping: Warning: time of day goes back (-59995290us), taking countermeasures\n./ping: Warning: time of day goes back (-59995104us), taking countermeasures\n64 bytes from 1.1.1.1: icmp_seq=1 ttl=60 time=0.000 ms\n\n--- 1.1.1.1 ping statistics ---\n1 packets transmitted, 1 received, 0% packet loss, time 0ms\nrtt min/avg/max/mdev = 0.000/0.000/0.000/0.000 ms\n</code></pre>\n<!--kg-card-end: markdown--><p>It worked! We can now generate the \"taking countermeasures\" message reliably!</p><p>While we can cheat on the <strong>gettimeofday</strong> result, with <strong>strace </strong>it's impossible to overwrite the CMSG timestamp. Perhaps it might be possible to adjust the CMSG timestamp with Linux <a href=\"https://man7.org/linux/man-pages/man7/time_namespaces.7.html\">time namespaces</a>, but I don't think it'll work. As far as I understand, time namespaces are not taken into account by the network stack. A program using SO_TIMESTAMP is deemed to compare it against the system clock, which might be rolled backwards.</p><h3 id=\"fool-me-once-fool-me-twice\">Fool me once, fool me twice</h3><p>At this point we could conclude our investigation. We're now able to reliably trigger the \"taking countermeasures\" message using strace fault injection.</p><p>There is one more thing though. When sending ICMP Echo Request messages, does <strong>ping</strong> <strong>remember</strong> the send timestamp in some kind of hash table? That might be wasteful considering a long-running ping sending thousands of packets.</p><p>Ping is smart, and instead puts the timestamp in the ICMP Echo Request <strong>packet payload</strong>!</p><p>Here's how the full algorithm works:</p><ol><li>Ping sets the SO_TIMESTAMP_OLD socket option to receive timestamps.</li><li>It looks at the wall clock with <strong>gettimeofday</strong>.</li><li>It puts the current timestamp in the first bytes of the ICMP payload.</li><li>After receiving the ICMP Echo Reply packet, it inspects the two timestamps: the send timestamp from the payload and the receive timestamp from CMSG.</li><li>It calculates the RTT delta.</li></ol><p>This is pretty neat! With this algorithm, ping doesn't need to remember much, and can have an unlimited number of packets in flight! (For completeness, ping maintains a small fixed-size bitmap to account for the DUP! packets).</p><p>What if we set a packet length to be less than 16 bytes? Let's see:</p><!--kg-card-begin: markdown--><pre><code>$ ping 1.1 -c2 -s0\nPING 1.1 (1.0.0.1) 0(28) bytes of data.\n8 bytes from 1.0.0.1: icmp_seq=1 ttl=60\n8 bytes from 1.0.0.1: icmp_seq=2 ttl=60\n--- 1.1 ping statistics ---\n2 packets transmitted, 2 received, 0% packet loss, time 1002ms\n</code></pre>\n<!--kg-card-end: markdown--><p>In such a case ping just skips the RTT from the output. Smart!</p><p>Right... this opens two completely new subjects. While ping was written back when everyone was friendly, today’s Internet can have rogue actors. What if we spoofed responses to confuse ping. Can we: cut the payload to prevent ping from producing RTT, and spoof the timestamp and fool the RTT measurements?</p><p>Both things work! The truncated case will look like this to the sender:</p><!--kg-card-begin: markdown--><pre><code>$ ping 139.162.188.91\nPING 139.162.188.91 (139.162.188.91) 56(84) bytes of data.\n8 bytes from 139.162.188.91: icmp_seq=1 ttl=53 (truncated)\n</code></pre>\n<!--kg-card-end: markdown--><p>The second case, of an overwritten timestamp, is even cooler. We can move timestamp forwards causing ping to show our favorite \"taking countermeasures\" message:</p><!--kg-card-begin: markdown--><pre><code>$ ping 139.162.188.91  -c 2 -n\nPING 139.162.188.91 (139.162.188.91) 56(84) bytes of data.\n./ping: Warning: time of day goes back (-1677721599919015us), taking countermeasures\n./ping: Warning: time of day goes back (-1677721599918907us), taking countermeasures\n64 bytes from 139.162.188.91: icmp_seq=1 ttl=53 time=0.000 ms\n./ping: Warning: time of day goes back (-1677721599905149us), taking countermeasures\n64 bytes from 139.162.188.91: icmp_seq=2 ttl=53 time=0.000 ms\n\n--- 139.162.188.91 ping statistics ---\n2 packets transmitted, 2 received, 0% packet loss, time 1001ms\nrtt min/avg/max/mdev = 0.000/0.000/0.000/0.000 ms\n</code></pre>\n<!--kg-card-end: markdown--><p>Alternatively we can move the time in the packet backwards causing <a href=\"https://github.com/iputils/iputils/issues/480\">ping to show nonsensical RTT values</a>:</p><!--kg-card-begin: markdown--><pre><code>$ ./ping 139.162.188.91  -c 2 -n\nPING 139.162.188.91 (139.162.188.91) 56(84) bytes of data.\n64 bytes from 139.162.188.91: icmp_seq=1 ttl=53 time=1677721600430 ms\n64 bytes from 139.162.188.91: icmp_seq=2 ttl=53 time=1677721600084 ms\n\n--- 139.162.188.91 ping statistics ---\n2 packets transmitted, 2 received, 0% packet loss, time 1000ms\nrtt min/avg/max/mdev = 1677721600084.349/1677721600257.351/1677721600430.354/-9223372036854775.-808 ms\n</code></pre>\n<!--kg-card-end: markdown--><p>We proved that \"countermeasures\" work only when time moves in one direction. In another direction ping is just fooled.</p><p>Here's a rough scapy snippet that generates an ICMP Echo Response fooling ping:</p><!--kg-card-begin: markdown--><pre><code class=\"language-python\"># iptables -I INPUT -i eth0 -p icmp --icmp-type=8 -j DROP\nimport scapy.all as scapy\nimport struct\n\ndef custom_action(echo_req):\n    try:\n    \tpayload = bytes(echo_req[scapy.ICMP].payload)\n    \tif len(payload) &gt;= 8:\n        \tts, tu = struct.unpack_from(&quot;&lt;II&quot;, payload)\n        \tpayload = struct.pack(&quot;&lt;II&quot;, (ts-0x64000000)&amp;0xffffffff, tu) \\\n                     + payload[8:]\n\n    \techo_reply = scapy.IP(\n        \tdst=echo_req[scapy.IP].src,\n        \tsrc=echo_req[scapy.IP].dst,\n    \t) / scapy.ICMP(type=0, code=0,\n                 \tid=echo_req[scapy.ICMP].id,\n                 \tseq=echo_req.payload.seq,\n   \t  \t) / payload\n    \tscapy.send(echo_reply,iface=iface)\n    except Exception as e:\n        pass\n\nscapy.sniff(filter=&quot;icmp and icmp[0] = 8&quot;, iface=iface, prn=custom_action)\n</code></pre>\n<!--kg-card-end: markdown--><h3 id=\"leap-second\">Leap second</h3><p>In practice, how often does time change on a computer? The <strong>NTP</strong> daemon adjusts the clock all the time to account for any drift. However, these are very small changes. Apart from initial clock synchronization after boot or sleep wakeup, big clock shifts shouldn't really happen.</p><p>There are exceptions as usual. Systems that operate in virtual environments or have unreliable Internet connections often experience their clocks getting out of sync.</p><p>One notable case that affects all computers is a coordinated clock adjustment called a <a href=\"https://en.wikipedia.org/wiki/Leap_second\">leap second</a>. It causes the clock to move backwards, which is particularly troublesome. An issue with handling leap second <a href=\"http://blog.cloudflare.com/how-and-why-the-leap-second-affected-cloudflare-dns/\">caused our engineers a headache in late 2016</a>.</p><figure class=\"kg-card kg-image-card\"><img src=\"http://blog.cloudflare.com/content/images/2023/07/Screenshot-2023-07-11-at-13.33.02.png\" class=\"kg-image\" alt loading=\"lazy\" width=\"1614\" height=\"648\"></figure><p>Leap seconds often cause issues, so the current consensus is to <a href=\"https://www.nytimes.com/2022/11/19/science/time-leap-second-bipm.html\">deprecate them by 2035</a>. However, <a href=\"https://en.wikipedia.org/wiki/Leap_second#International_proposals_for_elimination_of_leap_seconds\">according to Wikipedia</a> the solution seem to be to just kick the can down the road:</p><blockquote><em>A suggested possible future measure would be to let the discrepancy increase to a full minute, which would take 50 to 100 years, and then have the last minute of the day taking two minutes in a \"kind of smear\" with no discontinuity.</em></blockquote><p>In any case, there hasn't been a leap second since 2016, there might be some in the future, but there likely won't be any after 2035. Many environments already use a <a href=\"https://cloudplatform.googleblog.com/2015/05/Got-a-second-A-leap-second-that-is-Be-ready-for-June-30th.html\">leap second smear</a> to avoid the problem of clock jumping back.</p><p>In most cases, it might be completely fine to ignore the clock changes. When possible, to count time durations use CLOCK_MONOTONIC, which is bulletproof.</p><p>We haven't mentioned <a href=\"https://en.wikipedia.org/wiki/Daylight_saving_time\">daylight savings</a> clock adjustments here because, from a computer perspective they are not real clock changes! Most often programmers deal with the operating system clock, which is typically set to the <a href=\"https://en.wikipedia.org/wiki/Coordinated_Universal_Time\">UTC timezone</a>. DST timezone is taken into account only when pretty printing the date on screen. The underlying software operates on integer values. Let's consider an example of two timestamps, which in my <a href=\"https://devblogs.microsoft.com/oldnewthing/20061027-00/?p=29213\">Warsaw timezone</a>, appear as two different DST timezones. While it may like the clock rolled back, this is just a user interface illusion. The integer timestamps are sequential:</p><!--kg-card-begin: markdown--><pre><code>$ date --date=@$[1698541199+0]\nSun Oct 29 02:59:59 AM CEST 2023\n\n$ date --date=@$[1698541199+1]\nSun Oct 29 02:00:00 AM CET 2023\n</code></pre>\n<!--kg-card-end: markdown--><h3 id=\"lessons\">Lessons</h3><p>Arguably, the clock jumping backwards is a rare occurrence. It's very hard to test for such cases, and I was surprised to find that <strong>ping</strong> made such an attempt. To avoid the problem, to measure the latency ping might use CLOCK_MONOTONIC, its developers already <a href=\"https://github.com/iputils/iputils/commit/4fd276cd8211c502cb87c5db0ce15cd685177216\">use this time source in another place</a>.</p><p>Unfortunately this won't quite work here. Ping needs to compare send timestamp to receive timestamp from SO_TIMESTAMP CMSG, which uses the non-monotonic system clock. Linux API's are sometimes limited, and dealing with time is hard. For time being, clock adjustments will continue to confuse ping.</p><p>In any case, now we know what to do when <strong>ping</strong> is \"<strong>taking countermeasures</strong>\"! Pull down your periscope and check the <strong>NTP</strong> daemon status!</p>",
		"id": "64ac0a3234124c000b00bc5b",
		"meta_description": "Ping developers clearly put some thought into that. I wondered how far they went. Did they handle clock changes in both directions? Are the bad measurements excluded from the final statistics? How do they test the software?",
		"meta_title": null,
		"og_description": null,
		"og_image": "http://blog.cloudflare.com/content/images/2023/07/The-day-my-ping-took-countermeasures-OG-1.png",
		"og_title": null,
		"primary_author": {
			"id": "5d1644b141acde0011a94f30",
			"name": "Marek Majkowski",
			"slug": "marek-majkowski",
			"profile_image": "http://blog.cloudflare.com/content/images/2017/03/b5967d6c687939594adb6992723d0529.jpeg",
			"cover_image": "http://blog.cloudflare.com/content/images/2018/08/general@2x-101.png",
			"bio": null,
			"website": null,
			"location": null,
			"facebook": null,
			"twitter": "@majek04",
			"meta_title": null,
			"meta_description": null,
			"url": "http://blog.cloudflare.com/author/marek-majkowski/"
		},
		"primary_tag": null,
		"published_at": "2023-07-11T14:05:00.000+01:00",
		"reading_time": 12,
		"slug": "the-day-my-ping-took-countermeasures",
		"tags": [
			{
				"id": "64ac1fd934124c000b00bc65",
				"name": "#BLOG-1964",
				"slug": "hash-blog-1964",
				"description": null,
				"feature_image": null,
				"visibility": "internal",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/404/"
			},
			{
				"id": "5d16450341acde0011a9514f",
				"name": "Network",
				"slug": "network",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/network/"
			}
		],
		"title": "The day my ping took countermeasures",
		"twitter_description": null,
		"twitter_image": "http://blog.cloudflare.com/content/images/2023/07/The-day-my-ping-took-countermeasures-OG.png",
		"twitter_title": null,
		"updated_at": "2024-07-29T17:41:26.000+01:00",
		"url": "http://blog.cloudflare.com/the-day-my-ping-took-countermeasures/",
		"uuid": "5cb3eafb-d160-4d03-847c-658f93ae1203",
		"visibility": "public"
	}
}