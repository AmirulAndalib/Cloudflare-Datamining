{
	"locale": "en-us",
	"post": {
		"access": true,
		"authors": [
			{
				"id": "635aebdfabc75e000aade24f",
				"name": "Jacob Bednarz",
				"slug": "jacob-bednarz",
				"profile_image": "http://blog.cloudflare.com/content/images/2024/04/IMG_2693.jpg",
				"cover_image": null,
				"bio": "System Engineer, Control Plane",
				"website": "https://jacobbednarz.com",
				"location": "Australia",
				"facebook": null,
				"twitter": "@jacobbednarz",
				"meta_title": null,
				"meta_description": null,
				"url": "http://blog.cloudflare.com/author/jacob-bednarz/"
			}
		],
		"canonical_url": null,
		"codeinjection_foot": null,
		"codeinjection_head": null,
		"comment_id": "66277eb37c0f59000a6a8dfa",
		"comments": false,
		"created_at": "2024-04-23T10:26:11.000+01:00",
		"custom_excerpt": "During Developer Week 2024, we announced the revamped SDKs that are automatically generated using our OpenAPI schemas. Today, we’re taking a deeper look at how the pipeline works and share lessons we’ve learned along the way",
		"custom_template": null,
		"email_subject": null,
		"excerpt": "During Developer Week 2024, we announced the revamped SDKs that are automatically generated using our OpenAPI schemas. Today, we’re taking a deeper look at how the pipeline works and share lessons we’ve learned along the way",
		"feature_image": "http://blog.cloudflare.com/content/images/2024/04/image3-16.png",
		"feature_image_alt": "Lessons from building an automated SDK pipeline",
		"feature_image_caption": null,
		"featured": false,
		"frontmatter": null,
		"html": "<figure class=\"kg-card kg-image-card\"><img src=\"http://blog.cloudflare.com/content/images/2024/04/image3-17.png\" class=\"kg-image\" alt=\"Lessons from building an automated SDK pipeline\" loading=\"lazy\" width=\"1999\" height=\"1125\"></figure><p>In case you missed the <a href=\"http://blog.cloudflare.com/workers-production-safety\">announcement</a> from Developer Week 2024, Cloudflare is now offering software development kits (SDKs) for <a href=\"https://github.com/cloudflare/cloudflare-typescript\">Typescript</a>, <a href=\"https://github.com/cloudflare/cloudflare-go\">Go</a> and <a href=\"https://github.com/cloudflare/cloudflare-python\">Python</a>. As a reminder, you can get started by installing the packages.</p><!--kg-card-begin: markdown--><pre><code class=\"language-typescript\">// Typescript\nnpm install cloudflare\n\n// Go\ngo get -u github.com/cloudflare/cloudflare-go/v2\n\n// Python\npip install --pre cloudflare\n</code></pre>\n<!--kg-card-end: markdown--><p>Instead of using a tool like <code>curl</code> or Postman to create a new zone in your account, you can use one of the SDKs in a language that you’re already comfortable with or that integrates directly into your existing codebase.</p><!--kg-card-begin: markdown--><pre><code class=\"language-JavaScript\">import Cloudflare from 'cloudflare';\n\nconst cloudflare = new Cloudflare({\n  apiToken: process.env['CLOUDFLARE_API_TOKEN']\n});\n\nconst newZone = await cloudflare.zones.create({\n  account: { id: '023e105f4ecef8ad9ca31a8372d0c353' },\n  name: 'example.com',\n  type: 'full',\n});\n</code></pre>\n<!--kg-card-end: markdown--><p>Since their inception, our SDKs have been manually maintained by one or more dedicated individuals. For every product addition or improvement, we needed to orchestrate a series of manually created pull requests to get those changes into customer hands. This, unfortunately, created an imbalance in the frequency and quality of changes that made it into the SDKs. Even though the product teams would drive some of these changes, not all languages were covered and the SDKs fell to either community-driven contributions or to the maintainers of the libraries to cover the remaining languages. Internally, we too felt this pain when using our own services and, instead of covering all languages, decided to rally our efforts behind the primary SDK (Go) to ensure that at least one of these libraries was in a good state.</p><p>This plan worked for newer products and additions to the Go SDK, which in turn helped tools like our <a href=\"https://github.com/cloudflare/terraform-provider-cloudflare/\">Terraform Provider</a> stay mostly up to date, but even this focused improvement was still very taxing and time-consuming for internal teams to maintain. On top of this, the process didn’t provide any guarantees on coverage, parity, or correctness because the changes were still manually maintained and susceptible to human error. Regardless of the size of contribution, a team member would still need to coordinate a minimum of 4 pull requests (shown in more depth below) before a change was considered shipped and needed deep knowledge of the relationship between the dependencies in order to get it just right.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"http://blog.cloudflare.com/content/images/2024/04/image1-19.png\" class=\"kg-image\" alt=\"The pull requests previously required to ship an SDK change.\" loading=\"lazy\" width=\"1318\" height=\"898\"><figcaption><em>The pull requests previously required to ship an SDK change.</em></figcaption></figure><p>Following the completion of <a href=\"http://blog.cloudflare.com/open-api-transition\">our transition to OpenAPI from JSON Hyper-Schema</a>, we caught up internally and started discussing what else OpenAPI could help us unlock. It was at that point that we set the lofty goal of using OpenAPI for more than just our documentation. It was time to use OpenAPI to generate our SDKs.</p><p>Before we dove headfirst into generating SDKs, we established some guiding principles. These would be non-negotiable and determine where we spent our effort.</p><h3 id=\"you-should-not-be-able-to-tell-what-underlying-language-generated-the-sdk\">You should not be able to tell what underlying language generated the SDK</h3><p>This was important for us because too often companies build SDKs using automation. Not only do you end up with SDKs that are flavored based on generator language, but the SDKs then lack the language nuances or patterns that are noticeable to users familiar with the language.</p><p>For example, a Rubyist may use the following <code>if</code> expression:</p><!--kg-card-begin: markdown--><pre><code class=\"language-ruby\">do_something if bar?\n</code></pre>\n<!--kg-card-end: markdown--><p>Whereas most generators do not have this context and would instead default to the standard case where <code>if/else</code> expressions are spread over multiple lines.</p><!--kg-card-begin: markdown--><pre><code class=\"language-ruby\">if bar?\n  do_something\nend\n</code></pre>\n<!--kg-card-end: markdown--><p>Despite being a simple and non-material example, it demonstrates a nuance that a machine cannot decipher on its own. This is terrible for developers because you’re then no longer only thinking about how to solve the original task at hand, but you also end up tailoring your code to match how the generator has built the SDK and potentially lose out on the language features you would normally use. The problem is made significantly worse if you’re using a strongly typed language to generate a language without types, since it will be structuring and building code in a way that types are expected but never used.</p><h3 id=\"lowering-the-mean-time-to-uniform-support\">Lowering the mean time to uniform support</h3><p>When a new feature is added to a product, it’s great that we add API support initially. However, if that new feature or product never makes it to whatever language SDK you are using to drive your API calls, it’s as good as non-existent. Similarly, not every use case is for infrastructure-as-code tools like Terraform, so we needed a better way of meeting our customers with uniformity where they choose to integrate with our services.</p><p>By extension, we want uniformity in the way the namespaces and methods are constructed. Ignoring the language-specific parts, if you’re using one of our SDKs and you are looking for the ability to list all DNS records, you should be able to trust that the method will be in the <code>dns</code> namespace and that to find all records, you can call a <code>list</code> method regardless of which one you are using. Example:</p><!--kg-card-begin: markdown--><pre><code>// Go\nclient.DNS.Records.List(...)\n\n// Typescript\nclient.dns.records.list(...)\n\n// Python\nclient.dns.records.list(...)\n</code></pre>\n<!--kg-card-end: markdown--><p>This leads to less time digging through documentation to find what invocation you need and more time using the tools you’re already familiar with.</p><h3 id=\"fast-feedback-loops-clear-conventions\">Fast feedback loops, clear conventions</h3><p>Cloudflare has <strong>a lot</strong> of APIs; everything is backed by an API <em>somewhere</em>. However, not all Cloudflare APIs are designed with the same conventions in mind. Those APIs that are on the critical path and regularly experience traffic surges or malformed input are naturally more hardened and more resilient than those that are infrequently used. This creates a divergence in quality of the endpoint, which shouldn’t be the case.</p><p>Where we have learned a lesson or improved a system through a best practice, we should make it easy for others to be aware of and opt into that pattern with little friction at the earliest possible time, ideally as they are proposing the change in CI. That is why when we built the OpenAPI pipeline for API schemas, we built in mechanisms to allow applying linting rules, using <a href=\"https://redocly.com/docs/cli/\">redocly CLI</a>, that will either warn the engineer or block them entirely, depending on the severity of the violation.</p><p>For example, we want to encourage usage of fine grain API tokens, so we should present those authentication schemes first and ensure they are supported for new endpoints. To enforce this, we can write a <a href=\"https://redocly.com/docs/cli/configuration/reference/plugins/\">redocly plugin</a>:</p><!--kg-card-begin: markdown--><pre><code class=\"language-JavaScript\">module.exports = {\n    id: 'local',\n    assertions: {\n        apiTokenAuthSupported: (value, options, location) =&gt; {\n            for (const i in value) {\n                if (value.at(i)?.hasOwnProperty(&quot;api_token&quot;)) {\n                    return [];\n                }\n            }\n\n            return [{message: 'API Token should be defined as an auth method', location}];\n        },\n        apiTokenAuthDefinedFirst: (value, options, location) =&gt; {\n            if (!value.at(0)?.hasOwnProperty(&quot;api_token&quot;)) {\n                return [{message: 'API Tokens should be the first listed Security Option', location}];\n            }\n\n            return [];\n        },\n    },\n};\n</code></pre>\n<!--kg-card-end: markdown--><p>And the rule configuration:</p><!--kg-card-begin: markdown--><pre><code class=\"language-yaml\">rule/security-options-defined:\n  severity: error\n  subject:\n    type: Operation\n    property: security\n  where:\n  - subject:\n    type: Operation\n    property: security\n    assertions:\n      defined: true\n  assertions:\n    local/apiTokenAuthSupported: {}\n    local/apiTokenAuthDefinedFirst: {}\n</code></pre>\n<!--kg-card-end: markdown--><p>In this example, should a team forget to put the API token authentication scheme first, or define it at all, the CI run will fail. Teams are provided a helpful failure message with a link to the conventions to discover more if they need to understand why the change is recommended.</p><p>These lints can be used for style conventions, too. For our documentation descriptions, we like descriptions to start with a capital letter and end in a period. Again, we can add a lint to enforce this requirement.</p><!--kg-card-begin: markdown--><pre><code class=\"language-JavaScript\">module.exports = {\n    id: 'local',\n    assertions: {\n        descriptionIsFormatted: (value, options, location) =&gt; {\n            for (const i in value) {\n                if (/^[A-Z].*\\.$/.test(value)) {\n                    return [];\n                }\n            }\n\n            return [{message: 'Descriptions should start with a capital and end in a period.', location}];\n        },\n    },\n};\n</code></pre>\n<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code class=\"language-yaml\">rule/security-options-defined:\n  severity: error\n  subject:\n    type: Schema\n    property: description\n  assertions:\n    local/descriptionIsFormatted: {}\n</code></pre>\n<!--kg-card-end: markdown--><p>This makes shipping endpoints of the same quality much easier and prevents teams needing to sort through all the API design or resiliency patterns we may have introduced over the years – possibly even before they joined Cloudflare.</p><h2 id=\"building-the-generation-machine\">Building the generation machine</h2><p>Once we had our guiding principles, we started doing some analysis of our situation and saw that if we decided to build the solution entirely in house, we would be at least 6–9 months away from a single high quality SDK with the potential for additional follow-up work each time we had a new language addition. This wasn’t acceptable and prevented us from meeting the requirement of needing a low-cost followup for additional languages, so we explored the OpenAPI generation landscape.</p><p>Due to the size and complexity of our schemas, we weren’t able to use most off the shelf products. We tried a handful of solutions and workarounds, but we weren’t comfortable with any of the options; that was, until we tried <a href=\"https://www.stainlessapi.com/?ref=cloudflare_blog\">Stainless</a>. Founded by one of the engineers that built what many consider to be the best-in-class API experiences at Stripe, Stainless is dedicated to generating SDKs. If you've used the OpenAI <a href=\"https://github.com/openai/openai-python\">Python</a> or <a href=\"https://github.com/openai/openai-node\">Typescript</a> SDKs, you've used an SDK generated by Stainless.</p><p>The way the platform offering works is that you bring your OpenAPI schemas and map them to methods with the configuration file. Those inputs then get fed into the generation engine to build your SDKs.</p><!--kg-card-begin: markdown--><pre><code class=\"language-yaml\">resources:\n  zones:\n    methods:\n      list: get /zones\n</code></pre>\n<!--kg-card-end: markdown--><p>The configuration above would allow you to generate various <code>client.zones.list()</code> operations across your SDKs.</p><p>This approach means we can do the majority of our changes using the existing API schemas, but if there is an SDK-specific issue, we can modify that behavior on a per-SDK basis using the configuration file.</p><p>An added benefit of using the Stainless generation engine is that it gives us a clear line of responsibility when discussing where a change should be made.</p><ul><li><strong>Service team:</strong> Knows their service best and manages the representation for end users.</li><li><strong>API team:</strong> Understands and implements best practices for APIs and SDK conventions, builds centralized tooling or components within the platform for all teams, and translates service mappings to align with Stainless.</li><li><strong>Stainless:</strong> Provides a simple interface to generate SDKs consistently.</li></ul><p>The decision to use Stainless has allowed us to move our focus from building the generation engine to instead building high-quality schemas to describe our services. In the span of a few months, we have gone from inconsistent, manually maintained SDKs to automatically shipping three language SDKs with hands-off updates freely flowing from the internal teams. Best of all, it is now a single pull request workflow for the majority of our changes – even if we were to add a new language or integration to the pipeline!</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"http://blog.cloudflare.com/content/images/2024/04/image2-17.png\" class=\"kg-image\" alt=\"Just a single pull request is now required to ship an SDK change.\" loading=\"lazy\" width=\"1338\" height=\"1226\"><figcaption><em>Just a single pull request is now required to ship an SDK change.</em></figcaption></figure><h2 id=\"lessons-from-our-journey-for-yours\">Lessons from our journey, for yours</h2><h3 id=\"mass-updates-made-easy\">Mass updates, made easy</h3><p>Depending on the age of your APIs, you will have a diverging history of how they are represented to customers. That may be as simple as path parameters being inconsistent or perhaps something more complex like different HTTP methods for updates. While you can handle these individually at any sort of scale, that just isn’t feasible. As of this post, Cloudflare offers roughly 1,300 publicly documented endpoints, and we needed a more automatable solution. For us, that was codemods. Codemods are a way of applying transformations to perform large scale refactoring of your codebase. This allows you to programmatically rewrite expressions, syntax or other parts of your code without having to manually go through every file. Think of it like find and replace, but on steroids and with more context of the underlying language constructs.</p><p>We started with a tool called <a href=\"https://comby.dev/\">comby</a>. We wrapped it in a custom CLI tool that knew how to speak to our version control endpoints and wired it in a way that provides a comby configuration TOML file, pull request description, and commit message for each transformation we needed to apply. Here is a sample comby configuration where we updated the URI paths to be consistently suffixed with _id instead of other variations (<code>_identifier</code>, <code>Identifier</code>, etc.) where we had a plural resource followed by an individual identifier.</p><!--kg-card-begin: markdown--><pre><code class=\"language-toml\">[account-id-1-path-consistency]\nmatch = 'paths/~accounts~1{account_identifier1}'\nrewrite = 'paths/~accounts~1{account_id}'\n\n[account-id-camelcase-path-consistency]\nmatch = 'paths/~accounts~1{accountId}'\nrewrite = 'paths/~accounts~1{account_id}'\n\n[placeholder-identifier-to-id]\nmatch = ':[_~_identifier}]' # need the empty hole match here since we are using unbalanced }\nrewrite = '_id}'\n\n[route-consistency-for-resource-plurals]\nmatch = ':[topic~/\\w+/]{:[id~\\w+]}'\nrewrite = ':[topic]{:[id]}'\nrule = 'where rewrite :[id] { :[x] -&gt; :[topic] }, rewrite :[id] { /:[x]s/ -&gt; :[x]_id }'\n\n[property-identifier-to-id]\nmatch = 'name: :[topic]_identifier'\nrewrite = 'name: :[topic]_id'\n</code></pre>\n<!--kg-card-end: markdown--><p>For an interactive version of this configuration, check out the <a href=\"https://comby.live/#%7B%22source%22:%22/zones/%7Bfoo%7D/rulesets/phases/%7Bbar%7D/entrypoint/versions/%7Bbaz%7D%22,%22match%22:%22:%5Btopic~/%5C%5Cw%2B/%5D%7B:%5Bid~%5C%5Cw%2B%5D%7D%22,%22rule%22:%22where%20rewrite%20:%5Bid%5D%20%7B%20:%5Bx%5D%20-%3E%20:%5Btopic%5D%20%7D,rewrite%20:%5Bid%5D%20%7B%20/:%5Bx%5Ds/%20-%3E%20:%5Bx%5D_id%20%7D%22,%22rewrite%22:%22:%5Btopic%5D%7B:%5Bid%5D%7D%22,%22language%22:%22.generic%22,%22substitution_kind%22:%22in_place%22,%22id%22:0%7D\">comby playground</a>.</p><p>This approach worked for the majority of our internal changes. However, knowing how difficult migrations can be, we also wanted a tool that we could provide to customers to use for their own SDK migrations. In the past we’ve used <a href=\"https://registry.terraform.io/providers/cloudflare/cloudflare/latest/docs/guides/version-3-upgrade\">comby for upgrades in the Terraform Provider</a> with great feedback. While comby is powerful, once you start using more complex expressions, the syntax can be difficult to understand unless you are familiar with it.</p><p>After looking around, we eventually found <a href=\"https://www.grit.io/\">Grit</a>. It is a tool that does everything we need (including the custom CLI) while being very familiar to anyone that understands basic Javascript through a query language, known as <a href=\"https://docs.grit.io/tutorials/gritql\">GritQL</a>. An added bonus here is that we are able to contribute to the <a href=\"https://docs.grit.io/patterns\">Grit Pattern Library</a>, so our migrations are <a href=\"https://app.grit.io/studio?preset=cloudflare_go_v2&amp;key=nt_BGTed1mbXzuvxZ9n2q\">only ever a single CLI invocation away</a> for anyone to use once they have the CLI installed.</p><!--kg-card-begin: markdown--><pre><code>// Migrate to the Golang v2 library \ngrit apply cloudflare_go_v2\n</code></pre>\n<!--kg-card-end: markdown--><h3 id=\"consistency-consistency-consistency\">Consistency, consistency, consistency</h3><p>Did I mention consistency is important? Before attempting to feed your OpenAPI schemas into any system (especially a homegrown one), get them consistent with the practices, structures, and how you intend to represent them. This makes determining what is a bug in your generation pipeline vs a bug in your schema much easier. If it’s broken everywhere, it’s the generation pipeline, otherwise it’s an isolated bug to track down in your schema.</p><p>Having consistency leads into a better developer experience. From our examples above, if your routes always follow the plural resource name followed by an identifier, the end user doesn’t have to think about what the inputs need to be. The consistency and conventions lead them there – even if your documentation is lacking.</p><h3 id=\"use-shared-refs-sparingly\">Use shared $refs sparingly</h3><p>It seems like a great idea for reusability at the time of writing them, but when overused, <code>$ref</code>s make finding correct values problematic and lead to <a href=\"https://en.wikipedia.org/wiki/Cargo_cult_programming\">cargo cult</a> practices. In turn, this leads to lower quality and difficult-to-change schemas despite looking more usable from the outset. Consider the following schema example:</p><!--kg-card-begin: markdown--><pre><code class=\"language-yaml\">thing_base:\n  type: object\n  required:\n    - id\n  properties:\n    updated_at:\n      $ref: '#/components/schemas/thing_updated_at'\n    created_at:\n      $ref: '#/components/schemas/thing_updated_at'\n    id:\n      $ref: '#/components/schemas/thing_identifier'\n      \nthing_updated_at:\n  type: string\n  format: date-time\n  description: When the resource was last updated.\n  example: &quot;2014-01-01T05:20:00Z&quot;\n  \nthing_created_at:\n  type: string\n  format: date-time\n  description: When the resource was created.\n  example: &quot;2014-01-01T05:20:00Z&quot;\n\nthing_id:\n  type: string\n  description: Unique identifier of the resource.\n  example: &quot;2014-01-01T05:20:00Z&quot;\n</code></pre>\n<!--kg-card-end: markdown--><p>Did you spot the bug? Have another look at the <code>created_at</code> value. You likely didn’t catch it at first glance, but this is a common issue when needing to reference reusable values. Here, it is a minor annoyance as the documentation would be incorrect (<code>created_at</code> would have the description of <code>updated_at</code>), but in other cases, it could be a completely incorrect schema representation.</p><p>For us, the correct usage of <code>$ref</code> values is predominantly where you have potential for multiple component schemas that may be used as part of a <code>oneOf</code>, <code>allOf</code> or <code>anyOf</code> directive.</p><!--kg-card-begin: markdown--><pre><code class=\"language-yaml\">dns_record:\n  oneOf:\n    - $ref: '#/components/schemas/dns-records_ARecord'\n    - $ref: '#/components/schemas/dns-records_AAAARecord'\n    - $ref: '#/components/schemas/dns-records_CAARecord'\n    - $ref: '#/components/schemas/dns-records_CERTRecord'\n    - $ref: '#/components/schemas/dns-records_CNAMERecord'\n    - $ref: '#/components/schemas/dns-records_DNSKEYRecord'\n    - $ref: '#/components/schemas/dns-records_DSRecord'\n    - $ref: '#/components/schemas/dns-records_HTTPSRecord'\n    - $ref: '#/components/schemas/dns-records_LOCRecord'\n    - $ref: '#/components/schemas/dns-records_MXRecord'\n    - $ref: '#/components/schemas/dns-records_NAPTRRecord'\n    - $ref: '#/components/schemas/dns-records_NSRecord'\n    - $ref: '#/components/schemas/dns-records_PTRRecord'\n    - $ref: '#/components/schemas/dns-records_SMIMEARecord'\n    - $ref: '#/components/schemas/dns-records_SRVRecord'\n    - $ref: '#/components/schemas/dns-records_SSHFPRecord'\n    - $ref: '#/components/schemas/dns-records_SVCBRecord'\n    - $ref: '#/components/schemas/dns-records_TLSARecord'\n    - $ref: '#/components/schemas/dns-records_TXTRecord'\n    - $ref: '#/components/schemas/dns-records_URIRecord'\n  type: object\n  required:\n    - id\n    - type\n    - name\n    - content\n    - proxiable\n    - created_on\n    - modified_on\n</code></pre>\n<!--kg-card-end: markdown--><p>When in doubt, consider the <a href=\"https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it\">YAGNI principle</a> instead. You can always refactor and extract this later once you have enough uses to determine the correct abstraction.</p><h3 id=\"design-your-ideal-usage-and-work-backwards\">Design your ideal usage and work backwards</h3><p>Before we wrote a single line of code to solve the problem of generation, we prepared language design documents for each of our target languages that followed the <a href=\"https://tom.preston-werner.com/2010/08/23/readme-driven-development.html\">README-driven</a> design principles. This meant our focus from the initial design was on the usability of the library and not on the technical challenges that we would eventually encounter. This led us to identify problems and patterns early with how various language nuances would surface to the end user without investing in anything more than a document. Python keyword arguments, Go interfaces, how to enforce required parameters, client instantiation and overrides, types – all considerations made up front that helped minimize the number of unknowns as we built out support.</p><h2 id=\"what%E2%80%99s-next\">What’s next?</h2><p>When we embarked on the OpenAPI journey, we knew it was only the beginning and would eventually open more doors and quality of life improvements for teams and customers alike. Now that we have a few language SDKs available, we’re turning our attention to generating our <a href=\"https://github.com/cloudflare/terraform-provider-cloudflare\">Terraform Provider</a> using the same guiding principles to further minimize the maintenance burden. But that’s still not all. Coming later in 2024 are more improvements and integrations with other parts of the Cloudflare Developer Platform, so stay tuned.</p><p>If you haven’t already, check out one of the SDKs in <a href=\"https://github.com/cloudflare/cloudflare-go\">Go</a>, <a href=\"https://github.com/cloudflare/clouflare-typescript\">Typescript</a> and <a href=\"https://github.com/cloudflare/clouflare-python\">Python</a> today. If you’d like support for a different language, go <a href=\"https://forms.gle/TPQw3eoiRbyQBfEv5\">here</a> to submit your details to help determine the next language. We’d love to hear what languages you would like offered as a Cloudflare SDK.</p>",
		"id": "66277eb37c0f59000a6a8dfa",
		"meta_description": "During Developer Week 2024, we announced the revamped SDKs that are automatically generated using our OpenAPI schemas. Today, we’re taking a deeper look at how the pipeline works and share lessons we’ve learned along the way.",
		"meta_title": null,
		"og_description": null,
		"og_image": "http://blog.cloudflare.com/content/images/2024/04/Lessons-from-building-an-automated-SDK-pipeline-OG-1.png",
		"og_title": null,
		"primary_author": {
			"id": "635aebdfabc75e000aade24f",
			"name": "Jacob Bednarz",
			"slug": "jacob-bednarz",
			"profile_image": "http://blog.cloudflare.com/content/images/2024/04/IMG_2693.jpg",
			"cover_image": null,
			"bio": "System Engineer, Control Plane",
			"website": "https://jacobbednarz.com",
			"location": "Australia",
			"facebook": null,
			"twitter": "@jacobbednarz",
			"meta_title": null,
			"meta_description": null,
			"url": "http://blog.cloudflare.com/author/jacob-bednarz/"
		},
		"primary_tag": null,
		"published_at": "2024-04-23T14:00:29.000+01:00",
		"reading_time": 12,
		"slug": "lessons-from-building-an-automated-sdk-pipeline",
		"tags": [
			{
				"id": "66277f347c0f59000a6a8e02",
				"name": "#BLOG-2360",
				"slug": "hash-blog-2360",
				"description": null,
				"feature_image": null,
				"visibility": "internal",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/404/"
			},
			{
				"id": "660d7e6ca5fcdf000a08fb24",
				"name": "SDK",
				"slug": "sdk",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/sdk/"
			},
			{
				"id": "65c0d31851a92e000adeae66",
				"name": "#front-page",
				"slug": "hash-front-page",
				"description": null,
				"feature_image": null,
				"visibility": "internal",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/404/"
			}
		],
		"title": "Lessons from building an automated SDK pipeline",
		"twitter_description": null,
		"twitter_image": "http://blog.cloudflare.com/content/images/2024/04/Lessons-from-building-an-automated-SDK-pipeline-OG.png",
		"twitter_title": null,
		"updated_at": "2024-04-23T13:59:27.000+01:00",
		"url": "http://blog.cloudflare.com/lessons-from-building-an-automated-sdk-pipeline/",
		"uuid": "58b01c80-77c9-49a4-aa1f-7566d6e5fb47",
		"visibility": "public"
	}
}