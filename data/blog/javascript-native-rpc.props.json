{
	"locale": "en-us",
	"post": {
		"access": true,
		"authors": [
			{
				"id": "5d1644b141acde0011a94f9f",
				"name": "Kenton Varda",
				"slug": "kenton-varda",
				"profile_image": "https://blog-cloudflare-com-assets.storage.googleapis.com/2020/08/avatar-github.jpg",
				"cover_image": null,
				"bio": null,
				"website": null,
				"location": null,
				"facebook": null,
				"twitter": "@kentonvarda",
				"meta_title": null,
				"meta_description": null,
				"url": "http://blog.cloudflare.com/author/kenton-varda/"
			}
		],
		"canonical_url": null,
		"codeinjection_foot": null,
		"codeinjection_head": null,
		"comment_id": "660ed6aca5fcdf000a0902b0",
		"comments": false,
		"created_at": "2024-04-04T17:34:52.000+01:00",
		"custom_excerpt": "Cloudflare Workers now features a built-in RPC (Remote Procedure Call) system for use in Worker-to-Worker and Worker-to-Durable Object communication, with absolutely minimal boilerplate. We've designed an RPC system so expressive that calling a remote service can feel like using a library",
		"custom_template": null,
		"email_subject": null,
		"excerpt": "Cloudflare Workers now features a built-in RPC (Remote Procedure Call) system for use in Worker-to-Worker and Worker-to-Durable Object communication, with absolutely minimal boilerplate. We've designed an RPC system so expressive that calling a remote service can feel like using a library",
		"feature_image": "http://blog.cloudflare.com/content/images/2024/04/image2-11.png",
		"feature_image_alt": "We've added JavaScript-native RPC to Cloudflare Workers",
		"feature_image_caption": null,
		"featured": false,
		"frontmatter": null,
		"html": "<figure class=\"kg-card kg-image-card\"><img src=\"http://blog.cloudflare.com/content/images/2024/04/image2-12.png\" class=\"kg-image\" alt=\"We've added JavaScript-native RPC to Cloudflare Workers\" loading=\"lazy\" width=\"1999\" height=\"1125\"></figure><p>Cloudflare Workers now features a built-in RPC (Remote Procedure Call) system enabling seamless Worker-to-Worker and Worker-to-Durable Object communication, with almost no boilerplate. You just define a class:</p><!--kg-card-begin: markdown--><pre><code class=\"language-JavaScript\">export class MyService extends WorkerEntrypoint {\n  sum(a, b) {\n    return a + b;\n  }\n}\n</code></pre>\n<!--kg-card-end: markdown--><p>And then you call it:</p><!--kg-card-begin: markdown--><pre><code class=\"language-Java\">let three = await env.MY_SERVICE.sum(1, 2);\n</code></pre>\n<!--kg-card-end: markdown--><p>No schemas. No routers. Just define methods of a class. Then call them. That's it.</p><h2 id=\"but-thats-not-it\">But that's not it</h2><p>This isn't just any old RPC. We've designed an RPC system so expressive that calling a remote service can feel like using a library – without any need to actually import a library! This is important not just for ease of use, but also security: fewer dependencies means fewer critical security updates and less exposure to supply-chain attacks.</p><p>To this end, here are some of the features of Workers RPC:</p><ul><li>For starters, you can pass <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm#supported_types\"><strong>Structured Clonable</strong></a><strong> types</strong> as the params or return value of an RPC. (That means that, unlike JSON, Dates just work, and you can even have cycles.)</li><li>You can additionally pass <strong>functions</strong> in the params or return value of other functions. When the other side calls the function you passed to it, they make a new RPC back to you.</li><li>Similarly, you can pass <strong>objects with methods</strong>. Method calls become further RPCs.</li><li>RPC to another Worker (over a Service Binding) usually does not even cross a network. In fact, the other Worker usually runs in the very same thread as the caller, <strong>reducing latency to zero</strong>. Performance-wise, it’s almost as fast as an actual function call.</li><li>When RPC does cross a network (e.g. to a Durable Object), you can invoke a method and then speculatively invoke further methods on the result in a <strong>single network round trip</strong>.</li><li>You can send a <strong>byte stream over RPC</strong>, and the system will automatically stream the bytes with proper flow control.</li><li>All of this is <em>secure</em>, based on the <strong>object-capability model</strong>.</li><li>The <a href=\"https://github.com/cloudflare/workerd/blob/03629a6553751d3614a8b91926e380213e100d94/src/workerd/io/worker-interface.capnp#L302\">protocol</a> and <a href=\"https://github.com/cloudflare/workerd/blob/03629a6553751d3614a8b91926e380213e100d94/src/workerd/api/worker-rpc.c++\">implementation</a> are fully open source as part of <a href=\"https://github.com/cloudflare/workerd/\">workerd</a>.</li></ul><p>Workers RPC is a JavaScript-native RPC system. Under the hood, it is built on <a href=\"https://capnproto.org/rpc.html\">Cap'n Proto</a>. However, unlike Cap'n Proto, Workers RPC does not require you to write a schema. (Of course, you can use TypeScript if you like, and we provide tools to help with this.)</p><p>In general, Workers RPC is designed to \"just work\" using idiomatic JavaScript code, so you shouldn't have to spend too much time looking at docs. We'll give you an overview in this blog post. But if you want to understand the full feature set, <a href=\"https://developers.cloudflare.com/workers/runtime-apis/rpc/\">check out the documentation</a>.</p><h2 id=\"why-rpc-and-what-is-rpc-anyway\">Why RPC? (And what is RPC anyway?)</h2><p>Remote Procedure Calls (RPC) are a way of expressing communications between two programs over a network. Without RPC, you might communicate using a protocol like HTTP. With HTTP, though, you must format and parse your communications as an HTTP request and response, perhaps designed in <a href=\"https://en.wikipedia.org/wiki/REST\">REST</a> style. RPC systems try to make communications look like a regular function call instead, as if you were calling a library rather than a remote service. The RPC system provides a \"stub\" object on the client side which stands in for the real server-side object. When a method is called on the stub, the RPC system figures out how to serialize and transmit the parameters to the server, invoke the method on the server, and then transmit the return value back.</p><p>The merits of RPC have been subject to a great deal of debate. RPC is often accused of committing many of the <a href=\"https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing\">fallacies of distributed computing</a>.</p><p>But this reputation is outdated. When RPC was first invented some 40 years ago, async programming barely existed. We did not have Promises, much less async and await. Early RPC was synchronous: calls would block the calling thread waiting for a reply. At best, latency made the program slow. At worst, network failures would hang or crash the program. No wonder it was deemed \"broken\".</p><p>Things are different today. We have Promise and async and await, and we can throw exceptions on network failures. We even understand how RPCs can be pipelined so that a chain of calls takes only one network round trip. Many large distributed systems you likely use every day are built on RPC. It works.</p><p>The fact is, RPC fits the programming model we're used to. Every programmer is trained to think in terms of APIs composed of function calls, not in terms of byte stream protocols nor even REST. Using RPC frees you from the need to constantly translate between mental models, allowing you to move faster.</p><h2 id=\"example-authentication-service\">Example: Authentication Service</h2><p>Here's a common scenario: You have one Worker that implements an application, and another Worker that is responsible for authenticating user credentials. The app Worker needs to call the auth Worker on each request to check the user's cookie.</p><p>This example uses a <strong>Service Binding</strong>, which is a way of configuring one Worker with a private channel to talk to another, without going through a public URL. Here, we have an application Worker that has been configured with a service binding to the Auth worker.</p><p>Before RPC, all communications between Workers needed to use HTTP. So, you might write code like this:</p><!--kg-card-begin: markdown--><pre><code class=\"language-JavaScript\">// OLD STYLE: HTTP-based service bindings.\nexport default {\n  async fetch(req, env, ctx) {\n    // Call the auth service to authenticate the user's cookie.\n    // We send it an HTTP request using a service binding.\n\n    // Construct a JSON request to the auth service.\n    let authRequest = {\n      cookie: req.headers.get(&quot;Cookie&quot;)\n    };\n\n    // Send it to env.AUTH_SERVICE, which is our service binding\n    // to the auth worker.\n    let resp = await env.AUTH_SERVICE.fetch(\n        &quot;https://auth/check-cookie&quot;, {\n      method: &quot;POST&quot;,\n      headers: {\n        &quot;Content-Type&quot;: &quot;application/json; charset=utf-8&quot;,\n      },\n      body: JSON.stringify(authRequest)\n    });\n\n    if (!resp.ok) {\n      return new Response(&quot;Internal Server Error&quot;, {status: 500});\n    }\n\n    // Parse the JSON result.\n    let authResult = await resp.json();\n\n    // Use the result.\n    if (!authResult.authorized) {\n      return new Response(&quot;Not authorized&quot;, {status: 403});\n    }\n    let username = authResult.username;\n\n    return new Response(`Hello, ${username}!`);\n  }\n}\n</code></pre>\n<!--kg-card-end: markdown--><p>Meanwhile, your auth server might look like:</p><!--kg-card-begin: markdown--><pre><code class=\"language-JavaScript\">// OLD STYLE: HTTP-based auth server.\nexport default {\n  async fetch(req, env, ctx) {\n    // Parse URL to decide what endpoint is being called.\n    let url = new URL(req.url);\n    if (url.pathname == &quot;/check-cookie&quot;) {\n      // Parse the request.\n      let authRequest = await req.json();\n\n      // Look up cookie in Workers KV.\n      let cookieInfo = await env.COOKIE_MAP.get(\n          hash(authRequest.cookie), &quot;json&quot;);\n\n      // Construct the response.\n      let result;\n      if (cookieInfo) {\n        result = {\n          authorized: true,\n          username: cookieInfo.username\n        };\n      } else {\n        result = { authorized: false };\n      }\n\n      return Response.json(result);\n    } else {\n      return new Response(&quot;Not found&quot;, {status: 404});\n    }\n  }\n}\n</code></pre>\n<!--kg-card-end: markdown--><p>This code has a lot of boilerplate involved in setting up an HTTP request to the auth service. With RPC, we can instead express this as a function call:</p><!--kg-card-begin: markdown--><pre><code class=\"language-JavaScript\">// NEW STYLE: RPC-based service bindings\nexport default {\n  async fetch(req, env, ctx) {\n    // Call the auth service to authenticate the user's cookie.\n    // We invoke it using a service binding.\n    let authResult = await env.AUTH_SERVICE.checkCookie(\n        req.headers.get(&quot;Cookie&quot;));\n\n    // Use the result.\n    if (!authResult.authorized) {\n      return new Response(&quot;Not authorized&quot;, {status: 403});\n    }\n    let username = authResult.username;\n\n    return new Response(`Hello, ${username}!`);\n  }\n}\n</code></pre>\n<!--kg-card-end: markdown--><p>And the server side becomes:</p><!--kg-card-begin: markdown--><pre><code class=\"language-JavaScript\">// NEW STYLE: RPC-based auth server.\nimport { WorkerEntrypoint } from &quot;cloudflare:workers&quot;;\n\nexport class AuthService extends WorkerEntrypoint {\n  async checkCookie(cookie) {\n    // Look up cookie in Workers KV.\n    let cookieInfo = await this.env.COOKIE_MAP.get(\n        hash(cookie), &quot;json&quot;);\n\n    // Return result.\n    if (cookieInfo) {\n      return {\n        authorized: true,\n        username: cookieInfo.username\n      };\n    } else {\n      return { authorized: false };\n    }\n  }\n}\n</code></pre>\n<!--kg-card-end: markdown--><p>This is a pretty nice simplification… but we can do much more!</p><h3 id=\"lets-get-fancy-or-should-i-say%E2%80%A6-classy\">Let's get fancy! Or should I say… classy?</h3><p>Let's say we want our auth service to do a little more. Instead of just checking cookies, it provides a whole API around user accounts. In particular, it should let you:</p><ul><li>Get or update the user's profile info.</li><li>Send the user an email notification.</li><li>Append to the user's activity log.</li></ul><p>But, these operations should only be allowed after presenting the user's credentials.</p><p>Here's what the server might look like:</p><!--kg-card-begin: markdown--><pre><code class=\"language-JavaScript\">import { WorkerEntrypoint, RpcTarget } from &quot;cloudflare:workers&quot;;\n\n// `User` is an RPC interface to perform operations on a particular\n// user. This class is NOT exported as an entrypoint; it must be\n// received as the result of the checkCookie() RPC.\nclass User extends RpcTarget {\n  constructor(uid, env) {\n    super();\n\n    // Note: Instance members like these are NOT exposed over RPC.\n    // Only class (prototype) methods and properties are exposed.\n    this.uid = uid;\n    this.env = env;\n  }\n\n  // Get/set user profile, backed by Worker KV.\n  async getProfile() {\n    return await this.env.PROFILES.get(this.uid, &quot;json&quot;);\n  }\n  async setProfile(profile) {\n    await this.env.PROFILES.put(this.uid, JSON.stringify(profile));\n  }\n\n  // Send the user a notification email.\n  async sendNotification(message) {\n    let addr = await this.env.EMAILS.get(this.uid);\n    await this.env.EMAIL_SERVICE.send(addr, message);\n  }\n\n  // Append to the user's activity log.\n  async logActivity(description) {\n    // (Please excuse this somewhat problematic implementation,\n    // this is just a dumb example.)\n    let timestamp = new Date().toISOString();\n    await this.env.ACTIVITY.put(\n        `${this.uid}/${timestamp}`, description);\n  }\n}\n\n// Now we define the entrypoint service, which can be used to\n// get User instances -- but only by presenting the cookie.\nexport class AuthService extends WorkerEntrypoint {\n  async checkCookie(cookie) {\n    // Look up cookie in Workers KV.\n    let cookieInfo = await this.env.COOKIE_MAP.get(\n        hash(cookie), &quot;json&quot;);\n\n    if (cookieInfo) {\n      return {\n        authorized: true,\n        user: new User(cookieInfo.uid, this.env),\n      };\n    } else {\n      return { authorized: false };\n    }\n  }\n}\n</code></pre>\n<!--kg-card-end: markdown--><p>Now we can write a Worker that uses this API while displaying a web page:</p><!--kg-card-begin: markdown--><pre><code class=\"language-JavaScript\">export default {\n  async fetch(req, env, ctx) {\n    // `using` is a new JavaScript feature. Check out the\n    // docs for more on this:\n    // https://developers.cloudflare.com/workers/runtime-apis/rpc/lifecycle/\n    using authResult = await env.AUTH_SERVICE.checkCookie(\n        req.headers.get(&quot;Cookie&quot;));\n    if (!authResult.authorized) {\n      return new Response(&quot;Not authorized&quot;, {status: 403});\n    }\n\n    let user = authResult.user;\n    let profile = await user.getProfile();\n\n    await user.logActivity(&quot;You visited the site!&quot;);\n    await user.sendNotification(\n        `Thanks for visiting, ${profile.name}!`);\n\n    return new Response(`Hello, ${profile.name}!`);\n  }\n}\n</code></pre>\n<!--kg-card-end: markdown--><p>Finally, this worker needs to be configured with a service binding pointing at the AuthService class. Its wrangler.toml may look like:</p><!--kg-card-begin: markdown--><pre><code>name = &quot;app-worker&quot;\nmain = &quot;./src/app.js&quot;\n\n# Declare a service binding to the auth service.\n[[services]]\nbinding = &quot;AUTH_SERVICE&quot;    # name of the binding in `env`\nservice = &quot;auth-service&quot;    # name of the worker in the dashboard\nentrypoint = &quot;AuthService&quot;  # name of the exported RPC class\n</code></pre>\n<!--kg-card-end: markdown--><h3 id=\"wait-how\">Wait, how?</h3><p>What exactly happened here? The Server created an instance of the class User and returned it to the client. It has methods that the client can then just call? Are we somehow transferring code over the wire?</p><p>No, absolutely not! All code runs strictly in the <a href=\"https://developers.cloudflare.com/workers/reference/how-workers-works/#isolates\">isolate</a> where it was originally loaded. What actually happens is, when the return value is passed over RPC, all class instances are replaced with RPC stubs. The stub, when called, makes a new RPC back to the server, where it calls the method on the original User object that was created there:</p><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"http://blog.cloudflare.com/content/images/2024/04/image1-8.png\" class=\"kg-image\" alt loading=\"lazy\" width=\"1999\" height=\"1000\"></figure><p>But then you might ask: how does the RPC stub know what methods are available? Is a list of methods passed over the wire?</p><p>In fact, no. The RPC stub is a special object called a \"<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy\">Proxy</a>\". It implements a \"wildcard method\", that is, it appears to have an infinite number of methods of every possible name. When you try to call a method, the name you called is sent to the server. If the original object has no such method, an exception is thrown.</p><h3 id=\"did-you-spot-the-security\">Did you spot the security?</h3><p>In the above example, we see that RPC is easy to use. We made an object! We called it! It all just felt natural, like calling a local API! Hooray!</p><p>But there's another extremely important property that the AuthService API has which you may have missed: <strong>As designed, you cannot perform any operation on a user without first checking the cookie.</strong> This is true despite the fact that the individual method calls do not require sending the cookie again, and the User object itself doesn't store the cookie.</p><p>The trick is, the initial checkCookie() RPC is what returns a User object in the first place. The AuthService API does not provide any other way to obtain a User instance. The RPC client cannot create a User object out of thin air, and cannot call methods of an object without first explicitly receiving a reference to it.</p><p>This is called capability-based security: we say that the User reference received by the client is a \"capability\", because receiving it grants the client the ability to perform operations on the user. The getProfile() method grants this capability only when the client has presented the correct cookie.</p><p>Capability-based security is often like this: security can be woven naturally into your APIs, rather than feel like an additional concern bolted on top.</p><h3 id=\"more-security-named-entrypoints\">More security: Named entrypoints</h3><p>Another subtle but important detail to call out: in the above example, the auth service's RPC API is exported as a named class:</p><!--kg-card-begin: markdown--><pre><code class=\"language-JavaScript\">export class AuthService extends WorkerEntrypoint {\n</code></pre>\n<!--kg-card-end: markdown--><p>And in our wrangler.toml for the calling worker, we had to specify an \"entrypoint\", matching the class name:</p><!--kg-card-begin: markdown--><pre><code>entrypoint = &quot;AuthService&quot;  # name of the exported RPC class\n</code></pre>\n<!--kg-card-end: markdown--><p>In the past, service bindings would bind to the \"default\" entrypoint, declared with export default {. But, the default entrypoint is also typically exposed to the Internet, e.g. automatically mapped to a hostname under workers.dev (unless you explicitly turn that off). It can be tricky to safely assume that requests arriving at this entrypoint are in any way trusted.</p><p>With named entrypoints, this all changes. A named entrypoint is only accessible to Workers which have explicitly declared a binding to it. By default, only Workers on your own account can declare such bindings. Moreover, the binding must be declared at deploy time; a Worker cannot create new service bindings at runtime.</p><p>Thus, you can trust that requests arriving at a named entrypoint can only have come from Workers on your account and for which you explicitly created a service binding. In the future, we plan to extend this pattern further with the ability to lock down entrypoints, audit which Workers have bindings to them, tell the callee information about who is calling at runtime, and so on. With these tools, there is no need to write code in your app itself to authenticate access to internal APIs; the system does it for you.</p><h3 id=\"what-about-type-safety\">What about type safety?</h3><p>Workers RPC works in an entirely dynamically-typed way, just as JavaScript itself does. But just as you can apply TypeScript on top of JavaScript in general, you can apply it to Workers RPC.</p><p>The <a href=\"https://www.npmjs.com/package/@cloudflare/workers-types\"><code>@cloudflare/workers-types package</code></a> defines the type <code>Service&lt;MyEntrypointType&gt;</code>, which describes the type of a service binding. <code>MyEntrypointType</code> is the type of your server-side interface. <code>Service&lt;MyEntrypointType&gt;</code> applies all the necessary transformations to turn this into a client-side type, such as converting all methods to async, replacing functions and <code>RpcTargets</code> with (properly-typed) stubs, and so on.</p><p>It is up to you to share the definition of <code>MyEntrypointType</code> between your server app and its clients. You might do this by defining the interface in a separate shared TypeScript file, or by extracting a <code>.d.ts</code> type declaration file from your server code using <a href=\"https://www.typescriptlang.org/tsconfig/#declaration\"><code>tsc --declaration</code></a>.</p><p>With that done, you can apply types to your client:</p><!--kg-card-begin: markdown--><pre><code class=\"language-JavaScript\">import { WorkerEntrypoint } from &quot;cloudflare:workers&quot;;\n\n// The interface that your server-side entrypoint implements.\n// (This would probably be imported from a .d.ts file generated\n// from your server code.)\ndeclare class MyEntrypointType extends WorkerEntrypoint {\n  sum(a: number, b: number): number;\n}\n\n// Define an interface Env specifying the bindings your client-side\n// worker expects.\ninterface Env {\n  MY_SERVICE: Service&lt;MyEntrypointType&gt;;\n}\n\n// Define the client worker's fetch handler with typed Env.\nexport default &lt;ExportedHandler&lt;Env&gt;&gt; {\n  async fetch(req, env, ctx) {\n    // Now env.MY_SERVICE is properly typed!\n    const result = await env.MY_SERVICE.sum(1, 2);\n    return new Response(result.toString());\n  }\n}\n</code></pre>\n<!--kg-card-end: markdown--><h2 id=\"rpc-to-durable-objects\">RPC to Durable Objects</h2><p><a href=\"https://developers.cloudflare.com/durable-objects/\">Durable Objects</a> allow you to create a \"named\" worker instance somewhere on the network that multiple other workers can then talk to, in order to coordinate between them. Each Durable Object also has its own private on-disk storage where it can store state long-term.</p><p>Previously, communications with a Durable Object had to take the form of HTTP requests and responses. With RPC, you can now just declare methods on your Durable Object class, and call them on the stub. One catch: to opt into RPC, you must declare your Durable Object class with extends DurableObject, like so:</p><!--kg-card-begin: markdown--><pre><code class=\"language-JavaScript\">import { DurableObject } from &quot;cloudflare:workers&quot;;\n\nexport class Counter extends DurableObject {\n  async increment() {\n    // Increment our stored value and return it.\n    let value = await this.ctx.storage.get(&quot;value&quot;);\n    value = (value || 0) + 1;\n    this.ctx.storage.put(&quot;value&quot;, value);\n    return value;\n  }\n}\n</code></pre>\n<!--kg-card-end: markdown--><p>Now we can call it like:</p><!--kg-card-begin: markdown--><pre><code class=\"language-JavaScript\">let stub = env.COUNTER_NAMESPACE.get(id);\nlet value = await stub.increment();\n</code></pre>\n<!--kg-card-end: markdown--><p><code>TypeScript</code> is supported here too, by defining your binding with type <code>DurableObjectNamespace&lt;ServerType&gt;</code>:</p><!--kg-card-begin: markdown--><pre><code class=\"language-JavaScript\">interface Env {\n  COUNTER_NAMESPACE: DurableObjectNamespace&lt;Counter&gt;;\n}\n</code></pre>\n<!--kg-card-end: markdown--><h3 id=\"eliding-awaits-with-speculative-calls\">Eliding awaits with speculative calls</h3><p>When talking to a Durable Object, the object may be somewhere else in the world from the caller. RPCs must cross the network. This takes time: despite our best efforts, we still haven't figured out how to make information travel faster than the speed of light.</p><p>When you have a complex RPC interface where one call returns an object on which you wish to make further method calls, it's easy to end up with slow code that makes too many round trips over the network.</p><!--kg-card-begin: markdown--><pre><code class=\"language-JavaScript\">// Makes three round trips.\nlet foo = await stub.foo();\nlet baz = await foo.bar.baz();\nlet corge = await baz.qux[3].corge();\n</code></pre>\n<!--kg-card-end: markdown--><p>Workers RPC features a way to avoid this: If you know that a call will return a value containing a stub, and all you want to do with it is invoke a method on that stub, you can <em>skip awaiting it</em>:</p><!--kg-card-begin: markdown--><pre><code class=\"language-JavaScript\">// Same thing, only one round trip.\nlet foo = stub.foo();\nlet baz = foo.bar.baz();\nlet corge = await baz.qux[3].corge();\n</code></pre>\n<!--kg-card-end: markdown--><p>Whoa! How does this work?</p><p>RPC methods do not return normal promises. Instead, they return special RPC promises. These objects are \"<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise#thenables\">custom thenables</a>\", which means you can use them in all the ways you'd use a regular Promise, like awaiting it or calling .then() on it.</p><p>But an RPC promise is more than just a thenable. It is also a proxy. Like an RPC stub, it has a wildcard property. You can use this to express speculative RPC calls on the eventual result, before it has actually resolved. These speculative calls will be sent to the server immediately, so that they can begin executing as soon as the first RPC has finished there, before the result has actually made its way back over the network to the client.</p><p>This feature is also known as \"Promise Pipelining\". Although it isn't explicitly a security feature, it is commonly provided by object-capability RPC systems like Cap'n Proto.</p><h2 id=\"the-future-custom-bindings-marketplace\">The future: Custom Bindings Marketplace?</h2><p>For now, Service Bindings and Durable Objects only allow communication between Workers running on the same account. So, RPC can only be used to talk between your own Workers.</p><p>But we'd like to take it further.</p><p>We have previously explained <a href=\"http://blog.cloudflare.com/workers-environment-live-object-bindings\">why Workers environments contain live objects</a>, also known as \"bindings\". But today, only Cloudflare can add new binding types to the Workers platform – like Queues, KV, or D1. But what if <em>anyone</em> could invent their own binding type, and give it to other people?</p><p>Previously, we thought this would require creating a way to automatically load client libraries into the calling Workers. That seemed scary: it meant using someone's binding would require trusting their code to run inside your isolate. With RPC, there's no such trust. The binding only sees exactly what you explicitly pass to it. It cannot compromise the rest of your Worker.</p><p>Could Workers RPC provide the basis for a \"bindings marketplace\", where people can offer rich JavaScript APIs to each other in an easy and secure way? We're excited to explore and find out.</p><h2 id=\"try-it-now\">Try it now</h2><p>Workers RPC is available today for all Workers users. To get started, <a href=\"https://developers.cloudflare.com/workers/runtime-apis/rpc/\">check out the docs</a>.</p>",
		"id": "660ed6aca5fcdf000a0902b0",
		"meta_description": "Cloudflare Workers now features a built-in RPC (Remote Procedure Call) system for use in Worker-to-Worker and Worker-to-Durable Object communication, with absolutely minimal boilerplate. We've designed an RPC system so expressive that calling a remote service can feel like using a library.",
		"meta_title": null,
		"og_description": null,
		"og_image": "http://blog.cloudflare.com/content/images/2024/04/We-ve-added-JavaScript-native-RPC-to-Cloudflare-Workers-OG-1.png",
		"og_title": null,
		"primary_author": {
			"id": "5d1644b141acde0011a94f9f",
			"name": "Kenton Varda",
			"slug": "kenton-varda",
			"profile_image": "https://blog-cloudflare-com-assets.storage.googleapis.com/2020/08/avatar-github.jpg",
			"cover_image": null,
			"bio": null,
			"website": null,
			"location": null,
			"facebook": null,
			"twitter": "@kentonvarda",
			"meta_title": null,
			"meta_description": null,
			"url": "http://blog.cloudflare.com/author/kenton-varda/"
		},
		"primary_tag": null,
		"published_at": "2024-04-05T14:00:38.000+01:00",
		"reading_time": 13,
		"slug": "javascript-native-rpc",
		"tags": [
			{
				"id": "660ed768a5fcdf000a0902de",
				"name": "#BLOG-2378",
				"slug": "hash-blog-2378",
				"description": null,
				"feature_image": null,
				"visibility": "internal",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/404/"
			},
			{
				"id": "607030964b1e0f03f340f2d8",
				"name": "Developer Week",
				"slug": "developer-week",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/developer-week/"
			},
			{
				"id": "5d16450341acde0011a95204",
				"name": "Developers",
				"slug": "developers",
				"description": null,
				"feature_image": "http://blog.cloudflare.com/content/images/2020/10/Developers-1.png",
				"visibility": "public",
				"meta_title": "Cloudflare Blog: Developers",
				"meta_description": "Collection of Cloudflare blog posts tagged 'Developers'.",
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/developers/"
			},
			{
				"id": "65c0d31851a92e000adeae66",
				"name": "#front-page",
				"slug": "hash-front-page",
				"description": null,
				"feature_image": null,
				"visibility": "internal",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/404/"
			},
			{
				"id": "5d16450341acde0011a95253",
				"name": "Cloudflare Workers",
				"slug": "workers",
				"description": null,
				"feature_image": null,
				"visibility": "public",
				"meta_title": null,
				"meta_description": null,
				"og_image": null,
				"og_title": null,
				"og_description": null,
				"twitter_image": null,
				"twitter_title": null,
				"twitter_description": null,
				"codeinjection_head": null,
				"codeinjection_foot": null,
				"canonical_url": null,
				"accent_color": null,
				"url": "http://blog.cloudflare.com/tag/workers/"
			}
		],
		"title": "We've added JavaScript-native RPC to Cloudflare Workers",
		"twitter_description": null,
		"twitter_image": "http://blog.cloudflare.com/content/images/2024/04/We-ve-added-JavaScript-native-RPC-to-Cloudflare-Workers-OG.png",
		"twitter_title": null,
		"updated_at": "2024-04-05T17:20:49.000+01:00",
		"url": "http://blog.cloudflare.com/javascript-native-rpc/",
		"uuid": "9a803871-166c-4c6b-b3f2-429247d24cfb",
		"visibility": "public"
	}
}